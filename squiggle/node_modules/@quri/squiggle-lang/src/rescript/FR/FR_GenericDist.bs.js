'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var E_A$QuriSquiggleLang = require("../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../Utility/E/E_R.bs.js");
var SqError$QuriSquiggleLang = require("../SqError.bs.js");
var GenericDist$QuriSquiggleLang = require("../Distributions/GenericDist.bs.js");
var MagicNumbers$QuriSquiggleLang = require("../MagicNumbers.bs.js");
var SymbolicDist$QuriSquiggleLang = require("../Distributions/SymbolicDist/SymbolicDist.bs.js");
var Reducer_Lambda$QuriSquiggleLang = require("../Reducer/Reducer_Lambda.bs.js");
var DistributionOperation$QuriSquiggleLang = require("../Distributions/DistributionOperation.bs.js");
var FunctionRegistry_Core$QuriSquiggleLang = require("../FunctionRegistry/FunctionRegistry_Core.bs.js");

function arithmeticMap(r) {
  switch (r) {
    case "add" :
    case "dotAdd" :
        return "Add";
    case "divide" :
    case "dotDivide" :
        return "Divide";
    case "log" :
        return "Logarithm";
    case "dotMultiply" :
    case "multiply" :
        return "Multiply";
    case "dotPow" :
    case "pow" :
        return "Power";
    case "dotSubtract" :
    case "subtract" :
        return "Subtract";
    default:
      return "Multiply";
  }
}

function catchAndConvertTwoArgsToDists(args) {
  if (args.length !== 2) {
    return ;
  }
  var a = args[0];
  if (typeof a === "number") {
    return ;
  }
  switch (a.TAG | 0) {
    case /* IEvDistribution */4 :
        var a$1 = a._0;
        var b = args[1];
        if (typeof b === "number") {
          return ;
        }
        switch (b.TAG | 0) {
          case /* IEvDistribution */4 :
              return [
                      a$1,
                      b._0
                    ];
          case /* IEvNumber */6 :
              return [
                      a$1,
                      GenericDist$QuriSquiggleLang.fromFloat(b._0)
                    ];
          default:
            return ;
        }
    case /* IEvNumber */6 :
        var b$1 = args[1];
        if (typeof b$1 === "number" || b$1.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return [
                  GenericDist$QuriSquiggleLang.fromFloat(a._0),
                  b$1._0
                ];
        }
    default:
      return ;
  }
}

function toFloatFn(fnCall, dist, env) {
  return DistributionOperation$QuriSquiggleLang.run(env, {
              TAG: 0,
              _0: {
                NAME: "ToFloat",
                VAL: fnCall
              },
              _1: dist,
              [Symbol.for("name")]: "FromDist"
            });
}

function toStringFn(fnCall, dist, env) {
  return DistributionOperation$QuriSquiggleLang.run(env, {
              TAG: 0,
              _0: {
                NAME: "ToString",
                VAL: fnCall
              },
              _1: dist,
              [Symbol.for("name")]: "FromDist"
            });
}

function toBoolFn(fnCall, dist, env) {
  return DistributionOperation$QuriSquiggleLang.run(env, {
              TAG: 0,
              _0: {
                NAME: "ToBool",
                VAL: fnCall
              },
              _1: dist,
              [Symbol.for("name")]: "FromDist"
            });
}

function toDistFn(fnCall, dist, env) {
  return DistributionOperation$QuriSquiggleLang.run(env, {
              TAG: 0,
              _0: {
                NAME: "ToDist",
                VAL: fnCall
              },
              _1: dist,
              [Symbol.for("name")]: "FromDist"
            });
}

function twoDiststoDistFn(direction, arithmetic, dist1, dist2, env) {
  return DistributionOperation$QuriSquiggleLang.run(env, {
              TAG: 0,
              _0: {
                NAME: "ToDistCombination",
                VAL: [
                  direction,
                  arithmeticMap(arithmetic),
                  {
                    NAME: "Dist",
                    VAL: dist2
                  }
                ]
              },
              _1: dist1,
              [Symbol.for("name")]: "FromDist"
            });
}

function parseNumber(args) {
  if (typeof args === "number" || args.TAG !== /* IEvNumber */6) {
    return {
            TAG: 1,
            _0: "Not a number",
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: args._0,
            [Symbol.for("name")]: "Ok"
          };
  }
}

function parseNumberArray(ags) {
  return E_A$QuriSquiggleLang.R.firstErrorOrOpen(E_A$QuriSquiggleLang.fmap(ags, parseNumber));
}

function parseDist(args) {
  if (typeof args === "number") {
    return {
            TAG: 1,
            _0: "Not a distribution",
            [Symbol.for("name")]: "Error"
          };
  }
  switch (args.TAG | 0) {
    case /* IEvDistribution */4 :
        return {
                TAG: 0,
                _0: args._0,
                [Symbol.for("name")]: "Ok"
              };
    case /* IEvNumber */6 :
        return {
                TAG: 0,
                _0: GenericDist$QuriSquiggleLang.fromFloat(args._0),
                [Symbol.for("name")]: "Ok"
              };
    default:
      return {
              TAG: 1,
              _0: "Not a distribution",
              [Symbol.for("name")]: "Error"
            };
  }
}

function parseDistributionArray(ags) {
  return E_A$QuriSquiggleLang.R.firstErrorOrOpen(E_A$QuriSquiggleLang.fmap(ags, parseDist));
}

function mixtureWithGivenWeights(distributions, weights, env) {
  if (E_A$QuriSquiggleLang.length(distributions) === E_A$QuriSquiggleLang.length(weights)) {
    return DistributionOperation$QuriSquiggleLang.run(env, {
                TAG: 3,
                _0: E_A$QuriSquiggleLang.zip(distributions, weights),
                [Symbol.for("name")]: "Mixture"
              });
  } else {
    return {
            TAG: 5,
            _0: {
              TAG: 1,
              _0: "Error, mixture call has different number of distributions and weights",
              [Symbol.for("name")]: "ArgumentError"
            },
            [Symbol.for("name")]: "GenDistError"
          };
  }
}

function mixtureWithDefaultWeights(distributions, env) {
  var length = E_A$QuriSquiggleLang.length(distributions);
  var weights = Belt_Array.make(length, 1.0 / length);
  return mixtureWithGivenWeights(distributions, weights, env);
}

function mixture(args, env) {
  var exit = 0;
  var len = args.length;
  if (len >= 3) {
    exit = 1;
  } else {
    switch (len) {
      case 0 :
          exit = 1;
          break;
      case 1 :
          var distributions = args[0];
          if (typeof distributions === "number") {
            exit = 1;
          } else {
            if (distributions.TAG === /* IEvArray */0) {
              var distrs = parseDistributionArray(distributions._0);
              if (distrs.TAG === /* Ok */0) {
                return mixtureWithDefaultWeights(distrs._0, env);
              } else {
                return {
                        TAG: 5,
                        _0: {
                          TAG: 1,
                          _0: distrs._0,
                          [Symbol.for("name")]: "ArgumentError"
                        },
                        [Symbol.for("name")]: "GenDistError"
                      };
              }
            }
            exit = 1;
          }
          break;
      case 2 :
          var distributions$1 = args[0];
          if (typeof distributions$1 === "number" || distributions$1.TAG !== /* IEvArray */0) {
            exit = 1;
          } else {
            var weights = args[1];
            if (typeof weights === "number") {
              exit = 1;
            } else {
              if (weights.TAG === /* IEvArray */0) {
                var match = parseDistributionArray(distributions$1._0);
                var match$1 = parseNumberArray(weights._0);
                if (match.TAG === /* Ok */0) {
                  if (match$1.TAG === /* Ok */0) {
                    return mixtureWithGivenWeights(match._0, match$1._0, env);
                  } else {
                    return {
                            TAG: 5,
                            _0: {
                              TAG: 1,
                              _0: match$1._0,
                              [Symbol.for("name")]: "ArgumentError"
                            },
                            [Symbol.for("name")]: "GenDistError"
                          };
                  }
                }
                var err = match._0;
                if (match$1.TAG === /* Ok */0) {
                  return {
                          TAG: 5,
                          _0: {
                            TAG: 1,
                            _0: err,
                            [Symbol.for("name")]: "ArgumentError"
                          },
                          [Symbol.for("name")]: "GenDistError"
                        };
                } else {
                  return {
                          TAG: 5,
                          _0: {
                            TAG: 1,
                            _0: "" + err + "|" + match$1._0 + "",
                            [Symbol.for("name")]: "ArgumentError"
                          },
                          [Symbol.for("name")]: "GenDistError"
                        };
                }
              }
              exit = 1;
            }
          }
          break;
      
    }
  }
  if (exit === 1) {
    var match$2 = E_A$QuriSquiggleLang.last(args);
    var exit$1 = 0;
    if (match$2 === undefined) {
      return {
              TAG: 5,
              _0: {
                TAG: 1,
                _0: "Last argument of mx must be array or distribution",
                [Symbol.for("name")]: "ArgumentError"
              },
              [Symbol.for("name")]: "GenDistError"
            };
    }
    if (typeof match$2 === "number") {
      return {
              TAG: 5,
              _0: {
                TAG: 1,
                _0: "Last argument of mx must be array or distribution",
                [Symbol.for("name")]: "ArgumentError"
              },
              [Symbol.for("name")]: "GenDistError"
            };
    }
    switch (match$2.TAG | 0) {
      case /* IEvArray */0 :
          var weights$1 = parseNumberArray(match$2._0);
          var distributions$2 = parseDistributionArray(E_A$QuriSquiggleLang.slice(args, 0, E_A$QuriSquiggleLang.length(args) - 1 | 0));
          var err$1 = E_R$QuriSquiggleLang.merge(distributions$2, weights$1);
          if (err$1.TAG !== /* Ok */0) {
            return {
                    TAG: 5,
                    _0: {
                      TAG: 1,
                      _0: err$1._0,
                      [Symbol.for("name")]: "ArgumentError"
                    },
                    [Symbol.for("name")]: "GenDistError"
                  };
          }
          var match$3 = err$1._0;
          return mixtureWithGivenWeights(match$3[0], match$3[1], env);
      case /* IEvDistribution */4 :
      case /* IEvNumber */6 :
          exit$1 = 2;
          break;
      default:
        return {
                TAG: 5,
                _0: {
                  TAG: 1,
                  _0: "Last argument of mx must be array or distribution",
                  [Symbol.for("name")]: "ArgumentError"
                },
                [Symbol.for("name")]: "GenDistError"
              };
    }
    if (exit$1 === 2) {
      var distributions$3 = parseDistributionArray(args);
      if (distributions$3.TAG === /* Ok */0) {
        return mixtureWithDefaultWeights(distributions$3._0, env);
      } else {
        return {
                TAG: 5,
                _0: {
                  TAG: 1,
                  _0: distributions$3._0,
                  [Symbol.for("name")]: "ArgumentError"
                },
                [Symbol.for("name")]: "GenDistError"
              };
      }
    }
    
  }
  
}

var Helpers = {
  arithmeticMap: arithmeticMap,
  catchAndConvertTwoArgsToDists: catchAndConvertTwoArgsToDists,
  toFloatFn: toFloatFn,
  toStringFn: toStringFn,
  toBoolFn: toBoolFn,
  toDistFn: toDistFn,
  twoDiststoDistFn: twoDiststoDistFn,
  parseNumber: parseNumber,
  parseNumberArray: parseNumberArray,
  parseDist: parseDist,
  parseDistributionArray: parseDistributionArray,
  mixtureWithGivenWeights: mixtureWithGivenWeights,
  mixtureWithDefaultWeights: mixtureWithDefaultWeights,
  mixture: mixture
};

function threeFloat(name) {
  if (name === "triangular") {
    return {
            TAG: 0,
            _0: SymbolicDist$QuriSquiggleLang.Triangular.make,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Unreachable state",
            [Symbol.for("name")]: "Error"
          };
  }
}

function symbolicResultToOutput(symbolicResult) {
  if (symbolicResult.TAG === /* Ok */0) {
    return {
            TAG: 0,
            _0: {
              TAG: 2,
              _0: symbolicResult._0,
              [Symbol.for("name")]: "Symbolic"
            },
            [Symbol.for("name")]: "Dist"
          };
  } else {
    return {
            TAG: 5,
            _0: {
              TAG: 7,
              _0: symbolicResult._0,
              [Symbol.for("name")]: "OtherError"
            },
            [Symbol.for("name")]: "GenDistError"
          };
  }
}

var SymbolicConstructors = {
  threeFloat: threeFloat,
  symbolicResultToOutput: symbolicResultToOutput
};

function dispatchToGenericOutput(call, env) {
  var args = call[1];
  var fnName = call[0];
  var exit = 0;
  switch (fnName) {
    case "cdf" :
        if (args.length !== 2) {
          return ;
        }
        var dist = args[0];
        if (typeof dist === "number") {
          return ;
        }
        if (dist.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float = args[1];
        if (typeof $$float === "number" || $$float.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toFloatFn({
                      NAME: "Cdf",
                      VAL: $$float._0
                    }, dist._0, env);
        }
    case "dotExp" :
        if (args.length !== 1) {
          return ;
        }
        var a = args[0];
        if (typeof a === "number" || a.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return twoDiststoDistFn(/* Pointwise */0, "dotPow", GenericDist$QuriSquiggleLang.fromFloat(MagicNumbers$QuriSquiggleLang.$$Math.e), a._0, env);
        }
    case "dotAdd" :
    case "dotDivide" :
    case "dotMultiply" :
    case "dotPow" :
    case "dotSubtract" :
        exit = 3;
        break;
    case "exp" :
        if (args.length !== 1) {
          return ;
        }
        var a$1 = args[0];
        if (typeof a$1 === "number" || a$1.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return twoDiststoDistFn({
                      _0: /* AsDefault */0,
                      [Symbol.for("name")]: "Algebraic"
                    }, "pow", GenericDist$QuriSquiggleLang.fromFloat(MagicNumbers$QuriSquiggleLang.$$Math.e), a$1._0, env);
        }
    case "inspect" :
        if (args.length !== 1) {
          return ;
        }
        var dist$1 = args[0];
        if (typeof dist$1 === "number" || dist$1.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toDistFn(/* Inspect */2, dist$1._0, env);
        }
    case "integralSum" :
        if (args.length !== 1) {
          return ;
        }
        var dist$2 = args[0];
        if (typeof dist$2 === "number" || dist$2.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toFloatFn("IntegralSum", dist$2._0, env);
        }
    case "inv" :
        if (args.length !== 2) {
          return ;
        }
        var dist$3 = args[0];
        if (typeof dist$3 === "number") {
          return ;
        }
        if (dist$3.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$1 = args[1];
        if (typeof $$float$1 === "number" || $$float$1.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toFloatFn({
                      NAME: "Inv",
                      VAL: $$float$1._0
                    }, dist$3._0, env);
        }
    case "isNormalized" :
        if (args.length !== 1) {
          return ;
        }
        var dist$4 = args[0];
        if (typeof dist$4 === "number" || dist$4.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toBoolFn(/* IsNormalized */0, dist$4._0, env);
        }
    case "log" :
        if (args.length !== 1) {
          exit = 2;
        } else {
          var a$2 = args[0];
          if (typeof a$2 === "number") {
            exit = 2;
          } else {
            if (a$2.TAG === /* IEvDistribution */4) {
              return twoDiststoDistFn({
                          _0: /* AsDefault */0,
                          [Symbol.for("name")]: "Algebraic"
                        }, "log", a$2._0, GenericDist$QuriSquiggleLang.fromFloat(MagicNumbers$QuriSquiggleLang.$$Math.e), env);
            }
            exit = 2;
          }
        }
        break;
    case "log10" :
        if (args.length !== 1) {
          return ;
        }
        var a$3 = args[0];
        if (typeof a$3 === "number" || a$3.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return twoDiststoDistFn({
                      _0: /* AsDefault */0,
                      [Symbol.for("name")]: "Algebraic"
                    }, "log", a$3._0, GenericDist$QuriSquiggleLang.fromFloat(10.0), env);
        }
    case "mixture" :
    case "mx" :
        return mixture(args, env);
    case "normalize" :
        if (args.length !== 1) {
          return ;
        }
        var dist$5 = args[0];
        if (typeof dist$5 === "number" || dist$5.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toDistFn(/* Normalize */0, dist$5._0, env);
        }
    case "pdf" :
        if (args.length !== 2) {
          return ;
        }
        var dist$6 = args[0];
        if (typeof dist$6 === "number") {
          return ;
        }
        if (dist$6.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$2 = args[1];
        if (typeof $$float$2 === "number" || $$float$2.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toFloatFn({
                      NAME: "Pdf",
                      VAL: $$float$2._0
                    }, dist$6._0, env);
        }
    case "quantile" :
        if (args.length !== 2) {
          return ;
        }
        var dist$7 = args[0];
        if (typeof dist$7 === "number") {
          return ;
        }
        if (dist$7.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$3 = args[1];
        if (typeof $$float$3 === "number" || $$float$3.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toFloatFn({
                      NAME: "Inv",
                      VAL: $$float$3._0
                    }, dist$7._0, env);
        }
    case "sample" :
        if (args.length !== 1) {
          return ;
        }
        var dist$8 = args[0];
        if (typeof dist$8 === "number" || dist$8.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toFloatFn("Sample", dist$8._0, env);
        }
    case "sampleN" :
        if (args.length !== 2) {
          return ;
        }
        var dist$9 = args[0];
        if (typeof dist$9 === "number") {
          return ;
        }
        if (dist$9.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var n = args[1];
        if (typeof n === "number" || n.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return {
                  TAG: 3,
                  _0: GenericDist$QuriSquiggleLang.sampleN(dist$9._0, n._0 | 0),
                  [Symbol.for("name")]: "FloatArray"
                };
        }
    case "scaleExp" :
        if (args.length !== 1) {
          return ;
        }
        var dist$10 = args[0];
        if (typeof dist$10 === "number" || dist$10.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toDistFn({
                      TAG: 1,
                      _0: "Power",
                      _1: MagicNumbers$QuriSquiggleLang.$$Math.e,
                      [Symbol.for("name")]: "Scale"
                    }, dist$10._0, env);
        }
    case "scaleLog" :
        var len = args.length;
        if (len >= 3) {
          return ;
        }
        switch (len) {
          case 0 :
              return ;
          case 1 :
              var dist$11 = args[0];
              if (typeof dist$11 === "number" || dist$11.TAG !== /* IEvDistribution */4) {
                return ;
              } else {
                return toDistFn({
                            TAG: 1,
                            _0: "Logarithm",
                            _1: MagicNumbers$QuriSquiggleLang.$$Math.e,
                            [Symbol.for("name")]: "Scale"
                          }, dist$11._0, env);
              }
          case 2 :
              var dist$12 = args[0];
              if (typeof dist$12 === "number") {
                return ;
              }
              if (dist$12.TAG !== /* IEvDistribution */4) {
                return ;
              }
              var $$float$4 = args[1];
              if (typeof $$float$4 === "number" || $$float$4.TAG !== /* IEvNumber */6) {
                return ;
              } else {
                return toDistFn({
                            TAG: 1,
                            _0: "Logarithm",
                            _1: $$float$4._0,
                            [Symbol.for("name")]: "Scale"
                          }, dist$12._0, env);
              }
          
        }
    case "scaleLog10" :
        if (args.length !== 1) {
          return ;
        }
        var dist$13 = args[0];
        if (typeof dist$13 === "number" || dist$13.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toDistFn({
                      TAG: 1,
                      _0: "Logarithm",
                      _1: 10.0,
                      [Symbol.for("name")]: "Scale"
                    }, dist$13._0, env);
        }
    case "scaleLogWithThreshold" :
        if (args.length !== 3) {
          return ;
        }
        var dist$14 = args[0];
        if (typeof dist$14 === "number") {
          return ;
        }
        if (dist$14.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var base = args[1];
        if (typeof base === "number") {
          return ;
        }
        if (base.TAG !== /* IEvNumber */6) {
          return ;
        }
        var eps = args[2];
        if (typeof eps === "number" || eps.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 1,
                      _0: {
                        NAME: "LogarithmWithThreshold",
                        VAL: eps._0
                      },
                      _1: base._0,
                      [Symbol.for("name")]: "Scale"
                    }, dist$14._0, env);
        }
    case "scaleMultiply" :
        if (args.length !== 2) {
          return ;
        }
        var dist$15 = args[0];
        if (typeof dist$15 === "number") {
          return ;
        }
        if (dist$15.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$5 = args[1];
        if (typeof $$float$5 === "number" || $$float$5.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 1,
                      _0: "Multiply",
                      _1: $$float$5._0,
                      [Symbol.for("name")]: "Scale"
                    }, dist$15._0, env);
        }
    case "scalePow" :
        if (args.length !== 2) {
          return ;
        }
        var dist$16 = args[0];
        if (typeof dist$16 === "number") {
          return ;
        }
        if (dist$16.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$6 = args[1];
        if (typeof $$float$6 === "number" || $$float$6.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 1,
                      _0: "Power",
                      _1: $$float$6._0,
                      [Symbol.for("name")]: "Scale"
                    }, dist$16._0, env);
        }
    case "sparkline" :
        var len$1 = args.length;
        if (len$1 >= 3) {
          return ;
        }
        switch (len$1) {
          case 0 :
              return ;
          case 1 :
              var dist$17 = args[0];
              if (typeof dist$17 === "number" || dist$17.TAG !== /* IEvDistribution */4) {
                return ;
              } else {
                return toStringFn({
                            _0: MagicNumbers$QuriSquiggleLang.Environment.sparklineLength,
                            [Symbol.for("name")]: "ToSparkline"
                          }, dist$17._0, env);
              }
          case 2 :
              var dist$18 = args[0];
              if (typeof dist$18 === "number") {
                return ;
              }
              if (dist$18.TAG !== /* IEvDistribution */4) {
                return ;
              }
              var n$1 = args[1];
              if (typeof n$1 === "number" || n$1.TAG !== /* IEvNumber */6) {
                return ;
              } else {
                return toStringFn({
                            _0: n$1._0 | 0,
                            [Symbol.for("name")]: "ToSparkline"
                          }, dist$18._0, env);
              }
          
        }
    case "add" :
    case "divide" :
    case "multiply" :
    case "pow" :
    case "subtract" :
        exit = 2;
        break;
    case "toPointSet" :
        if (args.length !== 1) {
          return ;
        }
        var dist$19 = args[0];
        if (typeof dist$19 === "number" || dist$19.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toDistFn(/* ToPointSet */1, dist$19._0, env);
        }
    case "toString" :
        if (args.length !== 1) {
          return ;
        }
        var dist$20 = args[0];
        if (typeof dist$20 === "number" || dist$20.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return toStringFn(/* ToString */0, dist$20._0, env);
        }
    case "triangular" :
        if (args.length !== 3) {
          return ;
        }
        var f1 = args[0];
        if (typeof f1 === "number") {
          return ;
        }
        if (f1.TAG !== /* IEvNumber */6) {
          return ;
        }
        var f1$1 = f1._0;
        var f2 = args[1];
        if (typeof f2 === "number") {
          return ;
        }
        if (f2.TAG !== /* IEvNumber */6) {
          return ;
        }
        var f2$1 = f2._0;
        var f3 = args[2];
        if (typeof f3 === "number") {
          return ;
        }
        if (f3.TAG !== /* IEvNumber */6) {
          return ;
        }
        var f3$1 = f3._0;
        return symbolicResultToOutput(E_R$QuriSquiggleLang.bind(threeFloat(fnName), (function (r) {
                          return Curry._3(r, f1$1, f2$1, f3$1);
                        })));
    case "truncate" :
        if (args.length !== 3) {
          return ;
        }
        var dist$21 = args[0];
        if (typeof dist$21 === "number") {
          return ;
        }
        if (dist$21.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var float1 = args[1];
        if (typeof float1 === "number") {
          return ;
        }
        if (float1.TAG !== /* IEvNumber */6) {
          return ;
        }
        var float2 = args[2];
        if (typeof float2 === "number" || float2.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 2,
                      _0: float1._0,
                      _1: float2._0,
                      [Symbol.for("name")]: "Truncate"
                    }, dist$21._0, env);
        }
    case "truncateLeft" :
        if (args.length !== 2) {
          return ;
        }
        var dist$22 = args[0];
        if (typeof dist$22 === "number") {
          return ;
        }
        if (dist$22.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$7 = args[1];
        if (typeof $$float$7 === "number" || $$float$7.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 2,
                      _0: $$float$7._0,
                      _1: undefined,
                      [Symbol.for("name")]: "Truncate"
                    }, dist$22._0, env);
        }
    case "truncateRight" :
        if (args.length !== 2) {
          return ;
        }
        var dist$23 = args[0];
        if (typeof dist$23 === "number") {
          return ;
        }
        if (dist$23.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var $$float$8 = args[1];
        if (typeof $$float$8 === "number" || $$float$8.TAG !== /* IEvNumber */6) {
          return ;
        } else {
          return toDistFn({
                      TAG: 2,
                      _0: undefined,
                      _1: $$float$8._0,
                      [Symbol.for("name")]: "Truncate"
                    }, dist$23._0, env);
        }
    case "unaryMinus" :
        if (args.length !== 1) {
          return ;
        }
        var a$4 = args[0];
        if (typeof a$4 === "number" || a$4.TAG !== /* IEvDistribution */4) {
          return ;
        } else {
          return twoDiststoDistFn({
                      _0: /* AsDefault */0,
                      [Symbol.for("name")]: "Algebraic"
                    }, "multiply", a$4._0, GenericDist$QuriSquiggleLang.fromFloat(-1.0), env);
        }
    case "max" :
    case "mean" :
    case "min" :
    case "mode" :
    case "stdev" :
    case "variance" :
        exit = 1;
        break;
    default:
      return ;
  }
  switch (exit) {
    case 1 :
        if (args.length !== 1) {
          return ;
        }
        var dist$24 = args[0];
        if (typeof dist$24 === "number") {
          return ;
        }
        if (dist$24.TAG !== /* IEvDistribution */4) {
          return ;
        }
        var fn;
        switch (fnName) {
          case "max" :
              fn = "Max";
              break;
          case "mean" :
              fn = "Mean";
              break;
          case "min" :
              fn = "Min";
              break;
          case "mode" :
              fn = "Mode";
              break;
          case "stdev" :
              fn = "Stdev";
              break;
          case "variance" :
              fn = "Variance";
              break;
          default:
            fn = "Mean";
        }
        return toFloatFn(fn, dist$24._0, env);
    case 2 :
        if (args.length !== 2) {
          return ;
        } else {
          return E_O$QuriSquiggleLang.fmap(catchAndConvertTwoArgsToDists(args), (function (param) {
                        return twoDiststoDistFn({
                                    _0: /* AsDefault */0,
                                    [Symbol.for("name")]: "Algebraic"
                                  }, fnName, param[0], param[1], env);
                      }));
        }
    case 3 :
        if (args.length !== 2) {
          return ;
        } else {
          return E_O$QuriSquiggleLang.fmap(catchAndConvertTwoArgsToDists(args), (function (param) {
                        return twoDiststoDistFn(/* Pointwise */0, fnName, param[0], param[1], env);
                      }));
        }
    
  }
}

function genericOutputToReducerValue(o) {
  switch (o.TAG | 0) {
    case /* Dist */0 :
        return {
                TAG: 0,
                _0: {
                  TAG: 4,
                  _0: o._0,
                  [Symbol.for("name")]: "IEvDistribution"
                },
                [Symbol.for("name")]: "Ok"
              };
    case /* Float */1 :
        return {
                TAG: 0,
                _0: {
                  TAG: 6,
                  _0: o._0,
                  [Symbol.for("name")]: "IEvNumber"
                },
                [Symbol.for("name")]: "Ok"
              };
    case /* String */2 :
        return {
                TAG: 0,
                _0: {
                  TAG: 8,
                  _0: o._0,
                  [Symbol.for("name")]: "IEvString"
                },
                [Symbol.for("name")]: "Ok"
              };
    case /* FloatArray */3 :
        return {
                TAG: 0,
                _0: {
                  TAG: 0,
                  _0: E_A$QuriSquiggleLang.fmap(o._0, (function (r) {
                          return {
                                  TAG: 6,
                                  _0: r,
                                  [Symbol.for("name")]: "IEvNumber"
                                };
                        })),
                  [Symbol.for("name")]: "IEvArray"
                },
                [Symbol.for("name")]: "Ok"
              };
    case /* Bool */4 :
        return {
                TAG: 0,
                _0: {
                  TAG: 1,
                  _0: o._0,
                  [Symbol.for("name")]: "IEvBool"
                },
                [Symbol.for("name")]: "Ok"
              };
    case /* GenDistError */5 :
        return {
                TAG: 1,
                _0: {
                  TAG: 2,
                  _0: o._0,
                  [Symbol.for("name")]: "REDistributionError"
                },
                [Symbol.for("name")]: "Error"
              };
    
  }
}

function dispatch(call, environment) {
  var o = dispatchToGenericOutput(call, environment);
  if (o !== undefined) {
    return genericOutputToReducerValue(o);
  } else {
    return SqError$QuriSquiggleLang.Message.$$throw({
                TAG: 15,
                _0: "Internal error in FR_GenericDist implementation",
                [Symbol.for("name")]: "REOther"
              });
  }
}

var Old = {
  Helpers: Helpers,
  SymbolicConstructors: SymbolicConstructors,
  dispatchToGenericOutput: dispatchToGenericOutput,
  genericOutputToReducerValue: genericOutputToReducerValue,
  dispatch: dispatch
};

function makeProxyFn(name, inputs) {
  return FunctionRegistry_Core$QuriSquiggleLang.$$Function.make(name, "", false, [FunctionRegistry_Core$QuriSquiggleLang.FnDefinition.make(name, inputs, (function (inputs, context, param) {
                      return dispatch([
                                  name,
                                  inputs
                                ], context.environment);
                    }), undefined)], undefined, undefined, undefined, undefined, undefined);
}

function makeOperationFns(param) {
  var ops = [
    "add",
    "multiply",
    "subtract",
    "divide",
    "pow",
    "log",
    "dotAdd",
    "dotMultiply",
    "dotSubtract",
    "dotDivide",
    "dotPow"
  ];
  var twoArgTypes = [
    [
      /* FRTypeDist */6,
      /* FRTypeNumber */0
    ],
    [
      /* FRTypeNumber */0,
      /* FRTypeDist */6
    ],
    [
      /* FRTypeDist */6,
      /* FRTypeDist */6
    ]
  ];
  return E_A$QuriSquiggleLang.concatMany(E_A$QuriSquiggleLang.fmap(ops, (function (op) {
                    return E_A$QuriSquiggleLang.fmap(twoArgTypes, (function (types) {
                                  return makeProxyFn(op, types);
                                }));
                  })));
}

var library = E_A$QuriSquiggleLang.concatMany([
      [
        makeProxyFn("triangular", [
              /* FRTypeNumber */0,
              /* FRTypeNumber */0,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("sample", [/* FRTypeDist */6]),
        makeProxyFn("sampleN", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("mean", [/* FRTypeDist */6]),
        makeProxyFn("stdev", [/* FRTypeDist */6]),
        makeProxyFn("variance", [/* FRTypeDist */6]),
        makeProxyFn("min", [/* FRTypeDist */6]),
        makeProxyFn("max", [/* FRTypeDist */6]),
        makeProxyFn("mode", [/* FRTypeDist */6]),
        makeProxyFn("integralSum", [/* FRTypeDist */6]),
        makeProxyFn("toString", [/* FRTypeDist */6]),
        makeProxyFn("sparkline", [/* FRTypeDist */6]),
        makeProxyFn("sparkline", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("exp", [/* FRTypeDist */6]),
        makeProxyFn("normalize", [/* FRTypeDist */6]),
        makeProxyFn("isNormalized", [/* FRTypeDist */6]),
        makeProxyFn("toPointSet", [/* FRTypeDist */6]),
        makeProxyFn("scaleLog", [/* FRTypeDist */6]),
        makeProxyFn("scaleLog10", [/* FRTypeDist */6]),
        makeProxyFn("scaleLog", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("scaleLogWithThreshold", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("scaleMultiply", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("scalePow", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("scaleExp", [/* FRTypeDist */6]),
        makeProxyFn("cdf", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("pdf", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("inv", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("quantile", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("inspect", [/* FRTypeDist */6]),
        makeProxyFn("truncateLeft", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("truncateRight", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("truncate", [
              /* FRTypeDist */6,
              /* FRTypeNumber */0,
              /* FRTypeNumber */0
            ]),
        makeProxyFn("log", [/* FRTypeDist */6]),
        makeProxyFn("log10", [/* FRTypeDist */6]),
        makeProxyFn("unaryMinus", [/* FRTypeDist */6]),
        makeProxyFn("dotExp", [/* FRTypeDist */6])
      ],
      makeOperationFns(undefined)
    ]);

var mxLambda = Reducer_Lambda$QuriSquiggleLang.makeFFILambda("mx", (function (inputs, context, param) {
        var value = dispatch([
              "mx",
              inputs
            ], context.environment);
        if (value.TAG === /* Ok */0) {
          return value._0;
        } else {
          return SqError$QuriSquiggleLang.Message.$$throw(value._0);
        }
      }));

exports.Old = Old;
exports.makeProxyFn = makeProxyFn;
exports.makeOperationFns = makeOperationFns;
exports.library = library;
exports.mxLambda = mxLambda;
/* library Not a pure module */
