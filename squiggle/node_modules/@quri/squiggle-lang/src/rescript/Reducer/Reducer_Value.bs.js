'use strict';

var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var SqError$QuriSquiggleLang = require("../SqError.bs.js");
var DateTime$QuriSquiggleLang = require("../Utility/DateTime.bs.js");
var Declaration$QuriSquiggleLang = require("../Utility/Declaration.bs.js");
var GenericDist$QuriSquiggleLang = require("../Distributions/GenericDist.bs.js");

function toString(aValue) {
  if (typeof aValue === "number") {
    return toStringVoid;
  }
  switch (aValue.TAG | 0) {
    case /* IEvArray */0 :
        return toStringArray(aValue._0);
    case /* IEvDate */2 :
        return DateTime$QuriSquiggleLang.$$Date.toString(aValue._0);
    case /* IEvDeclaration */3 :
        return toStringDeclaration(aValue._0);
    case /* IEvDistribution */4 :
        return GenericDist$QuriSquiggleLang.toString(aValue._0);
    case /* IEvLambda */5 :
        return toStringLambda(aValue._0);
    case /* IEvBool */1 :
    case /* IEvNumber */6 :
        return String(aValue._0);
    case /* IEvRecord */7 :
        return toStringMap(aValue._0);
    case /* IEvString */8 :
        return toStringString(aValue._0);
    case /* IEvTimeDuration */9 :
        return DateTime$QuriSquiggleLang.Duration.toString(aValue._0);
    
  }
}

function toStringMap(aMap) {
  var pairs = Belt_MapString.toArray(aMap).map(function (param) {
          return "" + param[0] + ": " + toString(param[1]) + "";
        }).toString();
  return "{" + pairs + "}";
}

function toStringDeclaration(d) {
  return Declaration$QuriSquiggleLang.toString(d, (function (r) {
                return toString({
                            TAG: 5,
                            _0: r,
                            [Symbol.for("name")]: "IEvLambda"
                          });
              }));
}

function toStringString(aString) {
  return "'" + aString + "'";
}

function toStringArray(anArray) {
  var args = anArray.map(toString).toString();
  return "[" + args + "]";
}

function toStringLambda(lambdaValue) {
  if (lambdaValue.TAG === /* FnLambda */0) {
    return "lambda(" + lambdaValue.parameters.toString() + "=>internal code)";
  } else {
    return "Builtin function";
  }
}

var toStringVoid = "()";

function toStringTimeDuration(t) {
  return DateTime$QuriSquiggleLang.Duration.toString(t);
}

var toStringDistribution = GenericDist$QuriSquiggleLang.toString;

function toStringDate(date) {
  return DateTime$QuriSquiggleLang.$$Date.toString(date);
}

function toStringNumber(aNumber) {
  return String(aNumber);
}

function toStringBool(aBool) {
  return String(aBool);
}

var toStringRecord = toStringMap;

function toStringCall(fName) {
  return ":" + fName + "";
}

function toStringSymbol(aString) {
  return ":" + aString + "";
}

function toStringWithType(aValue) {
  if (typeof aValue === "number") {
    return "Void";
  }
  switch (aValue.TAG | 0) {
    case /* IEvArray */0 :
        return "Array::" + toString(aValue) + "";
    case /* IEvBool */1 :
        return "Bool::" + toString(aValue) + "";
    case /* IEvDeclaration */3 :
        return "Declaration::" + toString(aValue) + "";
    case /* IEvDistribution */4 :
        return "Distribution::" + toString(aValue) + "";
    case /* IEvLambda */5 :
        return "Lambda::" + toString(aValue) + "";
    case /* IEvNumber */6 :
        return "Number::" + toString(aValue) + "";
    case /* IEvRecord */7 :
        return "Record::" + toString(aValue) + "";
    case /* IEvString */8 :
        return "String::" + toString(aValue) + "";
    case /* IEvDate */2 :
    case /* IEvTimeDuration */9 :
        return "Date::" + toString(aValue) + "";
    
  }
}

function argsToString(args) {
  return args.map(toString).toString();
}

function toStringFunctionCall(param) {
  return "" + param[0] + "(" + argsToString(param[1]) + ")";
}

function toStringResult(x) {
  if (x.TAG === /* Ok */0) {
    return "Ok(" + toString(x._0) + ")";
  } else {
    return "Error(" + SqError$QuriSquiggleLang.toString(x._0) + ")";
  }
}

function toStringResultOkless(codeResult) {
  if (codeResult.TAG === /* Ok */0) {
    return toString(codeResult._0);
  } else {
    return "Error(" + SqError$QuriSquiggleLang.toString(codeResult._0) + ")";
  }
}

function valueToValueType(value) {
  if (typeof value === "number") {
    return /* EvtVoid */10;
  }
  switch (value.TAG | 0) {
    case /* IEvArray */0 :
        return /* EvtArray */0;
    case /* IEvBool */1 :
        return /* EvtBool */1;
    case /* IEvDate */2 :
        return /* EvtDate */2;
    case /* IEvDeclaration */3 :
        return /* EvtDeclaration */3;
    case /* IEvDistribution */4 :
        return /* EvtDistribution */4;
    case /* IEvLambda */5 :
        return /* EvtLambda */5;
    case /* IEvNumber */6 :
        return /* EvtNumber */6;
    case /* IEvRecord */7 :
        return /* EvtRecord */7;
    case /* IEvString */8 :
        return /* EvtString */8;
    case /* IEvTimeDuration */9 :
        return /* EvtTimeDuration */9;
    
  }
}

function functionCallToCallSignature(functionCall) {
  return {
          _0: functionCall[0],
          _1: functionCall[1].map(valueToValueType),
          [Symbol.for("name")]: "CallSignature"
        };
}

function valueTypeToString(valueType) {
  switch (valueType) {
    case /* EvtArray */0 :
        return "Array";
    case /* EvtBool */1 :
        return "Bool";
    case /* EvtDate */2 :
        return "Date";
    case /* EvtDeclaration */3 :
        return "Declaration";
    case /* EvtDistribution */4 :
        return "Distribution";
    case /* EvtLambda */5 :
        return "Lambda";
    case /* EvtNumber */6 :
        return "Number";
    case /* EvtRecord */7 :
        return "Record";
    case /* EvtString */8 :
        return "String";
    case /* EvtTimeDuration */9 :
        return "Duration";
    case /* EvtVoid */10 :
        return "Void";
    
  }
}

function functionCallSignatureToString(functionCallSignature) {
  return "" + functionCallSignature._0 + "(" + functionCallSignature._1.map(valueTypeToString).toString() + ")";
}

function arrayToValueArray(arr) {
  return arr;
}

function resultToValue(rExpression) {
  if (rExpression.TAG === /* Ok */0) {
    return rExpression._0;
  } else {
    return SqError$QuriSquiggleLang.Message.$$throw(rExpression._0);
  }
}

var recordToKeyValuePairs = Belt_MapString.toArray;

var T;

exports.T = T;
exports.toString = toString;
exports.toStringArray = toStringArray;
exports.toStringBool = toStringBool;
exports.toStringCall = toStringCall;
exports.toStringDate = toStringDate;
exports.toStringDeclaration = toStringDeclaration;
exports.toStringDistribution = toStringDistribution;
exports.toStringLambda = toStringLambda;
exports.toStringNumber = toStringNumber;
exports.toStringRecord = toStringRecord;
exports.toStringString = toStringString;
exports.toStringSymbol = toStringSymbol;
exports.toStringTimeDuration = toStringTimeDuration;
exports.toStringVoid = toStringVoid;
exports.toStringMap = toStringMap;
exports.toStringWithType = toStringWithType;
exports.argsToString = argsToString;
exports.toStringFunctionCall = toStringFunctionCall;
exports.toStringResult = toStringResult;
exports.toStringResultOkless = toStringResultOkless;
exports.valueToValueType = valueToValueType;
exports.functionCallToCallSignature = functionCallToCallSignature;
exports.valueTypeToString = valueTypeToString;
exports.functionCallSignatureToString = functionCallSignatureToString;
exports.arrayToValueArray = arrayToValueArray;
exports.resultToValue = resultToValue;
exports.recordToKeyValuePairs = recordToKeyValuePairs;
/* SqError-QuriSquiggleLang Not a pure module */
