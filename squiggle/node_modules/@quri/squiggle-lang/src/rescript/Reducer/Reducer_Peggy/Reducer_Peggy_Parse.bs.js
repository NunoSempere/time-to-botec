'use strict';

var Js_exn = require("@rescript/std/lib/js/js_exn.js");
var Js_string = require("@rescript/std/lib/js/js_string.js");
var Belt_Option = require("@rescript/std/lib/js/belt_Option.js");
var Caml_exceptions = require("@rescript/std/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("@rescript/std/lib/js/caml_js_exceptions.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var Reducer_Peggy_GeneratedParserJs = require("./Reducer_Peggy_GeneratedParser.js");
var Reducer_Extra_Array$QuriSquiggleLang = require("../Reducer_Extra/Reducer_Extra_Array.bs.js");

function getMessage(param) {
  return param._0;
}

function getLocation(param) {
  return param._1;
}

var ParseError = {
  getMessage: getMessage,
  getLocation: getLocation
};

function parse__(prim0, prim1) {
  return Reducer_Peggy_GeneratedParserJs.parse(prim0, prim1);
}

function syntaxErrorToLocation(error) {
  return error.location;
}

function parse(expr, source) {
  try {
    return {
            TAG: 0,
            _0: Reducer_Peggy_GeneratedParserJs.parse(expr, {
                  grammarSource: source
                }),
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_obj){
    var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
    if (obj.RE_EXN_ID === Js_exn.$$Error) {
      var obj$1 = obj._1;
      return {
              TAG: 1,
              _0: {
                _0: Belt_Option.getExn(obj$1.message),
                _1: obj$1.location,
                [Symbol.for("name")]: "SyntaxError"
              },
              [Symbol.for("name")]: "Error"
            };
    }
    throw obj;
  }
}

var UnsupportedPeggyNodeType = /* @__PURE__ */Caml_exceptions.create("Reducer_Peggy_Parse-QuriSquiggleLang.UnsupportedPeggyNodeType");

function nodeToAST(node) {
  var match = node.type;
  var content;
  switch (match) {
    case "Array" :
        content = {
          TAG: 2,
          _0: node,
          [Symbol.for("name")]: "ASTArray"
        };
        break;
    case "Block" :
        content = {
          TAG: 0,
          _0: node,
          [Symbol.for("name")]: "ASTBlock"
        };
        break;
    case "Boolean" :
        content = {
          TAG: 4,
          _0: node,
          [Symbol.for("name")]: "ASTBoolean"
        };
        break;
    case "Call" :
        content = {
          TAG: 6,
          _0: node,
          [Symbol.for("name")]: "ASTCall"
        };
        break;
    case "Float" :
        content = {
          TAG: 5,
          _0: node,
          [Symbol.for("name")]: "ASTFloat"
        };
        break;
    case "Identifier" :
        content = {
          TAG: 7,
          _0: node,
          [Symbol.for("name")]: "ASTIdentifier"
        };
        break;
    case "Integer" :
        content = {
          TAG: 8,
          _0: node,
          [Symbol.for("name")]: "ASTInteger"
        };
        break;
    case "KeyValue" :
        content = {
          TAG: 9,
          _0: node,
          [Symbol.for("name")]: "ASTKeyValue"
        };
        break;
    case "Lambda" :
        content = {
          TAG: 10,
          _0: node,
          [Symbol.for("name")]: "ASTLambda"
        };
        break;
    case "LetStatement" :
        content = {
          TAG: 11,
          _0: node,
          [Symbol.for("name")]: "ASTLetStatement"
        };
        break;
    case "ModuleIdentifier" :
        content = {
          TAG: 12,
          _0: node,
          [Symbol.for("name")]: "ASTModuleIdentifier"
        };
        break;
    case "Program" :
        content = {
          TAG: 1,
          _0: node,
          [Symbol.for("name")]: "ASTProgram"
        };
        break;
    case "Record" :
        content = {
          TAG: 3,
          _0: node,
          [Symbol.for("name")]: "ASTRecord"
        };
        break;
    case "String" :
        content = {
          TAG: 13,
          _0: node,
          [Symbol.for("name")]: "ASTString"
        };
        break;
    case "Ternary" :
        content = {
          TAG: 14,
          _0: node,
          [Symbol.for("name")]: "ASTTernary"
        };
        break;
    case "Void" :
        content = {
          TAG: 15,
          _0: node,
          [Symbol.for("name")]: "ASTVoid"
        };
        break;
    default:
      throw {
            RE_EXN_ID: UnsupportedPeggyNodeType,
            _1: node.type,
            Error: new Error()
          };
  }
  return {
          location: node.location,
          content: content
        };
}

function nodeIdentifierToAST(node) {
  return {
          location: node.location,
          content: {
            TAG: 7,
            _0: node,
            [Symbol.for("name")]: "ASTIdentifier"
          }
        };
}

function nodeKeyValueToAST(node) {
  return {
          location: node.location,
          content: {
            TAG: 9,
            _0: node,
            [Symbol.for("name")]: "ASTKeyValue"
          }
        };
}

function pgToString(ast) {
  var argsToString = function (args) {
    return E_A$QuriSquiggleLang.fmap(args, (function (arg) {
                    return pgToString(nodeIdentifierToAST(arg));
                  })).toString();
  };
  var nodesToStringUsingSeparator = function (nodes, separator) {
    return Js_string.concatMany(Reducer_Extra_Array$QuriSquiggleLang.intersperse(E_A$QuriSquiggleLang.fmap(nodes, toString), separator), "");
  };
  var pgNodesToStringUsingSeparator = function (nodes, separator) {
    return Js_string.concatMany(Reducer_Extra_Array$QuriSquiggleLang.intersperse(E_A$QuriSquiggleLang.fmap(nodes, pgToString), separator), "");
  };
  var node = ast.content;
  switch (node.TAG | 0) {
    case /* ASTBlock */0 :
    case /* ASTProgram */1 :
        break;
    case /* ASTArray */2 :
        return "[" + nodesToStringUsingSeparator(node._0.elements, "; ") + "]";
    case /* ASTRecord */3 :
        return "{" + pgNodesToStringUsingSeparator(E_A$QuriSquiggleLang.fmap(node._0.elements, nodeKeyValueToAST), ", ") + "}";
    case /* ASTCall */6 :
        var node$1 = node._0;
        var node$2 = node$1.fn;
        return "(" + pgToString(nodeToAST(node$2)) + " " + nodesToStringUsingSeparator(node$1.args, " ") + ")";
    case /* ASTIdentifier */7 :
        return ":" + node._0.value + "";
    case /* ASTKeyValue */9 :
        var node$3 = node._0;
        var node$4 = node$3.key;
        var node$5 = node$3.value;
        return pgToString(nodeToAST(node$4)) + ": " + pgToString(nodeToAST(node$5));
    case /* ASTLambda */10 :
        var node$6 = node._0;
        var node$7 = node$6.body;
        return "{|" + argsToString(node$6.args) + "| " + pgToString(nodeToAST(node$7)) + "}";
    case /* ASTLetStatement */11 :
        var node$8 = node._0;
        var node$9 = node$8.value;
        return pgToString(nodeIdentifierToAST(node$8.variable)) + " = " + pgToString(nodeToAST(node$9));
    case /* ASTModuleIdentifier */12 :
        return "@" + node._0.value + "";
    case /* ASTString */13 :
        return "'" + String(node._0.value) + "'";
    case /* ASTTernary */14 :
        var node$10 = node._0;
        var node$11 = node$10.condition;
        var node$12 = node$10.trueExpression;
        var node$13 = node$10.falseExpression;
        return "(::$$_ternary_$$ " + pgToString(nodeToAST(node$11)) + " " + pgToString(nodeToAST(node$12)) + " " + pgToString(nodeToAST(node$13)) + ")";
    case /* ASTVoid */15 :
        return "()";
    default:
      return String(node._0.value);
  }
  return "{" + nodesToStringUsingSeparator(node._0.statements, "; ") + "}";
}

function toString(node) {
  return pgToString(nodeToAST(node));
}

function toStringError(error) {
  return "Syntax Error: " + error._0 + "}";
}

function toStringResult(rNode) {
  if (rNode.TAG === /* Ok */0) {
    return pgToString(nodeToAST(rNode._0));
  } else {
    return "Error(" + toStringError(rNode._0) + ")";
  }
}

var Extra;

exports.Extra = Extra;
exports.ParseError = ParseError;
exports.parse__ = parse__;
exports.syntaxErrorToLocation = syntaxErrorToLocation;
exports.parse = parse;
exports.UnsupportedPeggyNodeType = UnsupportedPeggyNodeType;
exports.nodeToAST = nodeToAST;
exports.nodeIdentifierToAST = nodeIdentifierToAST;
exports.nodeKeyValueToAST = nodeKeyValueToAST;
exports.pgToString = pgToString;
exports.toString = toString;
exports.toStringError = toStringError;
exports.toStringResult = toStringResult;
/* E_A-QuriSquiggleLang Not a pure module */
