'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Caml_array = require("@rescript/std/lib/js/caml_array.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var MagicNumbers$QuriSquiggleLang = require("../../MagicNumbers.bs.js");
var Distributions$QuriSquiggleLang = require("./Distributions.bs.js");
var PointSetTypes$QuriSquiggleLang = require("./PointSetTypes.bs.js");
var AlgebraicShapeCombination$QuriSquiggleLang = require("./AlgebraicShapeCombination.bs.js");

function integrate(indefiniteIntegralStepwiseOpt, indefiniteIntegralLinearOpt, t) {
  var indefiniteIntegralStepwise = indefiniteIntegralStepwiseOpt !== undefined ? indefiniteIntegralStepwiseOpt : (function (p, h1) {
        return h1 * p;
      });
  var indefiniteIntegralLinear = indefiniteIntegralLinearOpt !== undefined ? indefiniteIntegralLinearOpt : (function (p, a, b) {
        return a * p + b * Math.pow(p, 2.0) / 2.0;
      });
  var xs = t.xyShape.xs;
  var ys = t.xyShape.ys;
  return E_A$QuriSquiggleLang.reducei(xs, 0.0, (function (acc, _x, i) {
                var match = t.interpolation;
                var areaUnderIntegral;
                if (i !== 0) {
                  if (match === "Linear") {
                    var x1 = Caml_array.get(xs, i - 1 | 0);
                    var x2 = Caml_array.get(xs, i);
                    if (x1 === x2) {
                      areaUnderIntegral = 0.0;
                    } else {
                      var h1 = Caml_array.get(ys, i - 1 | 0);
                      var h2 = Caml_array.get(ys, i);
                      var b = (h1 - h2) / (x1 - x2);
                      var a = h1 - b * x1;
                      areaUnderIntegral = Curry._3(indefiniteIntegralLinear, x2, a, b) - Curry._3(indefiniteIntegralLinear, x1, a, b);
                    }
                  } else {
                    areaUnderIntegral = Curry._2(indefiniteIntegralStepwise, Caml_array.get(xs, i), Caml_array.get(ys, i - 1 | 0)) - Curry._2(indefiniteIntegralStepwise, Caml_array.get(xs, i - 1 | 0), Caml_array.get(ys, i - 1 | 0));
                  }
                } else {
                  areaUnderIntegral = 0.0;
                }
                return acc + areaUnderIntegral;
              }));
}

function getMeanOfSquares(t) {
  var indefiniteIntegralLinear = function (p, a, b) {
    return a * Math.pow(p, 3.0) / 3.0 + b * Math.pow(p, 4.0) / 4.0;
  };
  var indefiniteIntegralStepwise = function (p, h1) {
    return h1 * Math.pow(p, 3.0) / 3.0;
  };
  return integrate(indefiniteIntegralStepwise, indefiniteIntegralLinear, t);
}

var Analysis = {
  integrate: integrate,
  getMeanOfSquares: getMeanOfSquares
};

function getShape(t) {
  return t.xyShape;
}

function interpolation(t) {
  return t.interpolation;
}

function make(interpolationOpt, integralSumCacheOpt, integralCacheOpt, xyShape) {
  var interpolation = interpolationOpt !== undefined ? interpolationOpt : "Linear";
  var integralSumCache = integralSumCacheOpt !== undefined ? Caml_option.valFromOption(integralSumCacheOpt) : undefined;
  var integralCache = integralCacheOpt !== undefined ? Caml_option.valFromOption(integralCacheOpt) : undefined;
  return {
          xyShape: xyShape,
          interpolation: interpolation,
          integralSumCache: integralSumCache,
          integralCache: integralCache
        };
}

function shapeMap(param, fn) {
  return {
          xyShape: Curry._1(fn, param.xyShape),
          interpolation: param.interpolation,
          integralSumCache: param.integralSumCache,
          integralCache: param.integralCache
        };
}

function lastY(t) {
  return XYShape$QuriSquiggleLang.T.lastY(t.xyShape);
}

function oShapeMap(fn, param) {
  var partial_arg = Caml_option.some(param.integralCache);
  var partial_arg$1 = Caml_option.some(param.integralSumCache);
  var partial_arg$2 = param.interpolation;
  return E_O$QuriSquiggleLang.fmap(Curry._1(fn, param.xyShape), (function (param) {
                return make(partial_arg$2, partial_arg$1, partial_arg, param);
              }));
}

var emptyIntegral_xyShape = {
  xs: [Pervasives.neg_infinity],
  ys: [0.0]
};

var emptyIntegral_integralSumCache = 0.0;

var emptyIntegral = {
  xyShape: emptyIntegral_xyShape,
  interpolation: "Linear",
  integralSumCache: emptyIntegral_integralSumCache,
  integralCache: undefined
};

var empty_xyShape = XYShape$QuriSquiggleLang.T.empty;

var empty_integralSumCache = 0.0;

var empty_integralCache = emptyIntegral;

var empty = {
  xyShape: empty_xyShape,
  interpolation: "Linear",
  integralSumCache: empty_integralSumCache,
  integralCache: empty_integralCache
};

function stepwiseToLinear(t) {
  return make(undefined, Caml_option.some(t.integralSumCache), Caml_option.some(t.integralCache), XYShape$QuriSquiggleLang.$$Range.stepwiseToLinear(t.xyShape));
}

function combinePointwise(combinerOpt, integralSumCachesFnOpt, distributionTypeOpt, fn, t1, t2) {
  var combiner = combinerOpt !== undefined ? combinerOpt : XYShape$QuriSquiggleLang.PointwiseCombination.combine;
  var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
        
      });
  var distributionType = distributionTypeOpt !== undefined ? distributionTypeOpt : "PDF";
  var combinedIntegralSum = Distributions$QuriSquiggleLang.Common.combineIntegralSums(integralSumCachesFn, t1.integralSumCache, t2.integralSumCache);
  var match = t1.interpolation;
  var match$1 = t2.interpolation;
  var match$2 = match === "Linear" ? (
      match$1 === "Linear" ? [
          t1,
          t2
        ] : [
          t1,
          stepwiseToLinear(t2)
        ]
    ) : (
      match$1 === "Linear" ? [
          stepwiseToLinear(t1),
          t2
        ] : [
          t1,
          t2
        ]
    );
  var t1$1 = match$2[0];
  var extrapolation = distributionType === "PDF" ? "UseZero" : "UseOutermostPoints";
  var interpolator = XYShape$QuriSquiggleLang.XtoY.continuousInterpolator(t1$1.interpolation, extrapolation);
  return E_R$QuriSquiggleLang.fmap(Curry._4(combiner, interpolator, fn, t1$1.xyShape, match$2[1].xyShape), (function (x) {
                return make(undefined, Caml_option.some(combinedIntegralSum), undefined, x);
              }));
}

function toLinear(t) {
  if (t.interpolation === "Linear") {
    return t;
  }
  var arg = Caml_option.some(t.integralSumCache);
  var arg$1 = Caml_option.some(t.integralCache);
  return E_O$QuriSquiggleLang.fmap(XYShape$QuriSquiggleLang.$$Range.stepsToContinuous(t.xyShape), (function (eta) {
                return make(undefined, arg, arg$1, eta);
              }));
}

function shapeFn(t, fn) {
  return Curry._1(fn, t.xyShape);
}

function updateIntegralSumCache(t, integralSumCache) {
  return {
          xyShape: t.xyShape,
          interpolation: t.interpolation,
          integralSumCache: integralSumCache,
          integralCache: t.integralCache
        };
}

function updateIntegralCache(t, integralCache) {
  return {
          xyShape: t.xyShape,
          interpolation: t.interpolation,
          integralSumCache: t.integralSumCache,
          integralCache: integralCache
        };
}

function sum(integralSumCachesFnOpt, continuousShapes) {
  var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
        
      });
  return E_A$QuriSquiggleLang.fold_left(continuousShapes, empty, (function (x, y) {
                return E_R$QuriSquiggleLang.toExn(combinePointwise(undefined, integralSumCachesFn, undefined, (function (a, b) {
                                  return {
                                          TAG: 0,
                                          _0: a + b,
                                          [Symbol.for("name")]: "Ok"
                                        };
                                }), x, y), "Addition should never fail");
              }));
}

function reduce(continuousShapes, integralSumCachesFnOpt, fn) {
  var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
        
      });
  var partial_arg = integralSumCachesFn;
  var merge = function (param, param$1) {
    return combinePointwise(undefined, partial_arg, undefined, fn, param, param$1);
  };
  return E_A$QuriSquiggleLang.R.foldM(continuousShapes, empty, merge);
}

function mapYResult(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
  var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
        
      });
  var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
        
      });
  return E_R$QuriSquiggleLang.fmap(XYShape$QuriSquiggleLang.T.mapYResult(t.xyShape, fn), (function (x) {
                return make(t.interpolation, Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralSumCache, integralSumCacheFn)), Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralCache, integralCacheFn)), x);
              }));
}

function mapY(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
  var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
        
      });
  var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
        
      });
  return make(t.interpolation, Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralSumCache, integralSumCacheFn)), Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralCache, integralCacheFn)), XYShape$QuriSquiggleLang.T.mapY(t.xyShape, fn));
}

function scaleBy(t, scale) {
  var scaledIntegralSumCache = E_O$QuriSquiggleLang.bind(t.integralSumCache, (function (v) {
          return scale * v;
        }));
  var scaledIntegralCache = E_O$QuriSquiggleLang.bind(t.integralCache, (function (v) {
          return scaleBy(v, scale);
        }));
  return updateIntegralCache(updateIntegralSumCache(mapY(undefined, undefined, t, (function (r) {
                        return r * scale;
                      })), scaledIntegralSumCache), scaledIntegralCache);
}

function minX(__x) {
  return XYShape$QuriSquiggleLang.T.minX(__x.xyShape);
}

function maxX(__x) {
  return XYShape$QuriSquiggleLang.T.maxX(__x.xyShape);
}

function toDiscreteProbabilityMassFraction(param) {
  return 0.0;
}

function toPointSetDist(t) {
  return {
          TAG: 2,
          _0: t,
          [Symbol.for("name")]: "Continuous"
        };
}

function xToY(f, param) {
  var xyShape = param.xyShape;
  return PointSetTypes$QuriSquiggleLang.MixedPoint.makeContinuous(param.interpolation === "Linear" ? XYShape$QuriSquiggleLang.XtoY.linear(xyShape, f) : E_O$QuriSquiggleLang.$$default(XYShape$QuriSquiggleLang.XtoY.stepwiseIncremental(xyShape, f), 0.0));
}

function truncate(leftCutoff, rightCutoff, t) {
  var lc = E_O$QuriSquiggleLang.$$default(leftCutoff, Pervasives.neg_infinity);
  var rc = E_O$QuriSquiggleLang.$$default(rightCutoff, Pervasives.infinity);
  var truncatedZippedPairs = XYShape$QuriSquiggleLang.Zipped.filterByX(XYShape$QuriSquiggleLang.T.zip(t.xyShape), (function (x) {
          if (x >= lc) {
            return x <= rc;
          } else {
            return false;
          }
        }));
  var leftNewPoint = E_O$QuriSquiggleLang.dimap(leftCutoff, (function (lc) {
          return [[
                    lc - Pervasives.epsilon_float,
                    0
                  ]];
        }), (function (param) {
          return [];
        }));
  var rightNewPoint = E_O$QuriSquiggleLang.dimap(rightCutoff, (function (rc) {
          return [[
                    rc + Pervasives.epsilon_float,
                    0
                  ]];
        }), (function (param) {
          return [];
        }));
  var truncatedZippedPairsWithNewPoints = E_A$QuriSquiggleLang.concatMany([
        leftNewPoint,
        truncatedZippedPairs,
        rightNewPoint
      ]);
  var truncatedShape = XYShape$QuriSquiggleLang.T.fromZippedArray(truncatedZippedPairsWithNewPoints);
  return make(undefined, undefined, undefined, truncatedShape);
}

function integral(t) {
  var match = XYShape$QuriSquiggleLang.T.isEmpty(t.xyShape);
  var match$1 = t.integralCache;
  if (match) {
    return emptyIntegral;
  } else if (match$1 !== undefined) {
    return match$1;
  } else {
    return make(undefined, undefined, undefined, E_O$QuriSquiggleLang.toExt(XYShape$QuriSquiggleLang.$$Range.integrateWithTriangles(t.xyShape), "This should not have happened"));
  }
}

function downsample(length, t) {
  return shapeMap(t, (function (__x) {
                return XYShape$QuriSquiggleLang.XsConversion.proportionByProbabilityMass(__x, length, integral(t).xyShape);
              }));
}

function integralEndY(t) {
  return E_O$QuriSquiggleLang.defaultFn(t.integralSumCache, (function (param) {
                var t$1 = integral(t);
                return XYShape$QuriSquiggleLang.T.lastY(t$1.xyShape);
              }));
}

function integralXtoY(f, t) {
  var t$1 = integral(t);
  var __x = t$1.xyShape;
  return XYShape$QuriSquiggleLang.XtoY.linear(__x, f);
}

function integralYtoX(f, t) {
  var t$1 = integral(t);
  var __x = t$1.xyShape;
  return XYShape$QuriSquiggleLang.YtoX.linear(__x, f);
}

function toContinuous(t) {
  return Caml_option.some(t);
}

function toDiscrete(param) {
  
}

function normalize(t) {
  return updateIntegralSumCache(scaleBy(updateIntegralCache(t, integral(t)), 1 / integralEndY(t)), 1.0);
}

function mean(t) {
  var indefiniteIntegralStepwise = function (p, h1) {
    return h1 * Math.pow(p, 2.0) / 2.0;
  };
  var indefiniteIntegralLinear = function (p, a, b) {
    return a * Math.pow(p, 2.0) / 2.0 + b * Math.pow(p, 3.0) / 3.0;
  };
  return integrate(indefiniteIntegralStepwise, indefiniteIntegralLinear, t);
}

function variance(t) {
  return XYShape$QuriSquiggleLang.Analysis.getVarianceDangerously(t, mean, getMeanOfSquares);
}

var T = Distributions$QuriSquiggleLang.Dist({
      minX: minX,
      maxX: maxX,
      mapY: mapY,
      mapYResult: mapYResult,
      xToY: xToY,
      toPointSetDist: toPointSetDist,
      toContinuous: toContinuous,
      toDiscrete: toDiscrete,
      normalize: normalize,
      toDiscreteProbabilityMassFraction: toDiscreteProbabilityMassFraction,
      downsample: downsample,
      truncate: truncate,
      updateIntegralCache: updateIntegralCache,
      integral: integral,
      integralEndY: integralEndY,
      integralXtoY: integralXtoY,
      integralYtoX: integralYtoX,
      mean: mean,
      variance: variance
    });

function isNormalized(t) {
  var areaUnderIntegral = Curry._1(T.integralEndY, updateIntegralCache(t, Curry._1(T.integral, t)));
  if (areaUnderIntegral < 1 + MagicNumbers$QuriSquiggleLang.Epsilon.seven) {
    return areaUnderIntegral > 1 - MagicNumbers$QuriSquiggleLang.Epsilon.seven;
  } else {
    return false;
  }
}

function downsampleEquallyOverX(length, t) {
  return shapeMap(t, (function (__x) {
                return XYShape$QuriSquiggleLang.XsConversion.proportionEquallyOverX(__x, length);
              }));
}

function combineAlgebraicallyWithDiscrete(op, t1, t2, discretePosition) {
  var t1s = t1.xyShape;
  var t2s = t2.xyShape;
  if (XYShape$QuriSquiggleLang.T.isEmpty(t1s) || XYShape$QuriSquiggleLang.T.isEmpty(t2s)) {
    return empty;
  }
  var match = t1.interpolation;
  var continuousAsLinear = match === "Linear" ? t1 : stepwiseToLinear(t1);
  var combinedShape = AlgebraicShapeCombination$QuriSquiggleLang.combineShapesContinuousDiscrete(op, continuousAsLinear.xyShape, t2s, discretePosition);
  var combinedIntegralSum = op === "Multiply" ? Distributions$QuriSquiggleLang.Common.combineIntegralSums((function (a, b) {
            return a * b;
          }), t1.integralSumCache, t2.integralSumCache) : undefined;
  return make(t1.interpolation, Caml_option.some(combinedIntegralSum), undefined, combinedShape);
}

function combineAlgebraically(op, t1, t2) {
  var s1 = t1.xyShape;
  var s2 = t2.xyShape;
  var t1n = XYShape$QuriSquiggleLang.T.length(s1);
  var t2n = XYShape$QuriSquiggleLang.T.length(s2);
  if (t1n === 0 || t2n === 0) {
    return empty;
  }
  var combinedShape = AlgebraicShapeCombination$QuriSquiggleLang.combineShapesContinuousContinuous(op, s1, s2);
  var combinedIntegralSum = Distributions$QuriSquiggleLang.Common.combineIntegralSums((function (a, b) {
          return a * b;
        }), t1.integralSumCache, t2.integralSumCache);
  return make(undefined, Caml_option.some(combinedIntegralSum), undefined, combinedShape);
}

exports.Analysis = Analysis;
exports.getShape = getShape;
exports.interpolation = interpolation;
exports.make = make;
exports.shapeMap = shapeMap;
exports.lastY = lastY;
exports.oShapeMap = oShapeMap;
exports.emptyIntegral = emptyIntegral;
exports.empty = empty;
exports.stepwiseToLinear = stepwiseToLinear;
exports.combinePointwise = combinePointwise;
exports.toLinear = toLinear;
exports.shapeFn = shapeFn;
exports.updateIntegralSumCache = updateIntegralSumCache;
exports.updateIntegralCache = updateIntegralCache;
exports.sum = sum;
exports.reduce = reduce;
exports.mapYResult = mapYResult;
exports.mapY = mapY;
exports.scaleBy = scaleBy;
exports.T = T;
exports.isNormalized = isNormalized;
exports.downsampleEquallyOverX = downsampleEquallyOverX;
exports.combineAlgebraicallyWithDiscrete = combineAlgebraicallyWithDiscrete;
exports.combineAlgebraically = combineAlgebraically;
/* T Not a pure module */
