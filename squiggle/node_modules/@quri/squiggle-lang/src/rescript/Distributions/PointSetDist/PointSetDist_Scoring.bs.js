'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var Mixed$QuriSquiggleLang = require("./Mixed.bs.js");
var Discrete$QuriSquiggleLang = require("./Discrete.bs.js");
var Continuous$QuriSquiggleLang = require("./Continuous.bs.js");

function logFn(prim) {
  return Math.log(prim);
}

function minusScaledLogOfQuotient(esti, answ) {
  var quot = esti / answ;
  if (quot < 0.0) {
    return {
            TAG: 1,
            _0: /* ComplexNumberError */1,
            [Symbol.for("name")]: "Error"
          };
  } else {
    return {
            TAG: 0,
            _0: -answ * Math.log(quot),
            [Symbol.for("name")]: "Ok"
          };
  }
}

function integrand(estimateElement, answerElement) {
  if (answerElement === 0.0) {
    return {
            TAG: 0,
            _0: 0.0,
            [Symbol.for("name")]: "Ok"
          };
  } else if (estimateElement === 0.0) {
    return {
            TAG: 0,
            _0: Pervasives.infinity,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return minusScaledLogOfQuotient(estimateElement, answerElement);
  }
}

function sum(estimate, answer, combineFn, integrateFn, toMixedFn) {
  var combineAndIntegrate = function (estimate, answer) {
    return E_R$QuriSquiggleLang.fmap(Curry._3(combineFn, integrand, estimate, answer), integrateFn);
  };
  var getMixedSums = function (estimate, answer) {
    var esti = Curry._1(toMixedFn, estimate);
    var answ = Curry._1(toMixedFn, answer);
    var match = Curry._1(Mixed$QuriSquiggleLang.T.toContinuous, esti);
    var match$1 = Curry._1(Mixed$QuriSquiggleLang.T.toDiscrete, esti);
    var match$2 = Curry._1(Mixed$QuriSquiggleLang.T.toContinuous, answ);
    var match$3 = Curry._1(Mixed$QuriSquiggleLang.T.toDiscrete, answ);
    if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined) {
      return E_R$QuriSquiggleLang.merge(combineAndIntegrate({
                      TAG: 1,
                      _0: match$1,
                      [Symbol.for("name")]: "Discrete"
                    }, {
                      TAG: 1,
                      _0: match$3,
                      [Symbol.for("name")]: "Discrete"
                    }), combineAndIntegrate({
                      TAG: 2,
                      _0: match,
                      [Symbol.for("name")]: "Continuous"
                    }, {
                      TAG: 2,
                      _0: match$2,
                      [Symbol.for("name")]: "Continuous"
                    }));
    } else {
      return {
              TAG: 1,
              _0: {
                _0: "unreachable state",
                [Symbol.for("name")]: "Other"
              },
              [Symbol.for("name")]: "Error"
            };
    }
  };
  switch (estimate.TAG | 0) {
    case /* Mixed */0 :
        break;
    case /* Discrete */1 :
        switch (answer.TAG | 0) {
          case /* Discrete */1 :
              return combineAndIntegrate(estimate, answer);
          case /* Mixed */0 :
          case /* Continuous */2 :
              break;
          
        }
        break;
    case /* Continuous */2 :
        switch (answer.TAG | 0) {
          case /* Mixed */0 :
          case /* Discrete */1 :
              break;
          case /* Continuous */2 :
              return combineAndIntegrate(estimate, answer);
          
        }
        break;
    
  }
  return E_R$QuriSquiggleLang.fmap(getMixedSums(estimate, answer), (function (param) {
                return param[0] + param[1];
              }));
}

function sumWithPrior(estimate, answer, prior, combineFn, integrateFn, toMixedFn) {
  var kl1 = sum(estimate, answer, combineFn, integrateFn, toMixedFn);
  var kl2 = sum(prior, answer, combineFn, integrateFn, toMixedFn);
  return E_R$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.merge(kl1, kl2), (function (param) {
                return param[0] - param[1];
              }));
}

var WithDistAnswer = {
  integrand: integrand,
  sum: sum,
  sumWithPrior: sumWithPrior
};

function sum$1(mp) {
  return mp.continuous + mp.discrete;
}

function score(estimate, answer) {
  var estimatePdf = function (x) {
    switch (estimate.TAG | 0) {
      case /* Mixed */0 :
          return ;
      case /* Discrete */1 :
          return sum$1(Curry._2(Discrete$QuriSquiggleLang.T.xToY, x, estimate._0));
      case /* Continuous */2 :
          return sum$1(Curry._2(Continuous$QuriSquiggleLang.T.xToY, x, estimate._0));
      
    }
  };
  var density = Curry._1(estimatePdf, answer);
  if (density !== undefined && density >= 0.0) {
    if (density === 0.0) {
      return {
              TAG: 0,
              _0: Pervasives.infinity,
              [Symbol.for("name")]: "Ok"
            };
    } else {
      return {
              TAG: 0,
              _0: -Math.log(density),
              [Symbol.for("name")]: "Ok"
            };
    }
  } else {
    return {
            TAG: 1,
            _0: /* PdfInvalidError */5,
            [Symbol.for("name")]: "Error"
          };
  }
}

function scoreWithPrior(estimate, answer, prior) {
  return E_R$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.merge(score(estimate, answer), score(prior, answer)), (function (param) {
                return param[0] - param[1];
              }));
}

var WithScalarAnswer = {
  sum: sum$1,
  score: score,
  scoreWithPrior: scoreWithPrior
};

function twoGenericDistsToTwoPointSetDists(toPointSetFn, estimate, answer) {
  return E_R$QuriSquiggleLang.merge(Curry._2(toPointSetFn, estimate, undefined), Curry._2(toPointSetFn, answer, undefined));
}

function logScore(args, combineFn, integrateFn, toMixedFn) {
  if (args.TAG === /* DistAnswer */0) {
    var match = args._0;
    var prior = match.prior;
    var answer = match.answer;
    var estimate = match.estimate;
    if (prior !== undefined) {
      return sumWithPrior(estimate, answer, prior, combineFn, integrateFn, toMixedFn);
    } else {
      return sum(estimate, answer, combineFn, integrateFn, toMixedFn);
    }
  }
  var match$1 = args._0;
  var prior$1 = match$1.prior;
  var answer$1 = match$1.answer;
  var estimate$1 = match$1.estimate;
  if (prior$1 !== undefined) {
    return scoreWithPrior(estimate$1, answer$1, prior$1);
  } else {
    return score(estimate$1, answer$1);
  }
}

exports.logFn = logFn;
exports.minusScaledLogOfQuotient = minusScaledLogOfQuotient;
exports.WithDistAnswer = WithDistAnswer;
exports.WithScalarAnswer = WithScalarAnswer;
exports.twoGenericDistsToTwoPointSetDists = twoGenericDistsToTwoPointSetDists;
exports.logScore = logScore;
/* Mixed-QuriSquiggleLang Not a pure module */
