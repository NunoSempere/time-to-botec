'use strict';

var Caml = require("@rescript/std/lib/js/caml.js");
var Curry = require("@rescript/std/lib/js/curry.js");
var Jstat = require("jstat");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var Stdlib$QuriSquiggleLang = require("../../Utility/Stdlib.bs.js");
var E_Float$QuriSquiggleLang = require("../../Utility/E/E_Float.bs.js");
var Discrete$QuriSquiggleLang = require("../PointSetDist/Discrete.bs.js");
var Operation$QuriSquiggleLang = require("../../Utility/Operation.bs.js");
var Continuous$QuriSquiggleLang = require("../PointSetDist/Continuous.bs.js");
var MagicNumbers$QuriSquiggleLang = require("../../MagicNumbers.bs.js");

function make(mean, stdev) {
  if (stdev > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Normal",
              VAL: {
                mean: mean,
                stdev: stdev
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Standard deviation of normal distribution must be larger than 0",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf(x, t) {
  return Jstat.normal.pdf(x, t.mean, t.stdev);
}

function cdf(x, t) {
  return Jstat.normal.cdf(x, t.mean, t.stdev);
}

function from90PercentCI(low, high) {
  var mean = E_A$QuriSquiggleLang.Floats.mean([
        low,
        high
      ]);
  var stdev = (high - low) / (2 * 1.6448536269514722);
  return {
          NAME: "Normal",
          VAL: {
            mean: mean,
            stdev: stdev
          }
        };
}

function inv(p, t) {
  return Jstat.normal.inv(p, t.mean, t.stdev);
}

function sample(t) {
  return Jstat.normal.sample(t.mean, t.stdev);
}

function mean(t) {
  return {
          TAG: 0,
          _0: Jstat.normal.mean(t.mean, t.stdev),
          [Symbol.for("name")]: "Ok"
        };
}

function toString(param) {
  return "Normal(" + param.mean + "," + param.stdev + ")";
}

function add(n1, n2) {
  var mean = n1.mean + n2.mean;
  var stdev = Math.sqrt(Math.pow(n1.stdev, 2) + Math.pow(n2.stdev, 2));
  return {
          NAME: "Normal",
          VAL: {
            mean: mean,
            stdev: stdev
          }
        };
}

function subtract(n1, n2) {
  var mean = n1.mean - n2.mean;
  var stdev = Math.sqrt(Math.pow(n1.stdev, 2) + Math.pow(n2.stdev, 2));
  return {
          NAME: "Normal",
          VAL: {
            mean: mean,
            stdev: stdev
          }
        };
}

function pointwiseProduct(n1, n2) {
  var mean = (n1.mean * Math.pow(n2.stdev, 2) + n2.mean * Math.pow(n1.stdev, 2)) / (Math.pow(n1.stdev, 2) + Math.pow(n2.stdev, 2));
  var stdev = 1 / (1 / Math.pow(n1.stdev, 2) + 1 / Math.pow(n2.stdev, 2));
  return {
          NAME: "Normal",
          VAL: {
            mean: mean,
            stdev: stdev
          }
        };
}

function operate(operation, n1, n2) {
  if (operation === "Subtract") {
    return subtract(n1, n2);
  } else if (operation === "Add") {
    return add(n1, n2);
  } else {
    return ;
  }
}

function operateFloatFirst(operation, n1, n2) {
  if (operation === "Subtract") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1 - n2.mean,
              stdev: n2.stdev
            }
          };
  } else if (operation === "Multiply") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1 * n2.mean,
              stdev: Math.abs(n1) * n2.stdev
            }
          };
  } else if (operation === "Add") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1 + n2.mean,
              stdev: n2.stdev
            }
          };
  } else {
    return ;
  }
}

function operateFloatSecond(operation, n1, n2) {
  if (operation === "Subtract") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1.mean - n2,
              stdev: n1.stdev
            }
          };
  } else if (operation === "Divide") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1.mean / n2,
              stdev: n1.stdev / Math.abs(n2)
            }
          };
  } else if (operation === "Multiply") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1.mean * n2,
              stdev: n1.stdev * Math.abs(n2)
            }
          };
  } else if (operation === "Add") {
    return {
            NAME: "Normal",
            VAL: {
              mean: n1.mean + n2,
              stdev: n1.stdev
            }
          };
  } else {
    return ;
  }
}

var Normal = {
  make: make,
  pdf: pdf,
  cdf: cdf,
  from90PercentCI: from90PercentCI,
  inv: inv,
  sample: sample,
  mean: mean,
  toString: toString,
  add: add,
  subtract: subtract,
  pointwiseProduct: pointwiseProduct,
  operate: operate,
  operateFloatFirst: operateFloatFirst,
  operateFloatSecond: operateFloatSecond
};

function make$1(rate) {
  if (rate > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Exponential",
              VAL: {
                rate: rate
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Exponential distributions rate must be larger than 0.",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$1(x, t) {
  return Jstat.exponential.pdf(x, t.rate);
}

function cdf$1(x, t) {
  return Jstat.exponential.cdf(x, t.rate);
}

function inv$1(p, t) {
  return Jstat.exponential.inv(p, t.rate);
}

function sample$1(t) {
  return Jstat.exponential.sample(t.rate);
}

function mean$1(t) {
  return {
          TAG: 0,
          _0: Jstat.exponential.mean(t.rate),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$1(param) {
  return "Exponential(" + param.rate + ")";
}

var Exponential = {
  make: make$1,
  pdf: pdf$1,
  cdf: cdf$1,
  inv: inv$1,
  sample: sample$1,
  mean: mean$1,
  toString: toString$1
};

function make$2(local, scale) {
  if (scale > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Cauchy",
              VAL: {
                local: local,
                scale: scale
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Cauchy distribution scale parameter must larger than 0.",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$2(x, t) {
  return Jstat.cauchy.pdf(x, t.local, t.scale);
}

function cdf$2(x, t) {
  return Jstat.cauchy.cdf(x, t.local, t.scale);
}

function inv$2(p, t) {
  return Jstat.cauchy.inv(p, t.local, t.scale);
}

function sample$2(t) {
  return Jstat.cauchy.sample(t.local, t.scale);
}

function mean$2(param) {
  return {
          TAG: 1,
          _0: "Cauchy distributions may have no mean value.",
          [Symbol.for("name")]: "Error"
        };
}

function toString$2(param) {
  return "Cauchy(" + param.local + ", " + param.scale + ")";
}

var Cauchy = {
  make: make$2,
  pdf: pdf$2,
  cdf: cdf$2,
  inv: inv$2,
  sample: sample$2,
  mean: mean$2,
  toString: toString$2
};

function make$3(low, medium, high) {
  if (low < medium && medium < high) {
    return {
            TAG: 0,
            _0: {
              NAME: "Triangular",
              VAL: {
                low: low,
                medium: medium,
                high: high
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Triangular values must be increasing order.",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$3(x, t) {
  return Jstat.triangular.pdf(x, t.low, t.high, t.medium);
}

function cdf$3(x, t) {
  return Jstat.triangular.cdf(x, t.low, t.high, t.medium);
}

function inv$3(p, t) {
  return Jstat.triangular.inv(p, t.low, t.high, t.medium);
}

function sample$3(t) {
  return Jstat.triangular.sample(t.low, t.high, t.medium);
}

function mean$3(t) {
  return {
          TAG: 0,
          _0: Jstat.triangular.mean(t.low, t.high, t.medium),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$3(param) {
  return "Triangular(" + param.low + ", " + param.medium + ", " + param.high + ")";
}

var Triangular = {
  make: make$3,
  pdf: pdf$3,
  cdf: cdf$3,
  inv: inv$3,
  sample: sample$3,
  mean: mean$3,
  toString: toString$3
};

function make$4(alpha, beta) {
  if (alpha > 0.0 && beta > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Beta",
              VAL: {
                alpha: alpha,
                beta: beta
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Beta distribution parameters must be positive",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$4(x, t) {
  return Jstat.beta.pdf(x, t.alpha, t.beta);
}

function cdf$4(x, t) {
  return Jstat.beta.cdf(x, t.alpha, t.beta);
}

function inv$4(p, t) {
  return Jstat.beta.inv(p, t.alpha, t.beta);
}

function sample$4(t) {
  return Jstat.beta.sample(t.alpha, t.beta);
}

function mean$4(t) {
  return {
          TAG: 0,
          _0: Jstat.beta.mean(t.alpha, t.beta),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$4(param) {
  return "Beta(" + param.alpha + "," + param.beta + ")";
}

function fromMeanAndSampleSize(mean, sampleSize) {
  var alpha = mean * sampleSize;
  var beta = (1.0 - mean) * sampleSize;
  return make$4(alpha, beta);
}

function fromMeanAndStdev(mean, stdev) {
  if (!(0.0 < stdev && stdev <= 0.5)) {
    return {
            TAG: 1,
            _0: "Stdev must be in in between 0 and 0.5.",
            [Symbol.for("name")]: "Error"
          };
  }
  if (!(0.0 <= mean && mean <= 1.0)) {
    return {
            TAG: 1,
            _0: "Mean must be in between 0 and 1.0.",
            [Symbol.for("name")]: "Error"
          };
  }
  var $$var = stdev * stdev;
  var sampleSize = mean * (1.0 - mean) / $$var - 1.0;
  return fromMeanAndSampleSize(mean, sampleSize);
}

var Beta = {
  make: make$4,
  pdf: pdf$4,
  cdf: cdf$4,
  inv: inv$4,
  sample: sample$4,
  mean: mean$4,
  toString: toString$4,
  fromMeanAndSampleSize: fromMeanAndSampleSize,
  fromMeanAndStdev: fromMeanAndStdev
};

function make$5(mu, sigma) {
  if (sigma > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Lognormal",
              VAL: {
                mu: mu,
                sigma: sigma
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Lognormal standard deviation must be larger than 0",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$5(x, t) {
  return Jstat.lognormal.pdf(x, t.mu, t.sigma);
}

function cdf$5(x, t) {
  return Jstat.lognormal.cdf(x, t.mu, t.sigma);
}

function inv$5(p, t) {
  return Jstat.lognormal.inv(p, t.mu, t.sigma);
}

function mean$5(t) {
  return {
          TAG: 0,
          _0: Jstat.lognormal.mean(t.mu, t.sigma),
          [Symbol.for("name")]: "Ok"
        };
}

function sample$5(t) {
  return Jstat.lognormal.sample(t.mu, t.sigma);
}

function toString$5(param) {
  return "Lognormal(" + param.mu + "," + param.sigma + ")";
}

function from90PercentCI$1(low, high) {
  var logLow = Math.log(low);
  var logHigh = Math.log(high);
  var mu = E_A$QuriSquiggleLang.Floats.mean([
        logLow,
        logHigh
      ]);
  var sigma = (logHigh - logLow) / (2.0 * 1.6448536269514722);
  return {
          NAME: "Lognormal",
          VAL: {
            mu: mu,
            sigma: sigma
          }
        };
}

function fromMeanAndStdev$1(mean, stdev) {
  if (mean <= 0.0) {
    return {
            TAG: 1,
            _0: "Lognormal mean must be larger than 0",
            [Symbol.for("name")]: "Error"
          };
  }
  if (stdev <= 0.0) {
    return {
            TAG: 1,
            _0: "Lognormal standard deviation must be larger than 0",
            [Symbol.for("name")]: "Error"
          };
  }
  var variance = Math.pow(stdev, 2);
  var meanSquared = Math.pow(mean, 2);
  var mu = 2 * Math.log(mean) - 0.5 * Math.log(variance + meanSquared);
  var sigma = Math.sqrt(Math.log(variance / meanSquared + 1));
  return {
          TAG: 0,
          _0: {
            NAME: "Lognormal",
            VAL: {
              mu: mu,
              sigma: sigma
            }
          },
          [Symbol.for("name")]: "Ok"
        };
}

function multiply(l1, l2) {
  var mu = l1.mu + l2.mu;
  var sigma = Math.sqrt(Math.pow(l1.sigma, 2) + Math.pow(l2.sigma, 2));
  return {
          NAME: "Lognormal",
          VAL: {
            mu: mu,
            sigma: sigma
          }
        };
}

function divide(l1, l2) {
  var mu = l1.mu - l2.mu;
  var sigma = Math.sqrt(Math.pow(l1.sigma, 2) + Math.pow(l2.sigma, 2));
  return {
          NAME: "Lognormal",
          VAL: {
            mu: mu,
            sigma: sigma
          }
        };
}

function operate$1(operation, n1, n2) {
  if (operation === "Divide") {
    return divide(n1, n2);
  } else if (operation === "Multiply") {
    return multiply(n1, n2);
  } else {
    return ;
  }
}

function operateFloatFirst$1(operation, n1, n2) {
  if (operation === "Divide") {
    if (n1 > 0.0) {
      return {
              NAME: "Lognormal",
              VAL: {
                mu: Math.log(n1) - n2.mu,
                sigma: n2.sigma
              }
            };
    } else {
      return ;
    }
  } else if (operation === "Multiply" && n1 > 0.0) {
    return {
            NAME: "Lognormal",
            VAL: {
              mu: Math.log(n1) + n2.mu,
              sigma: n2.sigma
            }
          };
  } else {
    return ;
  }
}

function operateFloatSecond$1(operation, n1, n2) {
  if (operation === "Divide") {
    if (n2 > 0.0) {
      return {
              NAME: "Lognormal",
              VAL: {
                mu: n1.mu - Math.log(n2),
                sigma: n1.sigma
              }
            };
    } else {
      return ;
    }
  } else if (operation === "Multiply" && n2 > 0.0) {
    return {
            NAME: "Lognormal",
            VAL: {
              mu: n1.mu + Math.log(n2),
              sigma: n1.sigma
            }
          };
  } else {
    return ;
  }
}

var Lognormal = {
  make: make$5,
  pdf: pdf$5,
  cdf: cdf$5,
  inv: inv$5,
  mean: mean$5,
  sample: sample$5,
  toString: toString$5,
  from90PercentCI: from90PercentCI$1,
  fromMeanAndStdev: fromMeanAndStdev$1,
  multiply: multiply,
  divide: divide,
  operate: operate$1,
  operateFloatFirst: operateFloatFirst$1,
  operateFloatSecond: operateFloatSecond$1
};

function make$6(low, high) {
  if (high > low) {
    return {
            TAG: 0,
            _0: {
              NAME: "Uniform",
              VAL: {
                low: low,
                high: high
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "High must be larger than low",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$6(x, t) {
  return Jstat.uniform.pdf(x, t.low, t.high);
}

function cdf$6(x, t) {
  return Jstat.uniform.cdf(x, t.low, t.high);
}

function inv$6(p, t) {
  return Jstat.uniform.inv(p, t.low, t.high);
}

function sample$6(t) {
  return Jstat.uniform.sample(t.low, t.high);
}

function mean$6(t) {
  return {
          TAG: 0,
          _0: Jstat.uniform.mean(t.low, t.high),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$6(param) {
  return "Uniform(" + param.low + "," + param.high + ")";
}

function truncate(low, high, t) {
  var newLow = Caml.float_max(E_O$QuriSquiggleLang.$$default(low, Pervasives.neg_infinity), t.low);
  var newHigh = Caml.float_min(E_O$QuriSquiggleLang.$$default(high, Pervasives.infinity), t.high);
  return {
          low: newLow,
          high: newHigh
        };
}

var Uniform = {
  make: make$6,
  pdf: pdf$6,
  cdf: cdf$6,
  inv: inv$6,
  sample: sample$6,
  mean: mean$6,
  toString: toString$6,
  truncate: truncate
};

function make$7($$location, scale) {
  if (scale > 0.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Logistic",
              VAL: {
                location: $$location,
                scale: scale
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Scale must be positive",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$7(x, t) {
  return Stdlib$QuriSquiggleLang.Logistic.pdf(x, t.location, t.scale);
}

function cdf$7(x, t) {
  return Stdlib$QuriSquiggleLang.Logistic.cdf(x, t.location, t.scale);
}

function inv$7(p, t) {
  return Stdlib$QuriSquiggleLang.Logistic.quantile(p, t.location, t.scale);
}

function sample$7(t) {
  var s = sample$6({
        low: 0.0,
        high: 1.0
      });
  return inv$7(s, t);
}

function mean$7(t) {
  return {
          TAG: 0,
          _0: Stdlib$QuriSquiggleLang.Logistic.mean(t.location, t.scale),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$7(param) {
  return "Logistic(" + param.location + "," + param.scale + ")";
}

var Logistic = {
  make: make$7,
  pdf: pdf$7,
  cdf: cdf$7,
  inv: inv$7,
  sample: sample$7,
  mean: mean$7,
  toString: toString$7
};

function make$8(p) {
  if (p >= 0.0 && p <= 1.0) {
    return {
            TAG: 0,
            _0: {
              NAME: "Bernoulli",
              VAL: {
                p: p
              }
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Bernoulli parameter must be between 0 and 1",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pmf(x, t) {
  return Stdlib$QuriSquiggleLang.Bernoulli.pmf(x, t.p);
}

function pdf$8(x, t) {
  return Stdlib$QuriSquiggleLang.Bernoulli.pmf(x, t.p);
}

function cdf$8(x, t) {
  return Stdlib$QuriSquiggleLang.Bernoulli.cdf(x, t.p);
}

function inv$8(p, t) {
  return Stdlib$QuriSquiggleLang.Bernoulli.quantile(p, t.p);
}

function mean$8(t) {
  return {
          TAG: 0,
          _0: Stdlib$QuriSquiggleLang.Bernoulli.mean(t.p),
          [Symbol.for("name")]: "Ok"
        };
}

function min(t) {
  if (t.p === 1.0) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function max(t) {
  if (t.p === 0.0) {
    return 0.0;
  } else {
    return 1.0;
  }
}

function sample$8(t) {
  var s = sample$6({
        low: 0.0,
        high: 1.0
      });
  return inv$8(s, t);
}

function toString$8(param) {
  return "Bernoulli(" + param.p + ")";
}

function toPointSetDist(param) {
  var p = param.p;
  return {
          TAG: 1,
          _0: Discrete$QuriSquiggleLang.make(1.0, undefined, {
                xs: [
                  0.0,
                  1.0
                ],
                ys: [
                  1.0 - p,
                  p
                ]
              }),
          [Symbol.for("name")]: "Discrete"
        };
}

var Bernoulli = {
  make: make$8,
  pmf: pmf,
  pdf: pdf$8,
  cdf: cdf$8,
  inv: inv$8,
  mean: mean$8,
  min: min,
  max: max,
  sample: sample$8,
  toString: toString$8,
  toPointSetDist: toPointSetDist
};

function make$9(shape, scale) {
  if (shape > 0) {
    if (scale > 0) {
      return {
              TAG: 0,
              _0: {
                NAME: "Gamma",
                VAL: {
                  shape: shape,
                  scale: scale
                }
              },
              [Symbol.for("name")]: "Ok"
            };
    } else {
      return {
              TAG: 1,
              _0: "scale must be larger than 0",
              [Symbol.for("name")]: "Error"
            };
    }
  } else {
    return {
            TAG: 1,
            _0: "shape must be larger than 0",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$9(x, t) {
  return Jstat.gamma.pdf(x, t.shape, t.scale);
}

function cdf$9(x, t) {
  return Jstat.gamma.cdf(x, t.shape, t.scale);
}

function inv$9(p, t) {
  return Jstat.gamma.inv(p, t.shape, t.scale);
}

function sample$9(t) {
  return Jstat.gamma.sample(t.shape, t.scale);
}

function mean$9(t) {
  return {
          TAG: 0,
          _0: Jstat.gamma.mean(t.shape, t.scale),
          [Symbol.for("name")]: "Ok"
        };
}

function toString$9(param) {
  return "(" + param.shape + ", " + param.scale + ")";
}

var Gamma = {
  make: make$9,
  pdf: pdf$9,
  cdf: cdf$9,
  inv: inv$9,
  sample: sample$9,
  mean: mean$9,
  toString: toString$9
};

function make$10(t) {
  return {
          NAME: "Float",
          VAL: t
        };
}

function makeSafe(t) {
  if (E_Float$QuriSquiggleLang.$$isFinite(t)) {
    return {
            TAG: 0,
            _0: {
              NAME: "Float",
              VAL: t
            },
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Float must be finite",
            [Symbol.for("name")]: "Error"
          };
  }
}

function pdf$10(x, t) {
  if (x === t) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function cdf$10(x, t) {
  if (x >= t) {
    return 1.0;
  } else {
    return 0.0;
  }
}

function inv$10(p, t) {
  if (p < t) {
    return 0.0;
  } else {
    return 1.0;
  }
}

function mean$10(t) {
  return {
          TAG: 0,
          _0: t,
          [Symbol.for("name")]: "Ok"
        };
}

function sample$10(t) {
  return t;
}

function toString$10(t) {
  return "PointMass(" + t + ")";
}

function toPointSetDist$1(t) {
  return {
          TAG: 1,
          _0: Discrete$QuriSquiggleLang.make(1.0, undefined, {
                xs: [t],
                ys: [1.0]
              }),
          [Symbol.for("name")]: "Discrete"
        };
}

var Float = {
  make: make$10,
  makeSafe: makeSafe,
  pdf: pdf$10,
  cdf: cdf$10,
  inv: inv$10,
  mean: mean$10,
  sample: sample$10,
  toString: toString$10,
  toPointSetDist: toPointSetDist$1
};

function make$11(low, high) {
  if (low <= 0.0 && low < high) {
    return {
            TAG: 0,
            _0: from90PercentCI(low, high),
            [Symbol.for("name")]: "Ok"
          };
  } else if (low < high) {
    return {
            TAG: 0,
            _0: from90PercentCI$1(low, high),
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: "Low value must be less than high value.",
            [Symbol.for("name")]: "Error"
          };
  }
}

var From90thPercentile = {
  make: make$11
};

function pdf$11(x, dist) {
  var variant = dist.NAME;
  if (variant === "Lognormal") {
    return pdf$5(x, dist.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.pdf(x, dist.VAL.rate);
  } else if (variant === "Normal") {
    return pdf(x, dist.VAL);
  } else if (variant === "Cauchy") {
    return pdf$2(x, dist.VAL);
  } else if (variant === "Logistic") {
    return pdf$7(x, dist.VAL);
  } else if (variant === "Uniform") {
    return pdf$6(x, dist.VAL);
  } else if (variant === "Float") {
    return pdf$10(x, dist.VAL);
  } else if (variant === "Gamma") {
    return pdf$9(x, dist.VAL);
  } else if (variant === "Bernoulli") {
    return pdf$8(x, dist.VAL);
  } else if (variant === "Beta") {
    return pdf$4(x, dist.VAL);
  } else {
    return pdf$3(x, dist.VAL);
  }
}

function cdf$11(x, dist) {
  var variant = dist.NAME;
  if (variant === "Lognormal") {
    return cdf$5(x, dist.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.cdf(x, dist.VAL.rate);
  } else if (variant === "Normal") {
    return cdf(x, dist.VAL);
  } else if (variant === "Cauchy") {
    return cdf$2(x, dist.VAL);
  } else if (variant === "Logistic") {
    return cdf$7(x, dist.VAL);
  } else if (variant === "Uniform") {
    return cdf$6(x, dist.VAL);
  } else if (variant === "Float") {
    return cdf$10(x, dist.VAL);
  } else if (variant === "Gamma") {
    return cdf$9(x, dist.VAL);
  } else if (variant === "Bernoulli") {
    return cdf$8(x, dist.VAL);
  } else if (variant === "Beta") {
    return cdf$4(x, dist.VAL);
  } else {
    return cdf$3(x, dist.VAL);
  }
}

function inv$11(x, dist) {
  var variant = dist.NAME;
  if (variant === "Lognormal") {
    return inv$5(x, dist.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.inv(x, dist.VAL.rate);
  } else if (variant === "Normal") {
    return inv(x, dist.VAL);
  } else if (variant === "Cauchy") {
    return inv$2(x, dist.VAL);
  } else if (variant === "Logistic") {
    return inv$7(x, dist.VAL);
  } else if (variant === "Uniform") {
    return inv$6(x, dist.VAL);
  } else if (variant === "Float") {
    return inv$10(x, dist.VAL);
  } else if (variant === "Gamma") {
    return inv$9(x, dist.VAL);
  } else if (variant === "Bernoulli") {
    return inv$8(x, dist.VAL);
  } else if (variant === "Beta") {
    return inv$4(x, dist.VAL);
  } else {
    return inv$3(x, dist.VAL);
  }
}

function sample$11(x) {
  var variant = x.NAME;
  if (variant === "Lognormal") {
    return sample$5(x.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.sample(x.VAL.rate);
  } else if (variant === "Normal") {
    return sample(x.VAL);
  } else if (variant === "Cauchy") {
    return sample$2(x.VAL);
  } else if (variant === "Logistic") {
    return sample$7(x.VAL);
  } else if (variant === "Uniform") {
    return sample$6(x.VAL);
  } else if (variant === "Float") {
    return x.VAL;
  } else if (variant === "Gamma") {
    return sample$9(x.VAL);
  } else if (variant === "Bernoulli") {
    return sample$8(x.VAL);
  } else if (variant === "Beta") {
    return sample$4(x.VAL);
  } else {
    return sample$3(x.VAL);
  }
}

function doN(n, fn) {
  var items = Belt_Array.make(n, 0.0);
  for(var x = 0; x < n; ++x){
    Belt_Array.set(items, x, Curry._1(fn, undefined));
  }
  return items;
}

function sampleN(n, dist) {
  return doN(n, (function (param) {
                return sample$11(dist);
              }));
}

function toString$11(x) {
  var variant = x.NAME;
  if (variant === "Lognormal") {
    return toString$5(x.VAL);
  } else if (variant === "Exponential") {
    return toString$1(x.VAL);
  } else if (variant === "Normal") {
    return toString(x.VAL);
  } else if (variant === "Cauchy") {
    return toString$2(x.VAL);
  } else if (variant === "Logistic") {
    return toString$7(x.VAL);
  } else if (variant === "Uniform") {
    return toString$6(x.VAL);
  } else if (variant === "Float") {
    return toString$10(x.VAL);
  } else if (variant === "Gamma") {
    return toString$9(x.VAL);
  } else if (variant === "Bernoulli") {
    return toString$8(x.VAL);
  } else if (variant === "Beta") {
    return toString$4(x.VAL);
  } else {
    return toString$3(x.VAL);
  }
}

function min$1(x) {
  var variant = x.NAME;
  if (variant === "Lognormal") {
    return inv$5(0.0001, x.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.inv(0.0001, x.VAL.rate);
  } else if (variant === "Normal") {
    return inv(0.0001, x.VAL);
  } else if (variant === "Cauchy") {
    return inv$2(0.0001, x.VAL);
  } else if (variant === "Logistic") {
    return inv$7(0.0001, x.VAL);
  } else if (variant === "Float") {
    return x.VAL;
  } else if (variant === "Gamma") {
    return inv$9(0.0001, x.VAL);
  } else if (variant === "Bernoulli") {
    return min(x.VAL);
  } else if (variant === "Beta") {
    return inv$4(0.0001, x.VAL);
  } else {
    return x.VAL.low;
  }
}

function max$1(x) {
  var variant = x.NAME;
  if (variant === "Lognormal") {
    return inv$5(0.9999, x.VAL);
  } else if (variant === "Exponential") {
    return Jstat.exponential.inv(0.9999, x.VAL.rate);
  } else if (variant === "Normal") {
    return inv(0.9999, x.VAL);
  } else if (variant === "Cauchy") {
    return inv$2(0.9999, x.VAL);
  } else if (variant === "Logistic") {
    return inv$7(0.9999, x.VAL);
  } else if (variant === "Uniform") {
    return x.VAL.high;
  } else if (variant === "Float") {
    return x.VAL;
  } else if (variant === "Gamma") {
    return inv$9(0.9999, x.VAL);
  } else if (variant === "Bernoulli") {
    return max(x.VAL);
  } else if (variant === "Beta") {
    return inv$4(0.9999, x.VAL);
  } else {
    return x.VAL.high;
  }
}

function mean$11(x) {
  var variant = x.NAME;
  if (variant === "Lognormal") {
    return mean$5(x.VAL);
  } else if (variant === "Exponential") {
    return {
            TAG: 0,
            _0: Jstat.exponential.mean(x.VAL.rate),
            [Symbol.for("name")]: "Ok"
          };
  } else if (variant === "Normal") {
    return mean(x.VAL);
  } else if (variant === "Cauchy") {
    return {
            TAG: 1,
            _0: "Cauchy distributions may have no mean value.",
            [Symbol.for("name")]: "Error"
          };
  } else if (variant === "Logistic") {
    return mean$7(x.VAL);
  } else if (variant === "Uniform") {
    return mean$6(x.VAL);
  } else if (variant === "Float") {
    return {
            TAG: 0,
            _0: x.VAL,
            [Symbol.for("name")]: "Ok"
          };
  } else if (variant === "Gamma") {
    return mean$9(x.VAL);
  } else if (variant === "Bernoulli") {
    return mean$8(x.VAL);
  } else if (variant === "Beta") {
    return mean$4(x.VAL);
  } else {
    return mean$3(x.VAL);
  }
}

function operate$2(distToFloatOp, s) {
  if (typeof distToFloatOp !== "object") {
    if (distToFloatOp === "Max") {
      return {
              TAG: 0,
              _0: max$1(s),
              [Symbol.for("name")]: "Ok"
            };
    } else if (distToFloatOp === "Min") {
      return {
              TAG: 0,
              _0: min$1(s),
              [Symbol.for("name")]: "Ok"
            };
    } else if (distToFloatOp === "Mean") {
      return mean$11(s);
    } else {
      return {
              TAG: 0,
              _0: sample$11(s),
              [Symbol.for("name")]: "Ok"
            };
    }
  }
  var variant = distToFloatOp.NAME;
  if (variant === "Inv") {
    return {
            TAG: 0,
            _0: inv$11(distToFloatOp.VAL, s),
            [Symbol.for("name")]: "Ok"
          };
  } else if (variant === "Pdf") {
    return {
            TAG: 0,
            _0: pdf$11(distToFloatOp.VAL, s),
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 0,
            _0: cdf$11(distToFloatOp.VAL, s),
            [Symbol.for("name")]: "Ok"
          };
  }
}

function interpolateXs(xSelectionOpt, dist, n) {
  var xSelection = xSelectionOpt !== undefined ? xSelectionOpt : "Linear";
  if (xSelection === "Linear") {
    return E_A$QuriSquiggleLang.Floats.range(min$1(dist), max$1(dist), n);
  }
  if (typeof dist === "object" && dist.NAME === "Uniform") {
    var n$1 = dist.VAL;
    var distance = n$1.high - n$1.low;
    var dx = MagicNumbers$QuriSquiggleLang.Epsilon.ten * distance;
    return [
            n$1.low - dx,
            n$1.low,
            n$1.low + dx,
            n$1.high - dx,
            n$1.high,
            n$1.high + dx
          ];
  }
  var ys = E_A$QuriSquiggleLang.Floats.range(0.0001, 0.9999, n);
  return E_A$QuriSquiggleLang.fmap(ys, (function (y) {
                return inv$11(y, dist);
              }));
}

function tryAnalyticalSimplification(d1, d2, op) {
  if (typeof d1 !== "object") {
    return "NoSolution";
  }
  var variant = d1.NAME;
  if (variant === "Lognormal") {
    if (typeof d2 !== "object") {
      return "NoSolution";
    }
    var variant$1 = d2.NAME;
    var v1 = d1.VAL;
    if (variant$1 === "Lognormal") {
      return E_O$QuriSquiggleLang.dimap(operate$1(op, v1, d2.VAL), (function (r) {
                    return {
                            NAME: "AnalyticalSolution",
                            VAL: r
                          };
                  }), (function (param) {
                    return "NoSolution";
                  }));
    } else if (variant$1 === "Float") {
      return E_O$QuriSquiggleLang.dimap(operateFloatSecond$1(op, v1, d2.VAL), (function (r) {
                    return {
                            NAME: "AnalyticalSolution",
                            VAL: r
                          };
                  }), (function (param) {
                    return "NoSolution";
                  }));
    } else {
      return "NoSolution";
    }
  }
  if (variant === "Normal") {
    if (typeof d2 !== "object") {
      return "NoSolution";
    }
    var variant$2 = d2.NAME;
    var v1$1 = d1.VAL;
    if (variant$2 === "Normal") {
      return E_O$QuriSquiggleLang.dimap(operate(op, v1$1, d2.VAL), (function (r) {
                    return {
                            NAME: "AnalyticalSolution",
                            VAL: r
                          };
                  }), (function (param) {
                    return "NoSolution";
                  }));
    } else if (variant$2 === "Float") {
      return E_O$QuriSquiggleLang.dimap(operateFloatSecond(op, v1$1, d2.VAL), (function (r) {
                    return {
                            NAME: "AnalyticalSolution",
                            VAL: r
                          };
                  }), (function (param) {
                    return "NoSolution";
                  }));
    } else {
      return "NoSolution";
    }
  }
  if (variant !== "Float") {
    return "NoSolution";
  }
  if (typeof d2 !== "object") {
    return "NoSolution";
  }
  var variant$3 = d2.NAME;
  var v1$2 = d1.VAL;
  if (variant$3 === "Lognormal") {
    return E_O$QuriSquiggleLang.dimap(operateFloatFirst$1(op, v1$2, d2.VAL), (function (r) {
                  return {
                          NAME: "AnalyticalSolution",
                          VAL: r
                        };
                }), (function (param) {
                  return "NoSolution";
                }));
  }
  if (variant$3 === "Normal") {
    return E_O$QuriSquiggleLang.dimap(operateFloatFirst(op, v1$2, d2.VAL), (function (r) {
                  return {
                          NAME: "AnalyticalSolution",
                          VAL: r
                        };
                }), (function (param) {
                  return "NoSolution";
                }));
  }
  if (variant$3 !== "Float") {
    return "NoSolution";
  }
  var r = Operation$QuriSquiggleLang.Algebraic.toFn(op, v1$2, d2.VAL);
  if (r.TAG === /* Ok */0) {
    return {
            NAME: "AnalyticalSolution",
            VAL: {
              NAME: "Float",
              VAL: r._0
            }
          };
  } else {
    return {
            NAME: "Error",
            VAL: r._0
          };
  }
}

function toPointSetDist$2(xSelectionOpt, sampleCount, d) {
  var xSelection = xSelectionOpt !== undefined ? xSelectionOpt : "ByWeight";
  if (typeof d === "object") {
    var variant = d.NAME;
    if (variant === "Float") {
      return toPointSetDist$1(d.VAL);
    }
    if (variant === "Bernoulli") {
      return toPointSetDist(d.VAL);
    }
    
  }
  var xs = interpolateXs(xSelection, d, sampleCount);
  var ys = E_A$QuriSquiggleLang.fmap(xs, (function (x) {
          return pdf$11(x, d);
        }));
  return {
          TAG: 2,
          _0: Continuous$QuriSquiggleLang.make(undefined, 1.0, undefined, {
                xs: xs,
                ys: ys
              }),
          [Symbol.for("name")]: "Continuous"
        };
}

var T = {
  minCdfValue: 0.0001,
  maxCdfValue: 0.9999,
  pdf: pdf$11,
  cdf: cdf$11,
  inv: inv$11,
  sample: sample$11,
  doN: doN,
  sampleN: sampleN,
  toString: toString$11,
  min: min$1,
  max: max$1,
  mean: mean$11,
  operate: operate$2,
  interpolateXs: interpolateXs,
  tryAnalyticalSimplification: tryAnalyticalSimplification,
  toPointSetDist: toPointSetDist$2
};

var normal95confidencePoint = 1.6448536269514722;

exports.normal95confidencePoint = normal95confidencePoint;
exports.Normal = Normal;
exports.Exponential = Exponential;
exports.Cauchy = Cauchy;
exports.Triangular = Triangular;
exports.Beta = Beta;
exports.Lognormal = Lognormal;
exports.Uniform = Uniform;
exports.Logistic = Logistic;
exports.Bernoulli = Bernoulli;
exports.Gamma = Gamma;
exports.Float = Float;
exports.From90thPercentile = From90thPercentile;
exports.T = T;
/* jstat Not a pure module */
