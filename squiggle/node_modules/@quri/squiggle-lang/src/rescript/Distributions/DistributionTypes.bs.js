'use strict';

var E_I$QuriSquiggleLang = require("../Utility/E/E_I.bs.js");
var E_R$QuriSquiggleLang = require("../Utility/E/E_R.bs.js");
var E_Float$QuriSquiggleLang = require("../Utility/E/E_Float.bs.js");
var XYShape$QuriSquiggleLang = require("../Utility/XYShape.bs.js");
var Operation$QuriSquiggleLang = require("../Utility/Operation.bs.js");
var PointSetTypes$QuriSquiggleLang = require("./PointSetDist/PointSetTypes.bs.js");
var SampleSetDist$QuriSquiggleLang = require("./SampleSetDist/SampleSetDist.bs.js");

function fromString(s) {
  return {
          TAG: 7,
          _0: s,
          [Symbol.for("name")]: "OtherError"
        };
}

function toString(err) {
  if (typeof err === "number") {
    switch (err) {
      case /* NotYetImplemented */0 :
          return "Function not yet implemented";
      case /* Unreachable */1 :
          return "Unreachable";
      case /* DistributionVerticalShiftIsInvalid */2 :
          return "Distribution vertical shift is invalid";
      
    }
  } else {
    switch (err.TAG | 0) {
      case /* SampleSetError */0 :
          var err$1 = err._0;
          if (typeof err$1 === "number") {
            return "Too Few Samples";
          } else if (err$1.TAG === /* NonNumericInput */0) {
            return "Found a non-number in input: " + err$1._0 + "";
          } else {
            return Operation$QuriSquiggleLang.$$Error.toString(err$1._0);
          }
      case /* ArgumentError */1 :
          return "Argument Error " + err._0 + "";
      case /* OperationError */2 :
          return Operation$QuriSquiggleLang.$$Error.toString(err._0);
      case /* PointSetConversionError */3 :
          return SampleSetDist$QuriSquiggleLang.pointsetConversionErrorToString(err._0);
      case /* SparklineError */4 :
          return PointSetTypes$QuriSquiggleLang.sparklineErrorToString(err._0);
      case /* RequestedStrategyInvalidError */5 :
          return "Requested strategy invalid: " + err._0 + "";
      case /* LogarithmOfDistributionError */6 :
          return "Logarithm of input error: " + err._0 + "";
      case /* OtherError */7 :
          return err._0;
      case /* XYShapeError */8 :
          return "XY Shape Error: " + XYShape$QuriSquiggleLang.$$Error.toString(err._0) + "";
      
    }
  }
}

function resultStringToResultError(n) {
  return E_R$QuriSquiggleLang.errMap(n, (function (r) {
                return {
                        TAG: 7,
                        _0: r,
                        [Symbol.for("name")]: "OtherError"
                      };
              }));
}

function sampleErrorToDistErr(err) {
  return {
          TAG: 0,
          _0: err,
          [Symbol.for("name")]: "SampleSetError"
        };
}

var $$Error = {
  fromString: fromString,
  toString: toString,
  resultStringToResultError: resultStringToResultError,
  sampleErrorToDistErr: sampleErrorToDistErr
};

function floatCallToString(floatFunction) {
  var variant = floatFunction.NAME;
  if (variant === "ToString") {
    var n = floatFunction.VAL;
    if (n) {
      return "sparkline(" + E_I$QuriSquiggleLang.toString(n._0) + ")";
    } else {
      return "toString";
    }
  }
  if (variant === "ToFloat") {
    var match = floatFunction.VAL;
    if (typeof match !== "object") {
      if (match === "Sample") {
        return "sample";
      } else if (match === "IntegralSum") {
        return "integralSum";
      } else if (match === "Max") {
        return "max";
      } else if (match === "Min") {
        return "min";
      } else if (match === "Stdev") {
        return "stdev";
      } else if (match === "Mean") {
        return "mean";
      } else if (match === "Mode") {
        return "mode";
      } else {
        return "variance";
      }
    }
    var variant$1 = match.NAME;
    if (variant$1 === "Inv") {
      return "inv(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
    } else if (variant$1 === "Pdf") {
      return "pdf(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
    } else {
      return "cdf(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
    }
  }
  if (variant === "ToBool") {
    return "isNormalized";
  }
  if (variant !== "ToDist") {
    if (floatFunction.VAL[0]) {
      return "algebraic";
    } else {
      return "pointwise";
    }
  }
  var r = floatFunction.VAL;
  if (typeof r === "number") {
    switch (r) {
      case /* Normalize */0 :
          return "normalize";
      case /* ToPointSet */1 :
          return "toPointSet";
      case /* Inspect */2 :
          return "inspect";
      
    }
  } else {
    switch (r.TAG | 0) {
      case /* ToSampleSet */0 :
          return "toSampleSet(" + E_I$QuriSquiggleLang.toString(r._0) + ")";
      case /* Scale */1 :
          var match$1 = r._0;
          if (typeof match$1 === "object") {
            return "scaleLogWithThreshold(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ", epsilon=" + E_Float$QuriSquiggleLang.toFixed(match$1.VAL) + ")";
          } else if (match$1 === "Power") {
            return "scalePower(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
          } else if (match$1 === "Multiply") {
            return "scaleMultiply(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
          } else {
            return "scaleLog(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
          }
      case /* Truncate */2 :
          return "truncate";
      
    }
  }
}

function distCallToString(distFunction) {
  var variant = distFunction.NAME;
  if (variant === "ToString") {
    return floatCallToString({
                NAME: "ToString",
                VAL: distFunction.VAL
              });
  }
  if (variant === "ToScore") {
    return "logScore";
  }
  if (variant === "ToFloat") {
    return floatCallToString({
                NAME: "ToFloat",
                VAL: distFunction.VAL
              });
  }
  if (variant === "ToBool") {
    return floatCallToString({
                NAME: "ToBool",
                VAL: distFunction.VAL
              });
  }
  if (variant === "ToDist") {
    return floatCallToString({
                NAME: "ToDist",
                VAL: distFunction.VAL
              });
  }
  var match = distFunction.VAL;
  return floatCallToString({
              NAME: "ToDistCombination",
              VAL: [
                match[0],
                match[1],
                match[2]
              ]
            });
}

function toString$1(d) {
  switch (d.TAG | 0) {
    case /* FromDist */0 :
        return distCallToString(d._0);
    case /* FromFloat */1 :
        return floatCallToString(d._0);
    case /* FromSamples */2 :
        return "fromSamples";
    case /* Mixture */3 :
        return "mixture";
    
  }
}

var DistributionOperation = {
  floatCallToString: floatCallToString,
  distCallToString: distCallToString,
  toString: toString$1
};

function mean(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: "Mean"
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function stdev(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: "Stdev"
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function variance(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: "Variance"
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function sample(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: "Sample"
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function cdf(dist, x) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: {
              NAME: "Cdf",
              VAL: x
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function inv(dist, x) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: {
              NAME: "Inv",
              VAL: x
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function pdf(dist, x) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToFloat",
            VAL: {
              NAME: "Pdf",
              VAL: x
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function normalize(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: /* Normalize */0
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function isNormalized(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToBool",
            VAL: /* IsNormalized */0
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function toPointSet(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: /* ToPointSet */1
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function toSampleSet(dist, r) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 0,
              _0: r,
              [Symbol.for("name")]: "ToSampleSet"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function fromSamples(xs) {
  return {
          TAG: 2,
          _0: xs,
          [Symbol.for("name")]: "FromSamples"
        };
}

function truncate(dist, left, right) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 2,
              _0: left,
              _1: right,
              [Symbol.for("name")]: "Truncate"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function inspect(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: /* Inspect */2
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function distEstimateDistAnswer(estimate, answer) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToScore",
            VAL: {
              _0: {
                TAG: 0,
                _0: answer,
                [Symbol.for("name")]: "Score_Dist"
              },
              _1: undefined,
              [Symbol.for("name")]: "LogScore"
            }
          },
          _1: estimate,
          [Symbol.for("name")]: "FromDist"
        };
}

function distEstimateDistAnswerWithPrior(estimate, answer, prior) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToScore",
            VAL: {
              _0: {
                TAG: 0,
                _0: answer,
                [Symbol.for("name")]: "Score_Dist"
              },
              _1: prior,
              [Symbol.for("name")]: "LogScore"
            }
          },
          _1: estimate,
          [Symbol.for("name")]: "FromDist"
        };
}

function distEstimateScalarAnswer(estimate, answer) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToScore",
            VAL: {
              _0: {
                TAG: 1,
                _0: answer,
                [Symbol.for("name")]: "Score_Scalar"
              },
              _1: undefined,
              [Symbol.for("name")]: "LogScore"
            }
          },
          _1: estimate,
          [Symbol.for("name")]: "FromDist"
        };
}

function distEstimateScalarAnswerWithPrior(estimate, answer, prior) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToScore",
            VAL: {
              _0: {
                TAG: 1,
                _0: answer,
                [Symbol.for("name")]: "Score_Scalar"
              },
              _1: prior,
              [Symbol.for("name")]: "LogScore"
            }
          },
          _1: estimate,
          [Symbol.for("name")]: "FromDist"
        };
}

var LogScore = {
  distEstimateDistAnswer: distEstimateDistAnswer,
  distEstimateDistAnswerWithPrior: distEstimateDistAnswerWithPrior,
  distEstimateScalarAnswer: distEstimateScalarAnswer,
  distEstimateScalarAnswerWithPrior: distEstimateScalarAnswerWithPrior
};

function scaleMultiply(dist, n) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 1,
              _0: "Multiply",
              _1: n,
              [Symbol.for("name")]: "Scale"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function scalePower(dist, n) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 1,
              _0: "Power",
              _1: n,
              [Symbol.for("name")]: "Scale"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function scaleLogarithm(dist, n) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 1,
              _0: "Logarithm",
              _1: n,
              [Symbol.for("name")]: "Scale"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function scaleLogarithmWithThreshold(dist, n, eps) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDist",
            VAL: {
              TAG: 1,
              _0: {
                NAME: "LogarithmWithThreshold",
                VAL: eps
              },
              _1: n,
              [Symbol.for("name")]: "Scale"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function toString$2(dist) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToString",
            VAL: /* ToString */0
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function toSparkline(dist, n) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToString",
            VAL: {
              _0: n,
              [Symbol.for("name")]: "ToSparkline"
            }
          },
          _1: dist,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicAdd(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Add",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicMultiply(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Multiply",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicDivide(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Divide",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicSubtract(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Subtract",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicLogarithm(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Logarithm",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function algebraicPower(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              {
                _0: /* AsDefault */0,
                [Symbol.for("name")]: "Algebraic"
              },
              "Power",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwiseAdd(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Add",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwiseMultiply(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Multiply",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwiseDivide(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Divide",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwiseSubtract(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Subtract",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwiseLogarithm(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Logarithm",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

function pointwisePower(dist1, dist2) {
  return {
          TAG: 0,
          _0: {
            NAME: "ToDistCombination",
            VAL: [
              /* Pointwise */0,
              "Power",
              {
                NAME: "Dist",
                VAL: dist2
              }
            ]
          },
          _1: dist1,
          [Symbol.for("name")]: "FromDist"
        };
}

var UsingDists = {
  mean: mean,
  stdev: stdev,
  variance: variance,
  sample: sample,
  cdf: cdf,
  inv: inv,
  pdf: pdf,
  normalize: normalize,
  isNormalized: isNormalized,
  toPointSet: toPointSet,
  toSampleSet: toSampleSet,
  fromSamples: fromSamples,
  truncate: truncate,
  inspect: inspect,
  LogScore: LogScore,
  scaleMultiply: scaleMultiply,
  scalePower: scalePower,
  scaleLogarithm: scaleLogarithm,
  scaleLogarithmWithThreshold: scaleLogarithmWithThreshold,
  toString: toString$2,
  toSparkline: toSparkline,
  algebraicAdd: algebraicAdd,
  algebraicMultiply: algebraicMultiply,
  algebraicDivide: algebraicDivide,
  algebraicSubtract: algebraicSubtract,
  algebraicLogarithm: algebraicLogarithm,
  algebraicPower: algebraicPower,
  pointwiseAdd: pointwiseAdd,
  pointwiseMultiply: pointwiseMultiply,
  pointwiseDivide: pointwiseDivide,
  pointwiseSubtract: pointwiseSubtract,
  pointwiseLogarithm: pointwiseLogarithm,
  pointwisePower: pointwisePower
};

var Constructors = {
  UsingDists: UsingDists
};

exports.$$Error = $$Error;
exports.DistributionOperation = DistributionOperation;
exports.Constructors = Constructors;
/* XYShape-QuriSquiggleLang Not a pure module */
