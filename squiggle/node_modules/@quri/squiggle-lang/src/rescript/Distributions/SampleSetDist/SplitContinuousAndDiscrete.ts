/*
  This function goes through a sorted array and divides it into two different clusters:
  continuous samples and discrete samples. The discrete samples are stored in a mutable map.
  Samples are considered discrete if they have at least `minDiscreteWight` duplicates.
  Using a `minDiscreteWight` higher than 2 is important because sometimes common elements
  will be generated by regular operations.
  The final continuous array will be sorted.

  The method here is designed for high performance for fairly small `minDiscreteWight`
  values for both mostly-continuous and mostly-discrete inputs.
  For each position i it visits, it compares it to the place where a run starting at i would end.
  For continuous distributions, this comparison is always false, keeping branch prediction costs low.
  If the comparison is true, it finds the complete run with recursive doubling then a binary search,
  which skips over many elements for long runs.
*/
export const splitContinuousAndDiscrete = (
  sortedArray: number[],
  minDiscreteWeight: number
) => {
  const continuous: number[] = [];
  const discreteCount: number[] = [];
  const discreteValue: number[] = [];

  if (!Number.isInteger(minDiscreteWeight)) {
    throw new Error("Minimum discrete weight must be an integer");
  }
  if (minDiscreteWeight <= 1) {
    // Weight of 1 is pointless because it indicates only discrete values,
    // and causes an infinite loop in the doubling search used here.
    throw new Error("Minimum discrete weight must be at least 2");
  }

  // In a run of exactly minDiscreteWeight, the first and last
  // element indices differ by minDistance.
  const minDistance = minDiscreteWeight - 1;

  const len = sortedArray.length;
  let i = 0;
  while (i < len - minDistance) {
    // We are interested in runs of elements equal to value
    const value = sortedArray[i];
    if (value !== sortedArray[i + minDistance]) {
      // No long run starting at i, so it's continuous
      continuous.push(value);
      i++;
    } else {
      // Now we know that a run starts at i
      // Move i forward to next unequal value
      // That is, find iNext so that isEqualAt(iNext-1) and !isEqualAt(iNext)
      const iOrig = i;
      // Find base so that iNext is in (iOrig+base, iOrig+2*base]
      // This is where we start the binary search
      let base = minDistance;
      const isEqualAt = (ind: number) =>
        ind < len && sortedArray[ind] === value;
      while (isEqualAt(iOrig + base * 2)) {
        base *= 2;
      }
      // Maintain iNext in (lo, i]. Once lo+1 === i, i is iNext.
      let lo = iOrig + base;
      i = Math.min(lo + base, len);
      while (i - lo > 1) {
        const mid = lo + Math.floor((i - lo) / 2);
        if (sortedArray[mid] === value) {
          lo = mid;
        } else {
          i = mid;
        }
      }

      discreteValue.push(value);
      discreteCount.push(i - iOrig);
    }
  }
  // Remaining values are continuous
  continuous.push(...sortedArray.slice(i));

  return {
    continuousPart: continuous,
    discretePart: { xs: discreteValue, ys: discreteCount },
  };
};
