'use strict';

var Js_math = require("@rescript/std/lib/js/js_math.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var E_I$QuriSquiggleLang = require("../../Utility/E/E_I.bs.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var E_Float$QuriSquiggleLang = require("../../Utility/E/E_Float.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var Discrete$QuriSquiggleLang = require("../PointSetDist/Discrete.bs.js");
var E_Tuple2$QuriSquiggleLang = require("../../Utility/E/E_Tuple2.bs.js");
var E_Tuple3$QuriSquiggleLang = require("../../Utility/E/E_Tuple3.bs.js");
var SampleSetDist_ToPointSet = require("./SampleSetDist_ToPointSet");
var Operation$QuriSquiggleLang = require("../../Utility/Operation.bs.js");
var Continuous$QuriSquiggleLang = require("../PointSetDist/Continuous.bs.js");
var MixedShapeBuilder$QuriSquiggleLang = require("../PointSetDist/MixedShapeBuilder.bs.js");

function toPointSetDist(prim0, prim1, prim2) {
  return SampleSetDist_ToPointSet.toPointSetDist(prim0, prim1, prim2);
}

var JS = {
  toPointSetDist: toPointSetDist
};

function pointsetConversionErrorToString(err) {
  return "Too Few Samples to convert to point set";
}

function fromOperationError(e) {
  return {
          TAG: 1,
          _0: e,
          [Symbol.for("name")]: "OperationError"
        };
}

function toString(err) {
  if (typeof err === "number") {
    return "Too few samples when constructing sample set";
  } else if (err.TAG === /* NonNumericInput */0) {
    return "Found a non-number in input: " + err._0 + "";
  } else {
    return Operation$QuriSquiggleLang.$$Error.toString(err._0);
  }
}

var $$Error = {
  pointsetConversionErrorToString: pointsetConversionErrorToString,
  fromOperationError: fromOperationError,
  toString: toString
};

function make(a) {
  if (E_A$QuriSquiggleLang.length(a) > 5) {
    return {
            TAG: 0,
            _0: a,
            [Symbol.for("name")]: "Ok"
          };
  } else {
    return {
            TAG: 1,
            _0: /* TooFewSamples */0,
            [Symbol.for("name")]: "Error"
          };
  }
}

function get(a) {
  return a;
}

var T = {
  make: make,
  get: get
};

var length = E_A$QuriSquiggleLang.length;

function toPointSetDist$1(samples, samplingInputs) {
  var dists = SampleSetDist_ToPointSet.toPointSetDist(samples, samplingInputs.outputXYPoints, samplingInputs.kernelWidth);
  return E_O$QuriSquiggleLang.toResult(MixedShapeBuilder$QuriSquiggleLang.buildSimple(E_O$QuriSquiggleLang.fmap(dists.continuousDist, (function (eta) {
                        return Continuous$QuriSquiggleLang.make(undefined, undefined, undefined, eta);
                      })), Discrete$QuriSquiggleLang.make(undefined, undefined, dists.discreteDist)), /* TooFewSamplesForConversionToPointSet */0);
}

function sample(t) {
  var i = Js_math.random_int(0, E_A$QuriSquiggleLang.length(t) - 1 | 0);
  return E_A$QuriSquiggleLang.unsafe_get(t, i);
}

function sampleN(t, n) {
  if (n <= E_A$QuriSquiggleLang.length(t)) {
    return E_A$QuriSquiggleLang.slice(t, 0, n);
  } else {
    return E_A$QuriSquiggleLang.makeBy(n, (function (param) {
                  return sample(t);
                }));
  }
}

function _fromSampleResultArray(samples) {
  return E_R$QuriSquiggleLang.bind(E_R$QuriSquiggleLang.errMap(E_A$QuriSquiggleLang.R.firstErrorOrOpen(samples), fromOperationError), make);
}

function samplesMap(fn, t) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(t, fn));
}

function map2(fn, t1, t2) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.zip(t1, t2), (function (param) {
                    return E_Tuple2$QuriSquiggleLang.toFnCall(fn, param);
                  })));
}

function map3(fn, t1, t2, t3) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.zip3(t1, t2, t3), (function (param) {
                    return E_Tuple3$QuriSquiggleLang.toFnCall(fn, param);
                  })));
}

function mapN(fn, t1) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.transpose(E_A$QuriSquiggleLang.fmap(t1, get)), fn));
}

function mean(t) {
  return E_A$QuriSquiggleLang.Floats.mean(t);
}

function geomean(t) {
  return E_A$QuriSquiggleLang.Floats.geomean(t);
}

function mode(t) {
  return E_A$QuriSquiggleLang.Floats.mode(t);
}

function sum(t) {
  return E_A$QuriSquiggleLang.Floats.sum(t);
}

function min(t) {
  return E_A$QuriSquiggleLang.Floats.min(t);
}

function max(t) {
  return E_A$QuriSquiggleLang.Floats.max(t);
}

function stdev(t) {
  return E_A$QuriSquiggleLang.Floats.stdev(t);
}

function variance(t) {
  return E_A$QuriSquiggleLang.Floats.variance(t);
}

function percentile(t, f) {
  return E_A$QuriSquiggleLang.Floats.percentile(t, f);
}

function cdf(t, f) {
  var countBelowF = E_A$QuriSquiggleLang.reduce(t, 0, (function (acc, x) {
          return acc + (
                  x <= f ? 1 : 0
                ) | 0;
        }));
  return countBelowF / E_A$QuriSquiggleLang.length(t);
}

function mixture(values, intendedLength) {
  var totalWeight = E_A$QuriSquiggleLang.Floats.sum(E_A$QuriSquiggleLang.fmap(values, E_Tuple2$QuriSquiggleLang.second));
  var discreteSamples = Discrete$QuriSquiggleLang.sampleN(Discrete$QuriSquiggleLang.make(undefined, undefined, XYShape$QuriSquiggleLang.T.fromZippedArray(E_A$QuriSquiggleLang.fmapi(values, (function (i, param) {
                      return [
                              E_I$QuriSquiggleLang.toFloat(i),
                              param[1] / totalWeight
                            ];
                    })))), intendedLength);
  var dists = E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.fmap(values, E_Tuple2$QuriSquiggleLang.first), get);
  var samples = E_A$QuriSquiggleLang.O.openIfAllSome(E_A$QuriSquiggleLang.fmapi(discreteSamples, (function (index, distIndexToChoose) {
              var chosenDist = E_A$QuriSquiggleLang.get(dists, E_Float$QuriSquiggleLang.toInt(distIndexToChoose));
              return E_O$QuriSquiggleLang.bind(chosenDist, (function (__x) {
                            return E_A$QuriSquiggleLang.get(__x, index);
                          }));
            })));
  return make(E_O$QuriSquiggleLang.toExn(samples, "Mixture unreachable error"));
}

function truncateLeft(t, f) {
  return make(E_A$QuriSquiggleLang.filter(t, (function (x) {
                    return x >= f;
                  })));
}

function truncateRight(t, f) {
  return make(E_A$QuriSquiggleLang.filter(t, (function (x) {
                    return x <= f;
                  })));
}

function truncate(t, leftCutoff, rightCutoff) {
  var withTruncatedLeft = function (t) {
    return E_O$QuriSquiggleLang.dimap(leftCutoff, (function (left) {
                  return truncateLeft(t, left);
                }), (function (param) {
                  return {
                          TAG: 0,
                          _0: t,
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  };
  var withTruncatedRight = function (t) {
    return E_O$QuriSquiggleLang.dimap(rightCutoff, (function (left) {
                  return truncateRight(t, left);
                }), (function (param) {
                  return {
                          TAG: 0,
                          _0: t,
                          [Symbol.for("name")]: "Ok"
                        };
                }));
  };
  return E_R$QuriSquiggleLang.bind(withTruncatedLeft(t), withTruncatedRight);
}

function minOfTwo(t1, t2) {
  return map2((function (a, b) {
                return {
                        TAG: 0,
                        _0: Math.min(a, b),
                        [Symbol.for("name")]: "Ok"
                      };
              }), t1, t2);
}

function maxOfTwo(t1, t2) {
  return map2((function (a, b) {
                return {
                        TAG: 0,
                        _0: Math.max(a, b),
                        [Symbol.for("name")]: "Ok"
                      };
              }), t1, t2);
}

function minOfFloat(t, f) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(t, (function (a) {
                    return {
                            TAG: 0,
                            _0: Math.min(a, f),
                            [Symbol.for("name")]: "Ok"
                          };
                  })));
}

function maxOfFloat(t, f) {
  return _fromSampleResultArray(E_A$QuriSquiggleLang.fmap(t, (function (a) {
                    return {
                            TAG: 0,
                            _0: Math.max(a, f),
                            [Symbol.for("name")]: "Ok"
                          };
                  })));
}

exports.JS = JS;
exports.$$Error = $$Error;
exports.pointsetConversionErrorToString = pointsetConversionErrorToString;
exports.fromOperationError = fromOperationError;
exports.toString = toString;
exports.T = T;
exports.make = make;
exports.get = get;
exports.length = length;
exports.toPointSetDist = toPointSetDist$1;
exports.sample = sample;
exports.sampleN = sampleN;
exports._fromSampleResultArray = _fromSampleResultArray;
exports.samplesMap = samplesMap;
exports.map2 = map2;
exports.map3 = map3;
exports.mapN = mapN;
exports.mean = mean;
exports.geomean = geomean;
exports.mode = mode;
exports.sum = sum;
exports.min = min;
exports.max = max;
exports.stdev = stdev;
exports.variance = variance;
exports.percentile = percentile;
exports.cdf = cdf;
exports.mixture = mixture;
exports.truncateLeft = truncateLeft;
exports.truncateRight = truncateRight;
exports.truncate = truncate;
exports.minOfTwo = minOfTwo;
exports.maxOfTwo = maxOfTwo;
exports.minOfFloat = minOfFloat;
exports.maxOfFloat = maxOfFloat;
/* E_A-QuriSquiggleLang Not a pure module */
