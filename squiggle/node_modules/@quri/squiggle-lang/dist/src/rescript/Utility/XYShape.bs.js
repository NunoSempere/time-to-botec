'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Js_array = require("@rescript/std/lib/js/js_array.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_array = require("@rescript/std/lib/js/caml_array.js");
var Caml_int32 = require("@rescript/std/lib/js/caml_int32.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var Belt_Option = require("@rescript/std/lib/js/belt_Option.js");
var E_A$QuriSquiggleLang = require("./E/E_A.bs.js");
var E_I$QuriSquiggleLang = require("./E/E_I.bs.js");
var E_O$QuriSquiggleLang = require("./E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("./E/E_R.bs.js");
var E_Float$QuriSquiggleLang = require("./E/E_Float.bs.js");
var MagicNumbers$QuriSquiggleLang = require("../MagicNumbers.bs.js");
function mapErrorArrayToError(errors) {
    var len = errors.length;
    if (len !== 1) {
        if (len !== 0) {
            return {
                TAG: 4,
                _0: errors,
                [Symbol.for("name")]: "MultipleErrors"
            };
        }
        else {
            return;
        }
    }
    else {
        return errors[0];
    }
}
function toString(t) {
    switch (t.TAG | 0) {
        case 0:
            return "" + t._0 + " is not sorted";
        case 1:
            return "" + t._0 + " is empty";
        case 2:
            return "" + t._0 + " is not finite. Example value: " + E_Float$QuriSquiggleLang.toString(t._1) + "";
        case 3:
            var p2Name = t.p2Name;
            var p1Name = t.p1Name;
            return "" + p1Name + " and " + p2Name + " have different lengths. " + p1Name + " has length " + E_I$QuriSquiggleLang.toString(t.p1Length) + " and " + p2Name + " has length " + E_I$QuriSquiggleLang.toString(t.p2Length) + "";
        case 4:
            return "Multiple Errors: " + E_A$QuriSquiggleLang.joinWith(E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.fmap(t._0, toString), (function (r) {
                return "[" + r + "]";
            })), ", ") + "";
    }
}
var $$Error = {
    mapErrorArrayToError: mapErrorArrayToError,
    toString: toString
};
function interpolate(xMin, xMax, yMin, yMax, xIntended) {
    var minProportion = (xMax - xIntended) / (xMax - xMin);
    var maxProportion = (xIntended - xMin) / (xMax - xMin);
    return yMin * minProportion + yMax * maxProportion;
}
function extImp(__x) {
    return E_O$QuriSquiggleLang.toExt(__x, "Tried to perform an operation on an empty XYShape.");
}
function toXyShape(t) {
    return t;
}
function xs(t) {
    return t.xs;
}
function ys(t) {
    return t.ys;
}
function length(t) {
    return E_A$QuriSquiggleLang.length(t.xs);
}
var empty_xs = [];
var empty_ys = [];
var empty = {
    xs: empty_xs,
    ys: empty_ys
};
function isEmpty(t) {
    return E_A$QuriSquiggleLang.length(t.xs) === 0;
}
function minX(t) {
    return E_O$QuriSquiggleLang.toExt(Curry._1(E_A$QuriSquiggleLang.Floats.Sorted.min, t.xs), "Tried to perform an operation on an empty XYShape.");
}
function maxX(t) {
    return E_O$QuriSquiggleLang.toExt(Curry._1(E_A$QuriSquiggleLang.Floats.Sorted.max, t.xs), "Tried to perform an operation on an empty XYShape.");
}
function firstY(t) {
    return E_O$QuriSquiggleLang.toExt(E_A$QuriSquiggleLang.first(t.ys), "Tried to perform an operation on an empty XYShape.");
}
function lastY(t) {
    return E_O$QuriSquiggleLang.toExt(E_A$QuriSquiggleLang.last(t.ys), "Tried to perform an operation on an empty XYShape.");
}
function xTotalRange(t) {
    return maxX(t) - minX(t);
}
function mapX(t, fn) {
    return {
        xs: E_A$QuriSquiggleLang.fmap(t.xs, fn),
        ys: t.ys
    };
}
function mapY(t, fn) {
    return {
        xs: t.xs,
        ys: E_A$QuriSquiggleLang.fmap(t.ys, fn)
    };
}
function mapYResult(t, fn) {
    var mappedYs = E_A$QuriSquiggleLang.fmap(t.ys, fn);
    return E_R$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.R.firstErrorOrOpen(mappedYs), (function (y) {
        return {
            xs: t.xs,
            ys: y
        };
    }));
}
function square(__x) {
    return mapX(__x, (function (x) {
        return Math.pow(x, 2.0);
    }));
}
function zip(param) {
    return E_A$QuriSquiggleLang.zip(param.xs, param.ys);
}
function fromArray(param) {
    return {
        xs: param[0],
        ys: param[1]
    };
}
function fromArrays(xs, ys) {
    return {
        xs: xs,
        ys: ys
    };
}
function accumulateYs(p, fn) {
    return fromArray([
        p.xs,
        E_A$QuriSquiggleLang.accumulate(p.ys, fn)
    ]);
}
function concat(t1, t2) {
    var cxs = E_A$QuriSquiggleLang.concat(t1.xs, t2.xs);
    var cys = E_A$QuriSquiggleLang.concat(t1.ys, t2.ys);
    return {
        xs: cxs,
        ys: cys
    };
}
function fromZippedArray(pairs) {
    return fromArray(E_A$QuriSquiggleLang.unzip(pairs));
}
function equallyDividedXs(t, newLength) {
    return E_A$QuriSquiggleLang.Floats.range(minX(t), maxX(t), newLength);
}
function toJs(t) {
    return {
        xs: t.xs,
        ys: t.ys
    };
}
function filterYValues(t, fn) {
    var pairs = E_A$QuriSquiggleLang.filter(zip(t), (function (param) {
        return Curry._1(fn, param[1]);
    }));
    return fromArray(E_A$QuriSquiggleLang.unzip(pairs));
}
function filterOkYs(xs, ys) {
    var n = E_A$QuriSquiggleLang.length(xs);
    var newXs = [];
    var newYs = [];
    for (var i = 0; i < n; ++i) {
        var y = Caml_array.get(ys, i);
        if (y.TAG === 0) {
            Js_array.push(Caml_array.get(xs, i), newXs);
            Js_array.push(y._0, newYs);
        }
    }
    return {
        xs: newXs,
        ys: newYs
    };
}
function notSortedError(p) {
    return {
        TAG: 0,
        _0: p,
        [Symbol.for("name")]: "NotSorted"
    };
}
function notFiniteError(p, exampleValue) {
    return {
        TAG: 2,
        _0: p,
        _1: exampleValue,
        [Symbol.for("name")]: "NotFinite"
    };
}
function isEmptyError(propertyName) {
    return {
        TAG: 1,
        _0: propertyName,
        [Symbol.for("name")]: "IsEmpty"
    };
}
function differentLengthsError(t) {
    return {
        TAG: 3,
        p1Name: "Xs",
        p2Name: "Ys",
        p1Length: E_A$QuriSquiggleLang.length(t.xs),
        p2Length: E_A$QuriSquiggleLang.length(t.ys),
        [Symbol.for("name")]: "DifferentLengths"
    };
}
function areXsSorted(t) {
    return E_A$QuriSquiggleLang.Floats.isSorted(t.xs);
}
function areXsEmpty(t) {
    return E_A$QuriSquiggleLang.length(t.xs) === 0;
}
function getNonFiniteXs(t) {
    return E_A$QuriSquiggleLang.Floats.getNonFinite(t.xs);
}
function getNonFiniteYs(t) {
    return E_A$QuriSquiggleLang.Floats.getNonFinite(t.ys);
}
function validate(t) {
    var xsNotSorted = E_A$QuriSquiggleLang.Floats.isSorted(t.xs) ? undefined : ({
        TAG: 0,
        _0: "Xs",
        [Symbol.for("name")]: "NotSorted"
    });
    var xsEmpty = areXsEmpty(t) ? ({
        TAG: 1,
        _0: "Xs",
        [Symbol.for("name")]: "IsEmpty"
    }) : undefined;
    var differentLengths = E_A$QuriSquiggleLang.length(t.xs) !== E_A$QuriSquiggleLang.length(t.ys) ? differentLengthsError(t) : undefined;
    var xsNotFinite = E_O$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.Floats.getNonFinite(t.xs), (function (param) {
        return {
            TAG: 2,
            _0: "Xs",
            _1: param,
            [Symbol.for("name")]: "NotFinite"
        };
    }));
    var ysNotFinite = E_O$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.Floats.getNonFinite(t.ys), (function (param) {
        return {
            TAG: 2,
            _0: "Ys",
            _1: param,
            [Symbol.for("name")]: "NotFinite"
        };
    }));
    return mapErrorArrayToError(E_A$QuriSquiggleLang.O.concatSomes([
        xsNotSorted,
        xsEmpty,
        differentLengths,
        xsNotFinite,
        ysNotFinite
    ]));
}
var Validator = {
    fnName: "XYShape validate",
    notSortedError: notSortedError,
    notFiniteError: notFiniteError,
    isEmptyError: isEmptyError,
    differentLengthsError: differentLengthsError,
    areXsSorted: areXsSorted,
    areXsEmpty: areXsEmpty,
    getNonFiniteXs: getNonFiniteXs,
    getNonFiniteYs: getNonFiniteYs,
    validate: validate
};
function make(xs, ys) {
    var attempt = {
        xs: xs,
        ys: ys
    };
    var error = validate(attempt);
    if (error !== undefined) {
        return {
            TAG: 1,
            _0: error,
            [Symbol.for("name")]: "Error"
        };
    }
    else {
        return {
            TAG: 0,
            _0: attempt,
            [Symbol.for("name")]: "Ok"
        };
    }
}
function makeFromZipped(values) {
    var match = E_A$QuriSquiggleLang.unzip(values);
    return make(match[0], match[1]);
}
var T = {
    toXyShape: toXyShape,
    xs: xs,
    ys: ys,
    length: length,
    empty: empty,
    isEmpty: isEmpty,
    minX: minX,
    maxX: maxX,
    firstY: firstY,
    lastY: lastY,
    xTotalRange: xTotalRange,
    mapX: mapX,
    mapY: mapY,
    mapYResult: mapYResult,
    square: square,
    zip: zip,
    fromArray: fromArray,
    fromArrays: fromArrays,
    accumulateYs: accumulateYs,
    concat: concat,
    fromZippedArray: fromZippedArray,
    equallyDividedXs: equallyDividedXs,
    toJs: toJs,
    filterYValues: filterYValues,
    filterOkYs: filterOkYs,
    Validator: Validator,
    make: make,
    makeFromZipped: makeFromZipped
};
function minX$1(t) {
    return E_A$QuriSquiggleLang.Floats.min(E_A$QuriSquiggleLang.fmap(t, minX));
}
function maxX$1(t) {
    return E_A$QuriSquiggleLang.Floats.max(E_A$QuriSquiggleLang.fmap(t, maxX));
}
function equallyDividedXs$1(t, newLength) {
    return E_A$QuriSquiggleLang.Floats.range(minX$1(t), maxX$1(t), newLength);
}
function allXs(t) {
    return Curry._1(E_A$QuriSquiggleLang.Floats.Sorted.concatMany, E_A$QuriSquiggleLang.fmap(t, xs));
}
var Ts = {
    minX: minX$1,
    maxX: maxX$1,
    equallyDividedXs: equallyDividedXs$1,
    allXs: allXs
};
function x(prim) {
    return prim[0];
}
function y(prim) {
    return prim[1];
}
function first(t) {
    return [
        minX(t),
        firstY(t)
    ];
}
function last(t) {
    return [
        maxX(t),
        lastY(t)
    ];
}
function getBy(t, fn) {
    return E_A$QuriSquiggleLang.getBy(zip(t), fn);
}
function firstAtOrBeforeXValue(t, xValue) {
    var zipped = zip(t);
    var firstIndex = E_A$QuriSquiggleLang.getIndexBy(zipped, (function (param) {
        return param[0] > xValue;
    }));
    var previousIndex = firstIndex !== undefined ? (firstIndex !== 0 ? firstIndex - 1 | 0 : undefined) : E_A$QuriSquiggleLang.length(zipped) - 1 | 0;
    return Belt_Option.flatMap(previousIndex, (function (param) {
        return E_A$QuriSquiggleLang.get(zipped, param);
    }));
}
var Pairs = {
    x: x,
    y: y,
    first: first,
    last: last,
    getBy: getBy,
    firstAtOrBeforeXValue: firstAtOrBeforeXValue
};
function linear(t, y) {
    var firstHigherIndex = Curry._2(E_A$QuriSquiggleLang.Floats.Sorted.binarySearchFirstElementGreaterIndex, t.ys, y);
    if (typeof firstHigherIndex !== "object") {
        if (firstHigherIndex === "overMax") {
            return maxX(t);
        }
        else {
            return minX(t);
        }
    }
    var firstHigherIndex$1 = firstHigherIndex.VAL;
    var lowerOrEqualIndex = (firstHigherIndex$1 - 1 | 0) < 0 ? 0 : firstHigherIndex$1 - 1 | 0;
    var _xs = t.xs;
    var _ys = t.ys;
    var needsInterpolation = Caml_array.get(_ys, lowerOrEqualIndex) !== y;
    if (needsInterpolation) {
        return interpolate(Caml_array.get(_ys, lowerOrEqualIndex), Caml_array.get(_ys, firstHigherIndex$1), Caml_array.get(_xs, lowerOrEqualIndex), Caml_array.get(_xs, firstHigherIndex$1), y);
    }
    else {
        return Caml_array.get(_xs, lowerOrEqualIndex);
    }
}
var YtoX = {
    linear: linear
};
function stepwiseIncremental(t, f) {
    return E_O$QuriSquiggleLang.fmap(firstAtOrBeforeXValue(t, f), y);
}
function stepwiseIfAtX(t, f) {
    return E_O$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.getBy(zip(t), (function (param) {
        return param[0] === f;
    })), y);
}
function linear$1(t, x) {
    var firstHigherIndex = Curry._2(E_A$QuriSquiggleLang.Floats.Sorted.binarySearchFirstElementGreaterIndex, t.xs, x);
    if (typeof firstHigherIndex !== "object") {
        if (firstHigherIndex === "overMax") {
            return lastY(t);
        }
        else {
            return firstY(t);
        }
    }
    var firstHigherIndex$1 = firstHigherIndex.VAL;
    var lowerOrEqualIndex = (firstHigherIndex$1 - 1 | 0) < 0 ? 0 : firstHigherIndex$1 - 1 | 0;
    var _xs = t.xs;
    var _ys = t.ys;
    var needsInterpolation = Caml_array.get(_xs, lowerOrEqualIndex) !== x;
    if (needsInterpolation) {
        return interpolate(Caml_array.get(_xs, lowerOrEqualIndex), Caml_array.get(_xs, firstHigherIndex$1), Caml_array.get(_ys, lowerOrEqualIndex), Caml_array.get(_ys, firstHigherIndex$1), x);
    }
    else {
        return Caml_array.get(_ys, lowerOrEqualIndex);
    }
}
function continuousInterpolator(interpolation, extrapolation) {
    if (interpolation === "Linear") {
        if (extrapolation === "UseZero") {
            return function (t, leftIndex, x) {
                if (leftIndex < 0) {
                    return 0.0;
                }
                if (leftIndex >= (E_A$QuriSquiggleLang.length(t.xs) - 1 | 0)) {
                    return 0.0;
                }
                var x1 = Caml_array.get(t.xs, leftIndex);
                var x2 = Caml_array.get(t.xs, leftIndex + 1 | 0);
                var y1 = Caml_array.get(t.ys, leftIndex);
                var y2 = Caml_array.get(t.ys, leftIndex + 1 | 0);
                var fraction = (x - x1) / (x2 - x1);
                return y1 * (1 - fraction) + y2 * fraction;
            };
        }
        else {
            return function (t, leftIndex, x) {
                if (leftIndex < 0) {
                    return Caml_array.get(t.ys, 0);
                }
                if (leftIndex >= (E_A$QuriSquiggleLang.length(t.xs) - 1 | 0)) {
                    return Caml_array.get(t.ys, E_A$QuriSquiggleLang.length(t.xs) - 1 | 0);
                }
                var x1 = Caml_array.get(t.xs, leftIndex);
                var x2 = Caml_array.get(t.xs, leftIndex + 1 | 0);
                var y1 = Caml_array.get(t.ys, leftIndex);
                var y2 = Caml_array.get(t.ys, leftIndex + 1 | 0);
                var fraction = (x - x1) / (x2 - x1);
                return y1 * (1 - fraction) + y2 * fraction;
            };
        }
    }
    else if (extrapolation === "UseZero") {
        return function (t, leftIndex, _x) {
            if (leftIndex < 0) {
                return 0.0;
            }
            else if (leftIndex >= (E_A$QuriSquiggleLang.length(t.xs) - 1 | 0)) {
                return 0.0;
            }
            else {
                return Caml_array.get(t.ys, leftIndex);
            }
        };
    }
    else {
        return function (t, leftIndex, _x) {
            if (leftIndex < 0) {
                return Caml_array.get(t.ys, 0);
            }
            else if (leftIndex >= (E_A$QuriSquiggleLang.length(t.xs) - 1 | 0)) {
                return Caml_array.get(t.ys, E_A$QuriSquiggleLang.length(t.xs) - 1 | 0);
            }
            else {
                return Caml_array.get(t.ys, leftIndex);
            }
        };
    }
}
function discreteInterpolator(param, param$1, param$2) {
    return 0.0;
}
var XtoY = {
    stepwiseIncremental: stepwiseIncremental,
    stepwiseIfAtX: stepwiseIfAtX,
    linear: linear$1,
    continuousInterpolator: continuousInterpolator,
    discreteInterpolator: discreteInterpolator
};
function _replaceWithXs(newXs, t) {
    var newYs = E_A$QuriSquiggleLang.fmap(newXs, (function (param) {
        return linear$1(t, param);
    }));
    return {
        xs: newXs,
        ys: newYs
    };
}
function equallyDivideXByMass(integral, newLength) {
    return E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.Floats.range(0.0, 1.0, newLength), (function (param) {
        return linear(integral, param);
    }));
}
function proportionEquallyOverX(t, newLength) {
    return _replaceWithXs(equallyDividedXs(t, newLength), t);
}
function proportionByProbabilityMass(t, newLength, integral) {
    return _replaceWithXs(equallyDivideXByMass(integral, newLength), t);
}
var XsConversion = {
    _replaceWithXs: _replaceWithXs,
    equallyDivideXByMass: equallyDivideXByMass,
    proportionEquallyOverX: proportionEquallyOverX,
    proportionByProbabilityMass: proportionByProbabilityMass
};
function compareYs(param, param$1) {
    if (param[1] > param$1[1]) {
        return 1;
    }
    else {
        return 0;
    }
}
function compareXs(param, param$1) {
    if (param[0] > param$1[0]) {
        return 1;
    }
    else {
        return 0;
    }
}
function sortByY(t) {
    return E_A$QuriSquiggleLang.stableSortBy(t, compareYs);
}
function sortByX(t) {
    return E_A$QuriSquiggleLang.stableSortBy(t, compareXs);
}
function filterByX(t, testFn) {
    return E_A$QuriSquiggleLang.filter(t, (function (param) {
        return Curry._1(testFn, param[0]);
    }));
}
var Zipped = {
    compareYs: compareYs,
    compareXs: compareXs,
    sortByY: sortByY,
    sortByX: sortByX,
    filterByX: filterByX
};
var combine = (function (interpolator, fn, t1, t2) {
    let t1n = t1.xs.length;
    let t2n = t2.xs.length;
    let outX = [];
    let outY = [];
    let i = -1;
    let j = -1;
    while (i <= t1n - 1 && j <= t2n - 1) {
        let x, ya, yb;
        if (j == t2n - 1 && i < t1n - 1 ||
            t1.xs[i + 1] < t2.xs[j + 1]) {
            i++;
            x = t1.xs[i];
            ya = t1.ys[i];
            yb = interpolator(t2, j, x);
        }
        else if (i == t1n - 1 && j < t2n - 1 ||
            t1.xs[i + 1] > t2.xs[j + 1]) {
            j++;
            x = t2.xs[j];
            yb = t2.ys[j];
            ya = interpolator(t1, i, x);
        }
        else if (i < t1n - 1 && j < t2n && t1.xs[i + 1] === t2.xs[j + 1]) {
            i++;
            j++;
            x = t1.xs[i];
            ya = t1.ys[i];
            yb = t2.ys[j];
        }
        else if (i === t1n - 1 && j === t2n - 1) {
            i = t1n;
            j = t2n;
            continue;
        }
        else {
            console.log("PointwiseCombination Error", i, j);
        }
        outX.push(x);
        let newY = fn(ya, yb);
        if (newY.TAG === 0) {
            outY.push(newY._0);
        }
        else {
            return newY;
        }
    }
    return { TAG: 0, _0: { xs: outX, ys: outY }, [Symbol.for("name")]: "Ok" };
});
function combineAlongSupportOfSecondArgument0(interpolator, fn, t1, t2) {
    var newYs = [];
    var newXs = [];
    var l1 = E_A$QuriSquiggleLang.length(t1.xs);
    var l2 = E_A$QuriSquiggleLang.length(t2.xs);
    var i = 0;
    var j = 0;
    var minX = Caml_array.get(t2.xs, 0);
    var maxX = Caml_array.get(t2.xs, l2 - 1 | 0);
    while (j < (l2 - 1 | 0) && i < (l1 - 1 | 0)) {
        var x1 = Caml_array.get(t1.xs, i + 1 | 0);
        var x2 = Caml_array.get(t2.xs, j + 1 | 0);
        var someTuple;
        if (i < (l1 - 1 | 0) && j < l2 && x1 < x2 && minX <= x1 && x2 <= maxX) {
            i = i + 1 | 0;
            var y1 = Caml_array.get(t1.ys, i);
            var y2 = Curry._3(interpolator, t2, j, x1);
            someTuple = [
                x1,
                y1,
                y2
            ];
        }
        else if (i < l1 && j < (l2 - 1 | 0) && x1 > x2 && x2 >= minX && maxX >= x1) {
            j = j + 1 | 0;
            var y1$1 = Curry._3(interpolator, t1, i, x2);
            var y2$1 = Caml_array.get(t2.ys, j);
            someTuple = [
                x2,
                y1$1,
                y2$1
            ];
        }
        else {
            i = i + 1 | 0;
            if (i < (l1 - 1 | 0) && j < (l2 - 1 | 0) && x1 === x2 && x1 >= minX && maxX >= x2) {
                j = j + 1 | 0;
                var y1$2 = Caml_array.get(t1.ys, i);
                var y2$2 = Caml_array.get(t2.ys, j);
                someTuple = [
                    x1,
                    y1$2,
                    y2$2
                ];
            }
            else {
                someTuple = undefined;
            }
        }
        if (someTuple !== undefined) {
            Js_array.push(Curry._2(fn, someTuple[1], someTuple[2]), newYs);
            Js_array.push(someTuple[0], newXs);
        }
    }
    ;
    return {
        TAG: 0,
        _0: filterOkYs(newXs, newYs),
        [Symbol.for("name")]: "Ok"
    };
}
function enrichXyShape(t) {
    var length = E_A$QuriSquiggleLang.length(t.xs);
    var points = length < MagicNumbers$QuriSquiggleLang.Environment.defaultXYPointLength ? Caml_int32.div(Math.imul(10, MagicNumbers$QuriSquiggleLang.Environment.defaultXYPointLength), length) : 10;
    var newXsUnflattened = Js_array.mapi((function (x, i) {
        if (i < (length - 2 | 0)) {
            var x2 = Caml_array.get(t.xs, i + 1 | 0);
            if (Math.abs(x - x2) < 2.0 * MagicNumbers$QuriSquiggleLang.Epsilon.seven) {
                return [x];
            }
            var newPointsArray = E_A$QuriSquiggleLang.makeBy(points - 1 | 0, (function (i) {
                return i;
            }));
            return Js_array.mapi((function (pos, i) {
                if (i === 0) {
                    return x;
                }
                else {
                    return x * (points - pos) / points + x2 * pos / points;
                }
            }), newPointsArray);
        }
        else {
            return [x];
        }
    }), t.xs);
    var newXs = E_A$QuriSquiggleLang.concatMany(newXsUnflattened);
    var newYs = E_A$QuriSquiggleLang.fmap(newXs, (function (x) {
        return linear$1(t, x);
    }));
    return {
        xs: newXs,
        ys: newYs
    };
}
function addCombine(interpolator, t1, t2) {
    return E_R$QuriSquiggleLang.toExn(combine(interpolator, (function (a, b) {
        return {
            TAG: 0,
            _0: a + b,
            [Symbol.for("name")]: "Ok"
        };
    }), t1, t2), "Add operation should never fail");
}
function combineEvenXs(fn, xToYSelection, sampleCount, t1, t2) {
    var match = E_A$QuriSquiggleLang.length(t1.xs);
    var match$1 = E_A$QuriSquiggleLang.length(t2.xs);
    if (match === 0) {
        if (match$1 !== 0) {
            return t2;
        }
        else {
            return empty;
        }
    }
    if (match$1 === 0) {
        return t1;
    }
    var allXs = equallyDividedXs$1([
        t1,
        t2
    ], sampleCount);
    var allYs = E_A$QuriSquiggleLang.fmap(allXs, (function (x) {
        return Curry._2(fn, Curry._2(xToYSelection, x, t1), Curry._2(xToYSelection, x, t2));
    }));
    return {
        xs: allXs,
        ys: allYs
    };
}
function intersperse(t1, t2) {
    var pairs = E_A$QuriSquiggleLang.intersperse(zip(t1), zip(t2));
    return fromArray(E_A$QuriSquiggleLang.unzip(pairs));
}
var PointwiseCombination = {
    combine: combine,
    combineAlongSupportOfSecondArgument0: combineAlongSupportOfSecondArgument0,
    enrichXyShape: enrichXyShape,
    addCombine: addCombine,
    combineEvenXs: combineEvenXs,
    intersperse: intersperse
};
function nextX(param) {
    return param[1][0];
}
function rangePointAssumingSteps(param) {
    return [
        param[1][0],
        param[0][1]
    ];
}
function rangeAreaAssumingTriangles(param) {
    var match = param[1];
    var match$1 = param[0];
    return (match[0] - match$1[0]) * (match$1[1] + match[1]) / 2;
}
function rangeAreaAssumingTrapezoids(param) {
    var match = param[1];
    var nextY = match[1];
    var match$1 = param[0];
    var lastY = match$1[1];
    return (match[0] - match$1[0]) * (Math.min(lastY, nextY) + (lastY + nextY) / 2);
}
function delta_y_over_delta_x(param) {
    var match = param[1];
    var match$1 = param[0];
    return (match[1] - match$1[1]) / (match[0] - match$1[0]);
}
function mapYsBasedOnRanges(t, fn) {
    return E_O$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.toOption(E_A$QuriSquiggleLang.toRanges(E_A$QuriSquiggleLang.zip(t.xs, t.ys))), (function (r) {
        return E_A$QuriSquiggleLang.fmap(r, (function (r) {
            return [
                nextX(r),
                Curry._1(fn, r)
            ];
        }));
    }));
}
function integrateWithTriangles(param) {
    var ys = param.ys;
    var xs = param.xs;
    var length = E_A$QuriSquiggleLang.length(xs);
    var cumulativeY = Belt_Array.make(length, 0.0);
    for (var x = 0, x_finish = E_A$QuriSquiggleLang.length(xs) - 2 | 0; x <= x_finish; ++x) {
        Belt_Array.set(cumulativeY, x + 1 | 0, (Caml_array.get(xs, x + 1 | 0) - Caml_array.get(xs, x)) * ((Caml_array.get(ys, x) + Caml_array.get(ys, x + 1 | 0)) / 2) + Caml_array.get(cumulativeY, x));
    }
    return {
        xs: xs,
        ys: cumulativeY
    };
}
function derivative(__x) {
    return mapYsBasedOnRanges(__x, delta_y_over_delta_x);
}
function stepwiseToLinear(param) {
    var ys = param.ys;
    var xs = param.xs;
    var length = E_A$QuriSquiggleLang.length(xs);
    var newXs = new Array((length << 1));
    var newYs = new Array((length << 1));
    Belt_Array.set(newXs, 0, Caml_array.get(xs, 0) - Pervasives.epsilon_float);
    Belt_Array.set(newYs, 0, 0);
    Belt_Array.set(newXs, 1, Caml_array.get(xs, 0));
    Belt_Array.set(newYs, 1, Caml_array.get(ys, 0));
    for (var i = 1, i_finish = E_A$QuriSquiggleLang.length(xs); i < i_finish; ++i) {
        Belt_Array.set(newXs, (i << 1), Caml_array.get(xs, i) - Pervasives.epsilon_float);
        Belt_Array.set(newYs, (i << 1), Caml_array.get(ys, i - 1 | 0));
        Belt_Array.set(newXs, (i << 1) + 1 | 0, Caml_array.get(xs, i));
        Belt_Array.set(newYs, (i << 1) + 1 | 0, Caml_array.get(ys, i));
    }
    return {
        xs: newXs,
        ys: newYs
    };
}
function stepsToContinuous(t) {
    var r = xTotalRange(t);
    var diff = r * MagicNumbers$QuriSquiggleLang.Epsilon.five;
    var items = E_A$QuriSquiggleLang.toRanges(E_A$QuriSquiggleLang.zip(t.xs, t.ys));
    var items$1;
    if (items.TAG === 0) {
        var pairs = E_A$QuriSquiggleLang.fmap(items._0, rangePointAssumingSteps);
        var __x = fromArray(E_A$QuriSquiggleLang.unzip(pairs));
        items$1 = intersperse(mapX(t, (function (e) {
            return e + diff;
        })), __x);
    }
    else {
        items$1 = t;
    }
    var first = E_O$QuriSquiggleLang.bind(E_O$QuriSquiggleLang.fmap(items$1, zip), (function (__x) {
        return E_A$QuriSquiggleLang.get(__x, 0);
    }));
    if (items$1 === undefined) {
        return;
    }
    if (first === undefined) {
        return;
    }
    var firstX = first[0];
    if (firstX === 0.0) {
        return items$1;
    }
    var all = E_A$QuriSquiggleLang.concat([[
            firstX,
            0.0
        ]], zip(items$1));
    return E_O$QuriSquiggleLang.some(fromArray(E_A$QuriSquiggleLang.unzip(all)));
}
var $$Range = {
    toT: fromZippedArray,
    nextX: nextX,
    rangePointAssumingSteps: rangePointAssumingSteps,
    rangeAreaAssumingTriangles: rangeAreaAssumingTriangles,
    rangeAreaAssumingTrapezoids: rangeAreaAssumingTrapezoids,
    delta_y_over_delta_x: delta_y_over_delta_x,
    mapYsBasedOnRanges: mapYsBasedOnRanges,
    integrateWithTriangles: integrateWithTriangles,
    derivative: derivative,
    stepwiseToLinear: stepwiseToLinear,
    stepsToContinuous: stepsToContinuous
};
function getVarianceDangerously(t, mean, getMeanOfSquares) {
    var meanSquared = Math.pow(Curry._1(mean, t), 2.0);
    var meanOfSquares = Curry._1(getMeanOfSquares, t);
    return meanOfSquares - meanSquared;
}
var Analysis = {
    getVarianceDangerously: getVarianceDangerously
};
exports.$$Error = $$Error;
exports.interpolate = interpolate;
exports.extImp = extImp;
exports.T = T;
exports.Ts = Ts;
exports.Pairs = Pairs;
exports.YtoX = YtoX;
exports.XtoY = XtoY;
exports.XsConversion = XsConversion;
exports.Zipped = Zipped;
exports.PointwiseCombination = PointwiseCombination;
exports.$$Range = $$Range;
exports.Analysis = Analysis;
//# sourceMappingURL=XYShape.bs.js.map