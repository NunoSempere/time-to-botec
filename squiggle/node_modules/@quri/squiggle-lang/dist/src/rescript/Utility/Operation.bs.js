'use strict';
var E_O$QuriSquiggleLang = require("./E/E_O.bs.js");
function fromAlgebraicOperation(op) {
    if (typeof op === "object" || op === "Divide" || op === "Power" || op === "Logarithm") {
        return;
    }
    else if (op === "Multiply") {
        return "Multiply";
    }
    else if (op === "Add") {
        return "Add";
    }
    else {
        return "Subtract";
    }
}
function canDoAlgebraicOperation(op) {
    return E_O$QuriSquiggleLang.isSome(fromAlgebraicOperation(op));
}
function toFn(x) {
    if (x === "Multiply") {
        return function (prim0, prim1) {
            return prim0 * prim1;
        };
    }
    else if (x === "Add") {
        return function (prim0, prim1) {
            return prim0 + prim1;
        };
    }
    else {
        return function (prim0, prim1) {
            return prim0 - prim1;
        };
    }
}
var Convolution = {
    fromAlgebraicOperation: fromAlgebraicOperation,
    canDoAlgebraicOperation: canDoAlgebraicOperation,
    toFn: toFn
};
function toString(err) {
    if (typeof err !== "number") {
        return err._0;
    }
    switch (err) {
        case 0:
            return "Cannot divide by zero";
        case 1:
            return "Operation returned complex result";
        case 2:
            return "Operation returned positive infinity";
        case 3:
            return "Operation returned negative infinity";
        case 4:
            return "SampleMap needs a function that converts a number to a number";
        case 5:
            return "This Pdf is invalid";
        case 6:
            return "This pathway is not yet implemented";
    }
}
var $$Error = {
    toString: toString
};
function power(a, b) {
    if (a >= 0.0) {
        return {
            TAG: 0,
            _0: Math.pow(a, b),
            [Symbol.for("name")]: "Ok"
        };
    }
    else {
        return {
            TAG: 1,
            _0: 1,
            [Symbol.for("name")]: "Error"
        };
    }
}
function divide(a, b) {
    if (b !== 0.0) {
        return {
            TAG: 0,
            _0: a / b,
            [Symbol.for("name")]: "Ok"
        };
    }
    else {
        return {
            TAG: 1,
            _0: 0,
            [Symbol.for("name")]: "Error"
        };
    }
}
function logarithm(a, b) {
    if (b === 1) {
        return {
            TAG: 1,
            _0: 0,
            [Symbol.for("name")]: "Error"
        };
    }
    else if (b === 0) {
        return {
            TAG: 0,
            _0: 0,
            [Symbol.for("name")]: "Ok"
        };
    }
    else if (a > 0.0 && b > 0.0) {
        return {
            TAG: 0,
            _0: Math.log(a) / Math.log(b),
            [Symbol.for("name")]: "Ok"
        };
    }
    else if (a === 0.0) {
        return {
            TAG: 1,
            _0: 3,
            [Symbol.for("name")]: "Error"
        };
    }
    else {
        return {
            TAG: 1,
            _0: 1,
            [Symbol.for("name")]: "Error"
        };
    }
}
function toFn$1(x, a, b) {
    if (typeof x === "object") {
        if (a < x.VAL) {
            return {
                TAG: 0,
                _0: 0.0,
                [Symbol.for("name")]: "Ok"
            };
        }
        else {
            return logarithm(a, b);
        }
    }
    else if (x === "Logarithm") {
        return logarithm(a, b);
    }
    else if (x === "Power") {
        return power(a, b);
    }
    else if (x === "Divide") {
        return divide(a, b);
    }
    else if (x === "Multiply") {
        return {
            TAG: 0,
            _0: a * b,
            [Symbol.for("name")]: "Ok"
        };
    }
    else if (x === "Add") {
        return {
            TAG: 0,
            _0: a + b,
            [Symbol.for("name")]: "Ok"
        };
    }
    else {
        return {
            TAG: 0,
            _0: a - b,
            [Symbol.for("name")]: "Ok"
        };
    }
}
function toString$1(x) {
    if (typeof x === "object" || x === "Logarithm") {
        return "log";
    }
    else if (x === "Power") {
        return "**";
    }
    else if (x === "Divide") {
        return "/";
    }
    else if (x === "Multiply") {
        return "*";
    }
    else if (x === "Add") {
        return "+";
    }
    else {
        return "-";
    }
}
function format(a, b, c) {
    return b + (" " + (toString$1(a) + (" " + c)));
}
var Algebraic = {
    toFn: toFn$1,
    toString: toString$1,
    format: format
};
function toString$2(x) {
    if (x === "Multiply") {
        return "*";
    }
    else if (x === "Add") {
        return "+";
    }
    else {
        return "**";
    }
}
function format$1(a, b, c) {
    return b + (" " + (toString$2(a) + (" " + c)));
}
var Pointwise = {
    toString: toString$2,
    format: format$1
};
function format$2(operation, value) {
    if (typeof operation !== "object") {
        if (operation === "Mean") {
            return "mean($value)";
        }
        else {
            return "sample($value)";
        }
    }
    var variant = operation.NAME;
    if (variant === "Inv") {
        return "inv(x=" + operation.VAL + "," + value + ")";
    }
    else if (variant === "Pdf") {
        return "pdf(x=" + operation.VAL + "," + value + ")";
    }
    else {
        return "cdf(x=" + operation.VAL + "," + value + ")";
    }
}
var DistToFloat = {
    format: format$2
};
function toFn$2(x, a, b) {
    if (typeof x === "object") {
        if (a < x.VAL) {
            return {
                TAG: 0,
                _0: 0.0,
                [Symbol.for("name")]: "Ok"
            };
        }
        else {
            return logarithm(a, b);
        }
    }
    else if (x === "Power") {
        return power(a, b);
    }
    else if (x === "Divide") {
        return divide(a, b);
    }
    else if (x === "Multiply") {
        return {
            TAG: 0,
            _0: a * b,
            [Symbol.for("name")]: "Ok"
        };
    }
    else {
        return logarithm(a, b);
    }
}
function format$3(operation, value, scaleBy) {
    if (typeof operation === "object") {
        return "verticalLog(" + value + ", " + scaleBy + ", epsilon=" + operation.VAL + ") ";
    }
    else if (operation === "Power") {
        return "verticalPower(" + value + ", " + scaleBy + ") ";
    }
    else if (operation === "Divide") {
        return "verticalDivide(" + value + ", " + scaleBy + ") ";
    }
    else if (operation === "Multiply") {
        return "verticalMultiply(" + value + ", " + scaleBy + ") ";
    }
    else {
        return "verticalLog(" + value + ", " + scaleBy + ") ";
    }
}
function toIntegralSumCacheFn(x) {
    if (typeof x !== "object") {
        if (x === "Divide") {
            return function (a, b) {
                return a / b;
            };
        }
        if (x === "Multiply") {
            return function (a, b) {
                return a * b;
            };
        }
    }
    return function (param, param$1) {
    };
}
function toIntegralCacheFn(x) {
    if (typeof x === "object") {
        return function (param, param$1) {
        };
    }
    else if (x === "Power") {
        return function (param, param$1) {
        };
    }
    else if (x === "Divide") {
        return function (param, param$1) {
        };
    }
    else if (x === "Multiply") {
        return function (param, param$1) {
        };
    }
    else {
        return function (param, param$1) {
        };
    }
}
var Scale = {
    toFn: toFn$2,
    format: format$3,
    toIntegralSumCacheFn: toIntegralSumCacheFn,
    toIntegralCacheFn: toIntegralCacheFn
};
function toString$3(left, right, nodeToString) {
    var left$1 = E_O$QuriSquiggleLang.dimap(left, (function (prim) {
        return prim.toString();
    }), (function (param) {
        return "-inf";
    }));
    var right$1 = E_O$QuriSquiggleLang.dimap(right, (function (prim) {
        return prim.toString();
    }), (function (param) {
        return "inf";
    }));
    return "truncate(" + nodeToString + ", " + left$1 + ", " + right$1 + ")";
}
var Truncate = {
    toString: toString$3
};
exports.Convolution = Convolution;
exports.$$Error = $$Error;
exports.power = power;
exports.divide = divide;
exports.logarithm = logarithm;
exports.Algebraic = Algebraic;
exports.Pointwise = Pointwise;
exports.DistToFloat = DistToFloat;
exports.Scale = Scale;
exports.Truncate = Truncate;
//# sourceMappingURL=Operation.bs.js.map