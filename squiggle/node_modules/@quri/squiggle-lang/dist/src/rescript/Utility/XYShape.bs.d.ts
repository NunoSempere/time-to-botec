export namespace $$Error {
    export { mapErrorArrayToError };
    export { toString };
}
export function interpolate(xMin: any, xMax: any, yMin: any, yMax: any, xIntended: any): number;
export function extImp(__x: any): any;
export namespace T {
    export { toXyShape };
    export { xs };
    export { ys };
    export { length };
    export { empty };
    export { isEmpty };
    export { minX };
    export { maxX };
    export { firstY };
    export { lastY };
    export { xTotalRange };
    export { mapX };
    export { mapY };
    export { mapYResult };
    export { square };
    export { zip };
    export { fromArray };
    export { fromArrays };
    export { accumulateYs };
    export { concat };
    export { fromZippedArray };
    export { equallyDividedXs };
    export { toJs };
    export { filterYValues };
    export { filterOkYs };
    export { Validator };
    export { make };
    export { makeFromZipped };
}
export namespace Ts {
    export { minX$1 as minX };
    export { maxX$1 as maxX };
    export { equallyDividedXs$1 as equallyDividedXs };
    export { allXs };
}
export namespace Pairs {
    export { x };
    export { y };
    export { first };
    export { last };
    export { getBy };
    export { firstAtOrBeforeXValue };
}
export namespace YtoX {
    export { linear };
}
export namespace XtoY {
    export { stepwiseIncremental };
    export { stepwiseIfAtX };
    export { linear$1 as linear };
    export { continuousInterpolator };
    export { discreteInterpolator };
}
export namespace XsConversion {
    export { _replaceWithXs };
    export { equallyDivideXByMass };
    export { proportionEquallyOverX };
    export { proportionByProbabilityMass };
}
export namespace Zipped {
    export { compareYs };
    export { compareXs };
    export { sortByY };
    export { sortByX };
    export { filterByX };
}
export namespace PointwiseCombination {
    export { combine };
    export { combineAlongSupportOfSecondArgument0 };
    export { enrichXyShape };
    export { addCombine };
    export { combineEvenXs };
    export { intersperse };
}
export namespace $$Range {
    export { fromZippedArray as toT };
    export { nextX };
    export { rangePointAssumingSteps };
    export { rangeAreaAssumingTriangles };
    export { rangeAreaAssumingTrapezoids };
    export { delta_y_over_delta_x };
    export { mapYsBasedOnRanges };
    export { integrateWithTriangles };
    export { derivative };
    export { stepwiseToLinear };
    export { stepsToContinuous };
}
export namespace Analysis {
    export { getVarianceDangerously };
}
declare function mapErrorArrayToError(errors: any): any;
declare function toString(t: any): string | undefined;
declare function toXyShape(t: any): any;
declare function xs(t: any): any;
declare function ys(t: any): any;
declare function length(t: any): any;
declare namespace empty {
    export { empty_xs as xs };
    export { empty_ys as ys };
}
declare function isEmpty(t: any): boolean;
declare function minX(t: any): any;
declare function maxX(t: any): any;
declare function firstY(t: any): any;
declare function lastY(t: any): any;
declare function xTotalRange(t: any): number;
declare function mapX(t: any, fn: any): {
    xs: any;
    ys: any;
};
declare function mapY(t: any, fn: any): {
    xs: any;
    ys: any;
};
declare function mapYResult(t: any, fn: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function square(__x: any): {
    xs: any;
    ys: any;
};
declare function zip(param: any): any;
declare function fromArray(param: any): {
    xs: any;
    ys: any;
};
declare function fromArrays(xs: any, ys: any): {
    xs: any;
    ys: any;
};
declare function accumulateYs(p: any, fn: any): {
    xs: any;
    ys: any;
};
declare function concat(t1: any, t2: any): {
    xs: any;
    ys: any;
};
declare function fromZippedArray(pairs: any): {
    xs: any;
    ys: any;
};
declare function equallyDividedXs(t: any, newLength: any): any;
declare function toJs(t: any): {
    xs: any;
    ys: any;
};
declare function filterYValues(t: any, fn: any): {
    xs: any;
    ys: any;
};
declare function filterOkYs(xs: any, ys: any): {
    xs: any[];
    ys: any[];
};
declare namespace Validator {
    export const fnName: string;
    export { notSortedError };
    export { notFiniteError };
    export { isEmptyError };
    export { differentLengthsError };
    export { areXsSorted };
    export { areXsEmpty };
    export { getNonFiniteXs };
    export { getNonFiniteYs };
    export { validate };
}
declare function make(xs: any, ys: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function makeFromZipped(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function minX$1(t: any): any;
declare function maxX$1(t: any): any;
declare function equallyDividedXs$1(t: any, newLength: any): any;
declare function allXs(t: any): any;
declare function x(prim: any): any;
declare function y(prim: any): any;
declare function first(t: any): any[];
declare function last(t: any): any[];
declare function getBy(t: any, fn: any): any;
declare function firstAtOrBeforeXValue(t: any, xValue: any): any;
declare function linear(t: any, y: any): any;
declare function stepwiseIncremental(t: any, f: any): any;
declare function stepwiseIfAtX(t: any, f: any): any;
declare function linear$1(t: any, x: any): any;
declare function continuousInterpolator(interpolation: any, extrapolation: any): (t: any, leftIndex: any, x: any) => any;
declare function discreteInterpolator(param: any, param$1: any, param$2: any): number;
declare function _replaceWithXs(newXs: any, t: any): {
    xs: any;
    ys: any;
};
declare function equallyDivideXByMass(integral: any, newLength: any): any;
declare function proportionEquallyOverX(t: any, newLength: any): {
    xs: any;
    ys: any;
};
declare function proportionByProbabilityMass(t: any, newLength: any, integral: any): {
    xs: any;
    ys: any;
};
declare function compareYs(param: any, param$1: any): 0 | 1;
declare function compareXs(param: any, param$1: any): 0 | 1;
declare function sortByY(t: any): any;
declare function sortByX(t: any): any;
declare function filterByX(t: any, testFn: any): any;
declare function combine(interpolator: any, fn: any, t1: any, t2: any): any;
declare function combineAlongSupportOfSecondArgument0(interpolator: any, fn: any, t1: any, t2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: {
        xs: any[];
        ys: any[];
    };
};
declare function enrichXyShape(t: any): {
    xs: any;
    ys: any;
};
declare function addCombine(interpolator: any, t1: any, t2: any): any;
declare function combineEvenXs(fn: any, xToYSelection: any, sampleCount: any, t1: any, t2: any): any;
declare function intersperse(t1: any, t2: any): {
    xs: any;
    ys: any;
};
declare function nextX(param: any): any;
declare function rangePointAssumingSteps(param: any): any[];
declare function rangeAreaAssumingTriangles(param: any): number;
declare function rangeAreaAssumingTrapezoids(param: any): number;
declare function delta_y_over_delta_x(param: any): number;
declare function mapYsBasedOnRanges(t: any, fn: any): any;
declare function integrateWithTriangles(param: any): {
    xs: any;
    ys: any;
};
declare function derivative(__x: any): any;
declare function stepwiseToLinear(param: any): {
    xs: any[];
    ys: any[];
};
declare function stepsToContinuous(t: any): any;
declare function getVarianceDangerously(t: any, mean: any, getMeanOfSquares: any): number;
declare var empty_xs: any[];
declare var empty_ys: any[];
declare function notSortedError(p: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function notFiniteError(p: any, exampleValue: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
    _1: any;
};
declare function isEmptyError(propertyName: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function differentLengthsError(t: any): {
    [x: symbol]: string;
    TAG: number;
    p1Name: string;
    p2Name: string;
    p1Length: any;
    p2Length: any;
};
declare function areXsSorted(t: any): any;
declare function areXsEmpty(t: any): boolean;
declare function getNonFiniteXs(t: any): any;
declare function getNonFiniteYs(t: any): any;
declare function validate(t: any): any;
export {};
