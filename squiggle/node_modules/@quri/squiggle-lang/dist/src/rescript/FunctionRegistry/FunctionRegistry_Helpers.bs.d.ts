export var impossibleErrorString: string;
export var impossibleError: {
    [x: symbol]: string;
    TAG: number;
    _0: string;
};
export function wrapError(e: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
export namespace Wrappers {
    export { symbolic };
    export { pointSet };
    export { sampleSet };
    export { evDistribution };
    export { evNumber };
    export { evArray };
    export { evRecord };
    export { evString };
    export { symbolicEvDistribution };
    export { evArrayOfEvNumber };
}
export function getOrError(a: any, g: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
export namespace Prepare {
    export { ToValueArray };
    export { ToValueTuple };
    export { oneNumber };
    export { oneDict };
    export { ToTypedArray };
}
export namespace Process {
    export { DistOrNumberToDist };
}
export namespace DefineFn {
    export { Numbers };
}
export namespace Make {
    export { f2f };
    export { ff2f };
    export { ff2b };
    export { bb2b };
}
declare function symbolic(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointSet(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function sampleSet(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function evDistribution(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function evNumber(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function evArray(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function evRecord(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function evString(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function symbolicEvDistribution(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: {
        [x: symbol]: string;
        TAG: number;
        _0: any;
    };
};
declare function evArrayOfEvNumber(xs: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare namespace ToValueArray {
    export { Record };
    export { $$Array };
}
declare namespace ToValueTuple {
    export { twoDistOrNumber };
    export { twoDist };
    export { twoNumbers };
    export { threeNumbers };
    export { oneDistOrNumber };
    export { Record$1 as Record };
}
declare function oneNumber(value: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function oneDict(value: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare namespace ToTypedArray {
    export { numbers };
    export { dicts };
}
declare namespace DistOrNumberToDist {
    export { Helpers };
    export { oneValue };
    export { oneValueUsingSymbolicDist };
    export { twoValues };
    export { twoValuesUsingSymbolicDist };
}
declare namespace Numbers {
    export { oneToOne };
    export { twoToOne };
    export { threeToOne };
}
declare function f2f(name: any, fn: any, nameSpaceOpt: any, requiresNamespaceOpt: any, examples: any, param: any): {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare function ff2f(name: any, fn: any, nameSpaceOpt: any, requiresNamespaceOpt: any, examples: any, param: any): {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare function ff2b(name: any, fn: any, nameSpaceOpt: any, requiresNamespaceOpt: any, examples: any, param: any): {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare function bb2b(name: any, fn: any, nameSpaceOpt: any, requiresNamespaceOpt: any, examples: any, param: any): {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare namespace Record {
    export { twoArgs };
    export { threeArgs };
}
declare namespace $$Array {
    export { openA };
    export { arrayOfArrays };
}
declare function twoDistOrNumber(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: {
        [x: symbol]: string;
        TAG: number;
        _0: any;
    }[];
};
declare function twoDist(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: any[];
};
declare function twoNumbers(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: any[];
};
declare function threeNumbers(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: any[];
};
declare function oneDistOrNumber(values: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: {
        [x: symbol]: string;
        TAG: number;
        _0: any;
    };
};
declare namespace Record$1 {
    export { twoDistOrNumber$1 as twoDistOrNumber };
    export { twoDist$1 as twoDist };
}
declare function numbers(inputs: any): any;
declare function dicts(inputs: any): any;
declare namespace Helpers {
    export { toSampleSet };
    export { mapFnResult };
    export { wrapSymbolic };
    export { singleVarSample };
    export { twoVarSample };
}
declare function oneValue(fn: any, value: any, env: any): any;
declare function oneValueUsingSymbolicDist(fn: any, value: any): (param: any) => any;
declare function twoValues(fn: any, values: any, env: any): any;
declare function twoValuesUsingSymbolicDist(fn: any, values: any): (param: any) => any;
declare function oneToOne(name: any, fn: any): {
    name: any;
    inputs: any;
    run: any;
};
declare function twoToOne(name: any, fn: any): {
    name: any;
    inputs: any;
    run: any;
};
declare function threeToOne(name: any, fn: any): {
    name: any;
    inputs: any;
    run: any;
};
declare function twoArgs(inputs: any, param: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: any[];
};
declare function threeArgs(inputs: any, param: any): {
    [x: symbol]: string;
    TAG: number;
    _0: string;
} | {
    [x: symbol]: string;
    TAG: number;
    _0: any[];
};
declare function openA(inputs: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function arrayOfArrays(inputs: any): any;
declare function twoDistOrNumber$1(values: any, labels: any): any;
declare function twoDist$1(values: any, labels: any): any;
declare function toSampleSet(r: any, env: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function mapFnResult(r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function wrapSymbolic(fn: any, r: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function singleVarSample(dist: any, fn: any, env: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function twoVarSample(dist1: any, dist2: any, fn: any, env: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
export {};
