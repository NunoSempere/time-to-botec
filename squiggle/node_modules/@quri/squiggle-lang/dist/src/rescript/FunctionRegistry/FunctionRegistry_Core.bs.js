'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var E_A$QuriSquiggleLang = require("../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../Utility/E/E_O.bs.js");
function toString(t) {
    if (typeof t === "number") {
        switch (t) {
            case 0:
                return "number";
            case 1:
                return "bool";
            case 2:
                return "numeric";
            case 3:
                return "date";
            case 4:
                return "duration";
            case 5:
                return "distribution|number";
            case 6:
                return "distribution";
            case 7:
                return "lambda";
            case 8:
                return "string";
            case 9:
                return "any";
        }
    }
    else {
        switch (t.TAG | 0) {
            case 0:
                var input = function (param) {
                    return "" + param[0] + ": " + toString(param[1]) + "";
                };
                return "{" + E_A$QuriSquiggleLang.joinWith(E_A$QuriSquiggleLang.fmap(t._0, input), ", ") + "}";
            case 1:
                return "dict(" + toString(t._0) + ")";
            case 2:
                return "list(" + toString(t._0) + ")";
            case 3:
                return "variant";
        }
    }
}
function matchWithValue(t, r) {
    if (typeof t === "number") {
        switch (t) {
            case 0:
                if (typeof r === "number" || r.TAG !== 6) {
                    return false;
                }
                else {
                    return true;
                }
            case 1:
                if (typeof r === "number" || r.TAG !== 1) {
                    return false;
                }
                else {
                    return true;
                }
            case 2:
                if (typeof r === "number") {
                    return false;
                }
                switch (r.TAG | 0) {
                    case 4:
                        var match = r._0;
                        switch (match.TAG | 0) {
                            case 0:
                            case 1:
                                return false;
                            case 2:
                                var match$1 = match._0;
                                if (typeof match$1 === "object") {
                                    return match$1.NAME === "Float";
                                }
                                else {
                                    return false;
                                }
                        }
                    case 6:
                        return true;
                    default:
                        return false;
                }
            case 3:
                if (typeof r === "number" || r.TAG !== 2) {
                    return false;
                }
                else {
                    return true;
                }
            case 4:
                if (typeof r === "number" || r.TAG !== 9) {
                    return false;
                }
                else {
                    return true;
                }
            case 5:
                if (typeof r === "number") {
                    return false;
                }
                switch (r.TAG | 0) {
                    case 4:
                    case 6:
                        return true;
                    default:
                        return false;
                }
            case 6:
                if (typeof r === "number" || r.TAG !== 4) {
                    return false;
                }
                else {
                    return true;
                }
            case 7:
                if (typeof r === "number" || r.TAG !== 5) {
                    return false;
                }
                else {
                    return true;
                }
            case 8:
                if (typeof r === "number" || r.TAG !== 8) {
                    return false;
                }
                else {
                    return true;
                }
            case 9:
                return true;
        }
    }
    else {
        switch (t.TAG | 0) {
            case 0:
                if (typeof r === "number") {
                    return false;
                }
                if (r.TAG !== 7) {
                    return false;
                }
                var map = r._0;
                return E_A$QuriSquiggleLang.every(t._0, (function (param) {
                    var v = Belt_MapString.get(map, param[0]);
                    if (v !== undefined) {
                        return matchWithValue(param[1], v);
                    }
                    else {
                        return false;
                    }
                }));
            case 1:
                if (typeof r === "number") {
                    return false;
                }
                if (r.TAG !== 7) {
                    return false;
                }
                var r$1 = t._0;
                return E_A$QuriSquiggleLang.every(Belt_MapString.valuesToArray(r._0), (function (v) {
                    return matchWithValue(r$1, v);
                }));
            case 2:
                if (typeof r === "number") {
                    return false;
                }
                if (r.TAG !== 0) {
                    return false;
                }
                var intendedType = t._0;
                return E_A$QuriSquiggleLang.every(r._0, (function (v) {
                    return matchWithValue(intendedType, v);
                }));
            case 3:
                return false;
        }
    }
}
function matchWithValueArray(inputs, args) {
    var isSameLength = E_A$QuriSquiggleLang.length(inputs) === E_A$QuriSquiggleLang.length(args);
    if (isSameLength) {
        return E_A$QuriSquiggleLang.every(E_A$QuriSquiggleLang.zip(inputs, args), (function (param) {
            return matchWithValue(param[0], param[1]);
        }));
    }
    else {
        return false;
    }
}
var FRType = {
    toString: toString,
    matchWithValue: matchWithValue,
    matchWithValueArray: matchWithValueArray
};
function toString$1(t) {
    var inputs = E_A$QuriSquiggleLang.joinWith(E_A$QuriSquiggleLang.fmap(t.inputs, toString), ", ");
    return t.name + ("(" + inputs + ")");
}
function isMatch(t, args) {
    return matchWithValueArray(t.inputs, args);
}
function run(t, args, context, reducer) {
    if (matchWithValueArray(t.inputs, args)) {
        return Curry._3(t.run, args, context, reducer);
    }
    else {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Incorrect Types",
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
}
function make(name, inputs, run, param) {
    return {
        name: name,
        inputs: inputs,
        run: run
    };
}
var FnDefinition = {
    toString: toString$1,
    isMatch: isMatch,
    run: run,
    make: make
};
function make$1(name, nameSpace, requiresNamespace, definitions, examples, output, description, isExperimentalOpt, param) {
    var isExperimental = isExperimentalOpt !== undefined ? isExperimentalOpt : false;
    return {
        name: name,
        definitions: definitions,
        requiresNamespace: requiresNamespace,
        nameSpace: nameSpace,
        output: output,
        examples: E_O$QuriSquiggleLang.$$default(examples, []),
        description: description,
        isExperimental: isExperimental
    };
}
function toJson(t) {
    return {
        name: t.name,
        definitions: E_A$QuriSquiggleLang.fmap(t.definitions, toString$1),
        examples: t.examples,
        description: t.description,
        isExperimental: t.isExperimental
    };
}
var $$Function = {
    make: make$1,
    toJson: toJson
};
function toJson$1(r) {
    return E_A$QuriSquiggleLang.fmap(r.functions, toJson);
}
function allExamples(r) {
    return E_A$QuriSquiggleLang.concatMany(E_A$QuriSquiggleLang.fmap(r.functions, (function (r) {
        return r.examples;
    })));
}
function allExamplesWithFns(r) {
    return E_A$QuriSquiggleLang.concatMany(E_A$QuriSquiggleLang.fmap(r.functions, (function (fn) {
        return E_A$QuriSquiggleLang.fmap(fn.examples, (function (example) {
            return [
                fn,
                example
            ];
        }));
    })));
}
function allNames(r) {
    return Belt_MapString.keysToArray(r.fnNameDict);
}
function _buildFnNameDict(r) {
    return E_A$QuriSquiggleLang.reduce(r, undefined, (function (acc, fn) {
        return E_A$QuriSquiggleLang.reduce(fn.definitions, acc, (function (acc, def) {
            var names = E_A$QuriSquiggleLang.concatMany([
                fn.nameSpace === "" ? [] : ["" + fn.nameSpace + "." + def.name + ""],
                fn.requiresNamespace ? [] : [def.name]
            ]);
            return E_A$QuriSquiggleLang.reduce(names, acc, (function (acc, name) {
                var fns = Belt_MapString.get(acc, name);
                if (fns !== undefined) {
                    fns.push(def);
                    return acc;
                }
                else {
                    return Belt_MapString.set(acc, name, [def]);
                }
            }));
        }));
    }));
}
function make$2(fns) {
    var dict = _buildFnNameDict(fns);
    return {
        functions: fns,
        fnNameDict: dict
    };
}
function call(registry, fnName, args, context, reducer) {
    var definitions = Belt_MapString.get(registry.fnNameDict, fnName);
    if (definitions === undefined) {
        return {
            TAG: 1,
            _0: {
                TAG: 11,
                _0: fnName,
                [Symbol.for("name")]: "RESymbolNotFound"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    var showNameMatchDefinitions = function (param) {
        var defsString = E_A$QuriSquiggleLang.joinWith(E_A$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.fmap(definitions, toString$1), (function (r) {
            return "[" + r + "]";
        })), "; ");
        return "There are function matches for " + fnName + "(), but with different arguments: " + defsString + "";
    };
    var match = definitions.find(function (def) {
        return matchWithValueArray(def.inputs, args);
    });
    if (match !== undefined) {
        return run(match, args, context, reducer);
    }
    else {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: showNameMatchDefinitions(undefined),
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
}
var Registry = {
    toJson: toJson$1,
    allExamples: allExamples,
    allExamplesWithFns: allExamplesWithFns,
    allNames: allNames,
    _buildFnNameDict: _buildFnNameDict,
    make: make$2,
    call: call
};
exports.FRType = FRType;
exports.FnDefinition = FnDefinition;
exports.$$Function = $$Function;
exports.Registry = Registry;
//# sourceMappingURL=FunctionRegistry_Core.bs.js.map