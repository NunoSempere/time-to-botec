'use strict';
var Caml = require("@rescript/std/lib/js/caml.js");
var Curry = require("@rescript/std/lib/js/curry.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var Discrete$QuriSquiggleLang = require("./Discrete.bs.js");
var Continuous$QuriSquiggleLang = require("./Continuous.bs.js");
var Distributions$QuriSquiggleLang = require("./Distributions.bs.js");
var PointSetTypes$QuriSquiggleLang = require("./PointSetTypes.bs.js");
function make(integralSumCacheOpt, integralCacheOpt, continuous, discrete) {
    var integralSumCache = integralSumCacheOpt !== undefined ? Caml_option.valFromOption(integralSumCacheOpt) : undefined;
    var integralCache = integralCacheOpt !== undefined ? Caml_option.valFromOption(integralCacheOpt) : undefined;
    return {
        continuous: continuous,
        discrete: discrete,
        integralSumCache: integralSumCache,
        integralCache: integralCache
    };
}
function totalLength(t) {
    var continuousLength = XYShape$QuriSquiggleLang.T.length(Continuous$QuriSquiggleLang.getShape(t.continuous));
    var discreteLength = XYShape$QuriSquiggleLang.T.length(Discrete$QuriSquiggleLang.getShape(t.discrete));
    return continuousLength + discreteLength | 0;
}
function scaleBy(t, scale) {
    var scaledDiscrete = Discrete$QuriSquiggleLang.scaleBy(t.discrete, scale);
    var scaledContinuous = Continuous$QuriSquiggleLang.scaleBy(t.continuous, scale);
    var scaledIntegralCache = E_O$QuriSquiggleLang.bind(t.integralCache, (function (v) {
        return Continuous$QuriSquiggleLang.scaleBy(v, scale);
    }));
    var scaledIntegralSumCache = E_O$QuriSquiggleLang.bind(t.integralSumCache, (function (s) {
        return s * scale;
    }));
    return make(Caml_option.some(scaledIntegralSumCache), Caml_option.some(scaledIntegralCache), scaledContinuous, scaledDiscrete);
}
function toContinuous(param) {
    return param.continuous;
}
function toDiscrete(param) {
    return param.discrete;
}
function updateIntegralCache(t, integralCache) {
    return {
        continuous: t.continuous,
        discrete: t.discrete,
        integralSumCache: t.integralSumCache,
        integralCache: integralCache
    };
}
function minX(param) {
    return Caml.float_min(Curry._1(Continuous$QuriSquiggleLang.T.minX, param.continuous), Curry._1(Discrete$QuriSquiggleLang.T.minX, param.discrete));
}
function maxX(param) {
    return Caml.float_max(Curry._1(Continuous$QuriSquiggleLang.T.maxX, param.continuous), Curry._1(Discrete$QuriSquiggleLang.T.maxX, param.discrete));
}
function toPointSetDist(t) {
    return {
        TAG: 0,
        _0: t,
        [Symbol.for("name")]: "Mixed"
    };
}
function truncate(leftCutoff, rightCutoff, param) {
    var truncatedContinuous = Curry._3(Continuous$QuriSquiggleLang.T.truncate, leftCutoff, rightCutoff, param.continuous);
    var truncatedDiscrete = Curry._3(Discrete$QuriSquiggleLang.T.truncate, leftCutoff, rightCutoff, param.discrete);
    return make(Caml_option.some(undefined), Caml_option.some(undefined), truncatedContinuous, truncatedDiscrete);
}
function normalize(t) {
    var continuousIntegral = Curry._1(Continuous$QuriSquiggleLang.T.Integral.get, t.continuous);
    var discreteIntegral = Curry._1(Discrete$QuriSquiggleLang.T.Integral.get, t.discrete);
    var continuous = Continuous$QuriSquiggleLang.updateIntegralCache(t.continuous, continuousIntegral);
    var discrete = Discrete$QuriSquiggleLang.updateIntegralCache(t.discrete, discreteIntegral);
    var continuousIntegralSum = Curry._1(Continuous$QuriSquiggleLang.T.Integral.sum, continuous);
    var discreteIntegralSum = Curry._1(Discrete$QuriSquiggleLang.T.Integral.sum, discrete);
    var totalIntegralSum = continuousIntegralSum + discreteIntegralSum;
    var newContinuousSum = continuousIntegralSum / totalIntegralSum;
    var newDiscreteSum = discreteIntegralSum / totalIntegralSum;
    var normalizedContinuous = Continuous$QuriSquiggleLang.updateIntegralSumCache(Continuous$QuriSquiggleLang.scaleBy(continuous, newContinuousSum / continuousIntegralSum), newContinuousSum);
    var normalizedDiscrete = Discrete$QuriSquiggleLang.updateIntegralSumCache(Discrete$QuriSquiggleLang.scaleBy(discrete, newDiscreteSum / discreteIntegralSum), newDiscreteSum);
    return make(1.0, Caml_option.some(undefined), normalizedContinuous, normalizedDiscrete);
}
function xToY(x, t) {
    var match = normalize(t);
    var c = Curry._2(Continuous$QuriSquiggleLang.T.xToY, x, match.continuous);
    var d = Curry._2(Discrete$QuriSquiggleLang.T.xToY, x, match.discrete);
    return PointSetTypes$QuriSquiggleLang.MixedPoint.add(c, d);
}
function toDiscreteProbabilityMassFraction(param) {
    var discreteIntegralSum = Curry._1(Discrete$QuriSquiggleLang.T.Integral.sum, param.discrete);
    var continuousIntegralSum = Curry._1(Continuous$QuriSquiggleLang.T.Integral.sum, param.continuous);
    var totalIntegralSum = discreteIntegralSum + continuousIntegralSum;
    return discreteIntegralSum / totalIntegralSum;
}
function downsample(count, t) {
    var discreteIntegralSum = Curry._1(Discrete$QuriSquiggleLang.T.Integral.sum, t.discrete);
    var continuousIntegralSum = Curry._1(Continuous$QuriSquiggleLang.T.Integral.sum, t.continuous);
    var totalIntegralSum = discreteIntegralSum + continuousIntegralSum;
    var downsampledDiscrete = Curry._2(Discrete$QuriSquiggleLang.T.downsample, count * (discreteIntegralSum / totalIntegralSum) | 0, t.discrete);
    var downsampledContinuous = Curry._2(Continuous$QuriSquiggleLang.T.downsample, count * (continuousIntegralSum / totalIntegralSum) | 0, t.continuous);
    return {
        continuous: downsampledContinuous,
        discrete: downsampledDiscrete,
        integralSumCache: t.integralSumCache,
        integralCache: t.integralCache
    };
}
function integral(t) {
    var cache = t.integralCache;
    if (cache !== undefined) {
        return cache;
    }
    var continuousIntegral = Curry._1(Continuous$QuriSquiggleLang.T.Integral.get, t.continuous);
    var discreteIntegral = Continuous$QuriSquiggleLang.stepwiseToLinear(Curry._1(Discrete$QuriSquiggleLang.T.Integral.get, t.discrete));
    return Continuous$QuriSquiggleLang.make(undefined, undefined, undefined, XYShape$QuriSquiggleLang.PointwiseCombination.addCombine(XYShape$QuriSquiggleLang.XtoY.continuousInterpolator("Linear", "UseOutermostPoints"), Continuous$QuriSquiggleLang.getShape(continuousIntegral), Continuous$QuriSquiggleLang.getShape(discreteIntegral)));
}
function integralEndY(t) {
    return Continuous$QuriSquiggleLang.lastY(integral(t));
}
function integralXtoY(f, t) {
    return XYShape$QuriSquiggleLang.XtoY.linear(Continuous$QuriSquiggleLang.getShape(integral(t)), f);
}
function integralYtoX(f, t) {
    return XYShape$QuriSquiggleLang.YtoX.linear(Continuous$QuriSquiggleLang.getShape(integral(t)), f);
}
function createMixedFromContinuousDiscrete(integralSumCacheFnOpt, integralCacheFnOpt, t, discrete, continuous) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    var yMappedDiscrete = Discrete$QuriSquiggleLang.updateIntegralCache(Discrete$QuriSquiggleLang.updateIntegralSumCache(discrete, E_O$QuriSquiggleLang.bind(t.discrete.integralSumCache, integralSumCacheFn)), E_O$QuriSquiggleLang.bind(t.discrete.integralCache, integralCacheFn));
    var yMappedContinuous = Continuous$QuriSquiggleLang.updateIntegralCache(Continuous$QuriSquiggleLang.updateIntegralSumCache(continuous, E_O$QuriSquiggleLang.bind(t.continuous.integralSumCache, integralSumCacheFn)), E_O$QuriSquiggleLang.bind(t.continuous.integralCache, integralCacheFn));
    return {
        continuous: yMappedContinuous,
        discrete: yMappedDiscrete,
        integralSumCache: E_O$QuriSquiggleLang.bind(t.integralSumCache, integralSumCacheFn),
        integralCache: E_O$QuriSquiggleLang.bind(t.integralCache, integralCacheFn)
    };
}
function mapY(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    var discrete = Curry._4(Discrete$QuriSquiggleLang.T.mapY, undefined, undefined, t.discrete, fn);
    var continuous = Curry._4(Continuous$QuriSquiggleLang.T.mapY, undefined, undefined, t.continuous, fn);
    return createMixedFromContinuousDiscrete(integralSumCacheFn, integralCacheFn, t, discrete, continuous);
}
function mapYResult(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    return E_R$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.merge(Curry._4(Discrete$QuriSquiggleLang.T.mapYResult, undefined, undefined, t.discrete, fn), Curry._4(Continuous$QuriSquiggleLang.T.mapYResult, undefined, undefined, t.continuous, fn)), (function (param) {
        return createMixedFromContinuousDiscrete(integralSumCacheFn, integralCacheFn, t, param[0], param[1]);
    }));
}
function mean(param) {
    var discrete = param.discrete;
    var continuous = param.continuous;
    var discreteMean = Curry._1(Discrete$QuriSquiggleLang.T.mean, discrete);
    var continuousMean = Curry._1(Continuous$QuriSquiggleLang.T.mean, continuous);
    var discreteIntegralSum = Curry._1(Discrete$QuriSquiggleLang.T.Integral.sum, discrete);
    var continuousIntegralSum = Curry._1(Continuous$QuriSquiggleLang.T.Integral.sum, continuous);
    var totalIntegralSum = discreteIntegralSum + continuousIntegralSum;
    return (discreteMean * discreteIntegralSum + continuousMean * continuousIntegralSum) / totalIntegralSum;
}
function variance(t) {
    var discrete = t.discrete;
    var continuous = t.continuous;
    var discreteIntegralSum = Curry._1(Discrete$QuriSquiggleLang.T.Integral.sum, discrete);
    var continuousIntegralSum = Curry._1(Continuous$QuriSquiggleLang.T.Integral.sum, continuous);
    var totalIntegralSum = discreteIntegralSum + continuousIntegralSum;
    var getMeanOfSquares = function (param) {
        var discreteMean = Curry._1(Discrete$QuriSquiggleLang.T.mean, Discrete$QuriSquiggleLang.shapeMap(param.discrete, XYShape$QuriSquiggleLang.T.square));
        var continuousMean = Continuous$QuriSquiggleLang.Analysis.getMeanOfSquares(param.continuous);
        return (discreteMean * discreteIntegralSum + continuousMean * continuousIntegralSum) / totalIntegralSum;
    };
    var match = discreteIntegralSum / totalIntegralSum;
    if (match !== 0.0) {
        if (match !== 1.0) {
            return XYShape$QuriSquiggleLang.Analysis.getVarianceDangerously(t, mean, getMeanOfSquares);
        }
        else {
            return Curry._1(Discrete$QuriSquiggleLang.T.variance, discrete);
        }
    }
    else {
        return Curry._1(Continuous$QuriSquiggleLang.T.variance, continuous);
    }
}
var T = Distributions$QuriSquiggleLang.Dist({
    minX: minX,
    maxX: maxX,
    mapY: mapY,
    mapYResult: mapYResult,
    xToY: xToY,
    toPointSetDist: toPointSetDist,
    toContinuous: toContinuous,
    toDiscrete: toDiscrete,
    normalize: normalize,
    toDiscreteProbabilityMassFraction: toDiscreteProbabilityMassFraction,
    downsample: downsample,
    truncate: truncate,
    updateIntegralCache: updateIntegralCache,
    integral: integral,
    integralEndY: integralEndY,
    integralXtoY: integralXtoY,
    integralYtoX: integralYtoX,
    mean: mean,
    variance: variance
});
function combineAlgebraically(op, t1, t2) {
    var ccConvResult = Continuous$QuriSquiggleLang.combineAlgebraically(op, t1.continuous, t2.continuous);
    var dcConvResult = Continuous$QuriSquiggleLang.combineAlgebraicallyWithDiscrete(op, t2.continuous, t1.discrete, 0);
    var cdConvResult = Continuous$QuriSquiggleLang.combineAlgebraicallyWithDiscrete(op, t1.continuous, t2.discrete, 1);
    var continuousConvResult = Continuous$QuriSquiggleLang.sum(undefined, [
        ccConvResult,
        dcConvResult,
        cdConvResult
    ]);
    var discreteConvResult = Discrete$QuriSquiggleLang.combineAlgebraically(op, t1.discrete, t2.discrete);
    var combinedIntegralSum = Distributions$QuriSquiggleLang.Common.combineIntegralSums((function (a, b) {
        return a * b;
    }), t1.integralSumCache, t2.integralSumCache);
    return {
        continuous: continuousConvResult,
        discrete: discreteConvResult,
        integralSumCache: combinedIntegralSum,
        integralCache: undefined
    };
}
function combinePointwise(integralSumCachesFnOpt, integralCachesFnOpt, fn, t1, t2) {
    var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
    });
    var integralCachesFn = integralCachesFnOpt !== undefined ? integralCachesFnOpt : (function (param, param$1) {
    });
    var reducedDiscrete = Discrete$QuriSquiggleLang.reduce(E_A$QuriSquiggleLang.O.concatSomes(E_A$QuriSquiggleLang.fmap([
        t1,
        t2
    ], toDiscrete)), integralSumCachesFn, fn);
    var reducedContinuous = Continuous$QuriSquiggleLang.reduce(E_A$QuriSquiggleLang.O.concatSomes(E_A$QuriSquiggleLang.fmap([
        t1,
        t2
    ], toContinuous)), integralSumCachesFn, fn);
    var combinedIntegralSum = Distributions$QuriSquiggleLang.Common.combineIntegralSums(integralSumCachesFn, t1.integralSumCache, t2.integralSumCache);
    var combinedIntegral = Distributions$QuriSquiggleLang.Common.combineIntegrals(integralCachesFn, t1.integralCache, t2.integralCache);
    return E_R$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.merge(reducedContinuous, reducedDiscrete), (function (param) {
        return make(Caml_option.some(combinedIntegralSum), Caml_option.some(combinedIntegral), param[0], param[1]);
    }));
}
exports.make = make;
exports.totalLength = totalLength;
exports.scaleBy = scaleBy;
exports.toContinuous = toContinuous;
exports.toDiscrete = toDiscrete;
exports.updateIntegralCache = updateIntegralCache;
exports.T = T;
exports.combineAlgebraically = combineAlgebraically;
exports.combinePointwise = combinePointwise;
//# sourceMappingURL=Mixed.bs.js.map