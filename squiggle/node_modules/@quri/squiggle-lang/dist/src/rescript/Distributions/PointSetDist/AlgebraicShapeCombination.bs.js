'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Js_array = require("@rescript/std/lib/js/js_array.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_array = require("@rescript/std/lib/js/caml_array.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var Operation$QuriSquiggleLang = require("../../Utility/Operation.bs.js");
function toDiscretePointMassesFromTriangulars(inverseOpt, s) {
    var inverse = inverseOpt !== undefined ? inverseOpt : false;
    var n = XYShape$QuriSquiggleLang.T.length(s);
    var ys = s.ys;
    var xs = s.xs;
    Js_array.unshift(Caml_array.get(xs, 0), xs);
    Js_array.unshift(Caml_array.get(ys, 0), ys);
    Js_array.push(Caml_array.get(xs, n - 1 | 0), xs);
    Js_array.push(Caml_array.get(ys, n - 1 | 0), ys);
    var n$1 = E_A$QuriSquiggleLang.length(xs);
    var xsSq = new Array(n$1);
    var xsProdN1 = new Array(n$1 - 1 | 0);
    var xsProdN2 = new Array(n$1 - 2 | 0);
    for (var i = 0; i < n$1; ++i) {
        Belt_Array.set(xsSq, i, Caml_array.get(xs, i) * Caml_array.get(xs, i));
    }
    for (var i$1 = 0, i_finish = n$1 - 2 | 0; i$1 <= i_finish; ++i$1) {
        Belt_Array.set(xsProdN1, i$1, Caml_array.get(xs, i$1) * Caml_array.get(xs, i$1 + 1 | 0));
    }
    for (var i$2 = 0, i_finish$1 = n$1 - 3 | 0; i$2 <= i_finish$1; ++i$2) {
        Belt_Array.set(xsProdN2, i$2, Caml_array.get(xs, i$2) * Caml_array.get(xs, i$2 + 2 | 0));
    }
    var masses = new Array(n$1 - 2 | 0);
    var means = new Array(n$1 - 2 | 0);
    var variances = new Array(n$1 - 2 | 0);
    if (inverse) {
        for (var i$3 = 1, i_finish$2 = n$1 - 2 | 0; i$3 <= i_finish$2; ++i$3) {
            Belt_Array.set(masses, i$3 - 1 | 0, (Caml_array.get(xs, i$3 + 1 | 0) - Caml_array.get(xs, i$3 - 1 | 0)) * Caml_array.get(ys, i$3) / 2);
            var a = Caml_array.get(xs, i$3 - 1 | 0);
            var c = Caml_array.get(xs, i$3);
            var b = Caml_array.get(xs, i$3 + 1 | 0);
            var inverseMean = 2 * (a * Math.log(a / c) / (a - c) + b * Math.log(c / b) / (b - c)) / (a - b);
            var inverseVar = 2 * (Math.log(c / a) / (a - c) + b * Math.log(b / c) / (b - c)) / (a - b) - Math.pow(inverseMean, 2);
            Belt_Array.set(means, i$3 - 1 | 0, inverseMean);
            Belt_Array.set(variances, i$3 - 1 | 0, inverseVar);
        }
        return {
            n: n$1 - 2 | 0,
            masses: masses,
            means: means,
            variances: variances
        };
    }
    for (var i$4 = 1, i_finish$3 = n$1 - 2 | 0; i$4 <= i_finish$3; ++i$4) {
        Belt_Array.set(masses, i$4 - 1 | 0, (Caml_array.get(xs, i$4 + 1 | 0) - Caml_array.get(xs, i$4 - 1 | 0)) * Caml_array.get(ys, i$4) / 2);
        Belt_Array.set(means, i$4 - 1 | 0, (Caml_array.get(xs, i$4 - 1 | 0) + Caml_array.get(xs, i$4) + Caml_array.get(xs, i$4 + 1 | 0)) / 3);
        Belt_Array.set(variances, i$4 - 1 | 0, (Caml_array.get(xsSq, i$4 - 1 | 0) + Caml_array.get(xsSq, i$4) + Caml_array.get(xsSq, i$4 + 1 | 0) - Caml_array.get(xsProdN1, i$4 - 1 | 0) - Caml_array.get(xsProdN1, i$4) - Caml_array.get(xsProdN2, i$4 - 1 | 0)) / 18);
    }
    return {
        n: n$1 - 2 | 0,
        masses: masses,
        means: means,
        variances: variances
    };
}
function combineShapesContinuousContinuous(op, s1, s2) {
    var t1m = toDiscretePointMassesFromTriangulars(undefined, s1);
    var t2m = toDiscretePointMassesFromTriangulars(false, s2);
    var combineMeansFn = op === "Multiply" ? (function (m1, m2) {
        return m1 * m2;
    }) : (op === "Add" ? (function (m1, m2) {
        return m1 + m2;
    }) : (function (m1, m2) {
        return m1 - m2;
    }));
    var combineVariancesFn = op === "Multiply" ? (function (v1, v2, m1, m2) {
        return v1 * v2 + v1 * Math.pow(m2, 2) + v2 * Math.pow(m1, 2);
    }) : (op === "Add" ? (function (v1, v2, param, param$1) {
        return v1 + v2;
    }) : (function (v1, v2, param, param$1) {
        return v1 + v2;
    }));
    var outputMinX = Pervasives.infinity;
    var outputMaxX = Pervasives.neg_infinity;
    var masses = new Array(Math.imul(t1m.n, t2m.n));
    var means = new Array(Math.imul(t1m.n, t2m.n));
    var variances = new Array(Math.imul(t1m.n, t2m.n));
    for (var i = 0, i_finish = t1m.n; i < i_finish; ++i) {
        for (var j = 0, j_finish = t2m.n; j < j_finish; ++j) {
            var k = Math.imul(i, t2m.n) + j | 0;
            Belt_Array.set(masses, k, Caml_array.get(t1m.masses, i) * Caml_array.get(t2m.masses, j));
            var mean = Curry._2(combineMeansFn, Caml_array.get(t1m.means, i), Caml_array.get(t2m.means, j));
            var variance = Curry._4(combineVariancesFn, Caml_array.get(t1m.variances, i), Caml_array.get(t2m.variances, j), Caml_array.get(t1m.means, i), Caml_array.get(t2m.means, j));
            Belt_Array.set(means, k, mean);
            Belt_Array.set(variances, k, variance);
            var minX = mean - 2 * Math.sqrt(variance) * 1.644854;
            var maxX = mean + 2 * Math.sqrt(variance) * 1.644854;
            if (minX < outputMinX) {
                outputMinX = minX;
            }
            if (maxX > outputMaxX) {
                outputMaxX = maxX;
            }
        }
    }
    var outputXs = E_A$QuriSquiggleLang.Floats.range(outputMinX, outputMaxX, 300);
    var outputYs = Belt_Array.make(300, 0.0);
    for (var j$1 = 0, j_finish$1 = E_A$QuriSquiggleLang.length(masses); j$1 < j_finish$1; ++j$1) {
        if (Caml_array.get(variances, j$1) > 0 && Caml_array.get(masses, j$1) > 0) {
            for (var i$1 = 0, i_finish$1 = E_A$QuriSquiggleLang.length(outputXs); i$1 < i_finish$1; ++i$1) {
                var dx = Caml_array.get(outputXs, i$1) - Caml_array.get(means, j$1);
                var contribution = Caml_array.get(masses, j$1) * Math.exp(-Math.pow(dx, 2) / (2 * Caml_array.get(variances, j$1))) / Math.sqrt(2 * 3.14159276 * Caml_array.get(variances, j$1));
                Belt_Array.set(outputYs, i$1, Caml_array.get(outputYs, i$1) + contribution);
            }
        }
    }
    return {
        xs: outputXs,
        ys: outputYs
    };
}
function toDiscretePointMassesFromDiscrete(s) {
    var ys = s.ys;
    var xs = s.xs;
    var n = E_A$QuriSquiggleLang.length(xs);
    var masses = E_A$QuriSquiggleLang.makeBy(n, (function (i) {
        return Caml_array.get(ys, i);
    }));
    var means = E_A$QuriSquiggleLang.makeBy(n, (function (i) {
        return Caml_array.get(xs, i);
    }));
    var variances = E_A$QuriSquiggleLang.makeBy(n, (function (param) {
        return 0.0;
    }));
    return {
        n: n,
        masses: masses,
        means: means,
        variances: variances
    };
}
function combineShapesContinuousDiscrete(op, continuousShape, discreteShape, discretePosition) {
    var t1n = XYShape$QuriSquiggleLang.T.length(continuousShape);
    var t2n = XYShape$QuriSquiggleLang.T.length(discreteShape);
    var opFunc = Operation$QuriSquiggleLang.Convolution.toFn(op);
    var fn = discretePosition === 0 ? (function (a, b) {
        return Curry._2(opFunc, b, a);
    }) : opFunc;
    var outXYShapes = new Array(t2n);
    if (op === "Multiply") {
        for (var j = 0; j < t2n; ++j) {
            var dxyShape = new Array(t1n);
            for (var i = 0; i < t1n; ++i) {
                var index = Caml_array.get(discreteShape.xs, j) > 0.0 ? i : (t1n - 1 | 0) - i | 0;
                Belt_Array.set(dxyShape, index, [
                    Curry._2(fn, Caml_array.get(continuousShape.xs, i), Caml_array.get(discreteShape.xs, j)),
                    Caml_array.get(continuousShape.ys, i) * Caml_array.get(discreteShape.ys, j) / Math.abs(Caml_array.get(discreteShape.xs, j))
                ]);
            }
            Belt_Array.set(outXYShapes, j, dxyShape);
        }
    }
    else {
        for (var j$1 = 0; j$1 < t2n; ++j$1) {
            var dxyShape$1 = new Array(t1n);
            for (var i$1 = 0; i$1 < t1n; ++i$1) {
                var index$1 = discretePosition === 0 && op === "Subtract" ? (t1n - 1 | 0) - i$1 | 0 : i$1;
                Belt_Array.set(dxyShape$1, index$1, [
                    Curry._2(fn, Caml_array.get(continuousShape.xs, i$1), Caml_array.get(discreteShape.xs, j$1)),
                    Caml_array.get(continuousShape.ys, i$1) * Caml_array.get(discreteShape.ys, j$1)
                ]);
            }
            Belt_Array.set(outXYShapes, j$1, dxyShape$1);
        }
    }
    return E_A$QuriSquiggleLang.fold_left(E_A$QuriSquiggleLang.fmap(outXYShapes, XYShape$QuriSquiggleLang.T.fromZippedArray), XYShape$QuriSquiggleLang.T.empty, (function (acc, x) {
        return XYShape$QuriSquiggleLang.PointwiseCombination.addCombine(XYShape$QuriSquiggleLang.XtoY.continuousInterpolator("Linear", "UseZero"), acc, x);
    }));
}
function isOrdered(a) {
    return E_A$QuriSquiggleLang.Floats.isSorted(a.xs);
}
exports.toDiscretePointMassesFromTriangulars = toDiscretePointMassesFromTriangulars;
exports.combineShapesContinuousContinuous = combineShapesContinuousContinuous;
exports.toDiscretePointMassesFromDiscrete = toDiscretePointMassesFromDiscrete;
exports.combineShapesContinuousDiscrete = combineShapesContinuousDiscrete;
exports.isOrdered = isOrdered;
//# sourceMappingURL=AlgebraicShapeCombination.bs.js.map