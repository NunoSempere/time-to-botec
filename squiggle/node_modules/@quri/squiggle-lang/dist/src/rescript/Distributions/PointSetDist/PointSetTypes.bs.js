'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
function fmap(t, param) {
    switch (t.TAG | 0) {
        case 0:
            return {
                TAG: 0,
                _0: Curry._1(param[0], t._0),
                [Symbol.for("name")]: "Mixed"
            };
        case 1:
            return {
                TAG: 1,
                _0: Curry._1(param[1], t._0),
                [Symbol.for("name")]: "Discrete"
            };
        case 2:
            return {
                TAG: 2,
                _0: Curry._1(param[2], t._0),
                [Symbol.for("name")]: "Continuous"
            };
    }
}
var ShapeMonad = {
    fmap: fmap
};
function toContinuousValue(t) {
    return t.continuous;
}
function toDiscreteValue(t) {
    return t.discrete;
}
function makeContinuous(continuous) {
    return {
        continuous: continuous,
        discrete: 0.0
    };
}
function makeDiscrete(discrete) {
    return {
        continuous: 0.0,
        discrete: discrete
    };
}
function fmap$1(fn, t) {
    return {
        continuous: Curry._1(fn, t.continuous),
        discrete: Curry._1(fn, t.discrete)
    };
}
function combine2(fn, c, d) {
    return {
        continuous: Curry._2(fn, c.continuous, d.continuous),
        discrete: Curry._2(fn, c.discrete, d.discrete)
    };
}
function add(param, param$1) {
    return combine2((function (a, b) {
        return a + b;
    }), param, param$1);
}
var MixedPoint = {
    toContinuousValue: toContinuousValue,
    toDiscreteValue: toDiscreteValue,
    makeContinuous: makeContinuous,
    makeDiscrete: makeDiscrete,
    fmap: fmap$1,
    combine2: combine2,
    add: add
};
function sparklineErrorToString(err) {
    return "Cannot find the sparkline of a discrete distribution";
}
exports.ShapeMonad = ShapeMonad;
exports.MixedPoint = MixedPoint;
exports.sparklineErrorToString = sparklineErrorToString;
//# sourceMappingURL=PointSetTypes.bs.js.map