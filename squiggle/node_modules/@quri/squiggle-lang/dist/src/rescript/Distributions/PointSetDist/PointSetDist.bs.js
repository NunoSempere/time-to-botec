'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Random = require("@rescript/std/lib/js/random.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var Mixed$QuriSquiggleLang = require("./Mixed.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var Discrete$QuriSquiggleLang = require("./Discrete.bs.js");
var Continuous$QuriSquiggleLang = require("./Continuous.bs.js");
var Sparklines$QuriSquiggleLang = require("../../Utility/Sparklines.bs.js");
var Distributions$QuriSquiggleLang = require("./Distributions.bs.js");
var PointSetDist_Scoring$QuriSquiggleLang = require("./PointSetDist_Scoring.bs.js");
function mapToAll(param, t) {
    switch (t.TAG | 0) {
        case 0:
            return Curry._1(param[0], t._0);
        case 1:
            return Curry._1(param[1], t._0);
        case 2:
            return Curry._1(param[2], t._0);
    }
}
function fmap(t, param) {
    switch (t.TAG | 0) {
        case 0:
            return {
                TAG: 0,
                _0: Curry._1(param[0], t._0),
                [Symbol.for("name")]: "Mixed"
            };
        case 1:
            return {
                TAG: 1,
                _0: Curry._1(param[1], t._0),
                [Symbol.for("name")]: "Discrete"
            };
        case 2:
            return {
                TAG: 2,
                _0: Curry._1(param[2], t._0),
                [Symbol.for("name")]: "Continuous"
            };
    }
}
function fmapResult(t, param) {
    switch (t.TAG | 0) {
        case 0:
            return E_R$QuriSquiggleLang.fmap(Curry._1(param[0], t._0), (function (x) {
                return {
                    TAG: 0,
                    _0: x,
                    [Symbol.for("name")]: "Mixed"
                };
            }));
        case 1:
            return E_R$QuriSquiggleLang.fmap(Curry._1(param[1], t._0), (function (x) {
                return {
                    TAG: 1,
                    _0: x,
                    [Symbol.for("name")]: "Discrete"
                };
            }));
        case 2:
            return E_R$QuriSquiggleLang.fmap(Curry._1(param[2], t._0), (function (x) {
                return {
                    TAG: 2,
                    _0: x,
                    [Symbol.for("name")]: "Continuous"
                };
            }));
    }
}
function partial_arg_0(m) {
    return m;
}
function partial_arg_1(d) {
    return Mixed$QuriSquiggleLang.make(Caml_option.some(d.integralSumCache), Caml_option.some(d.integralCache), Continuous$QuriSquiggleLang.empty, d);
}
function partial_arg_2(c) {
    return Mixed$QuriSquiggleLang.make(Caml_option.some(c.integralSumCache), Caml_option.some(c.integralCache), c, Discrete$QuriSquiggleLang.empty);
}
var partial_arg = [
    partial_arg_0,
    partial_arg_1,
    partial_arg_2
];
function toMixed(param) {
    return mapToAll(partial_arg, param);
}
function combineAlgebraically(op, t1, t2) {
    switch (t1.TAG | 0) {
        case 0:
            break;
        case 1:
            var m1 = t1._0;
            switch (t2.TAG | 0) {
                case 0:
                    break;
                case 1:
                    return Curry._1(Discrete$QuriSquiggleLang.T.toPointSetDist, Discrete$QuriSquiggleLang.combineAlgebraically(op, m1, t2._0));
                case 2:
                    return Curry._1(Continuous$QuriSquiggleLang.T.toPointSetDist, Continuous$QuriSquiggleLang.combineAlgebraicallyWithDiscrete(op, t2._0, m1, 0));
            }
            break;
        case 2:
            var m1$1 = t1._0;
            switch (t2.TAG | 0) {
                case 0:
                    break;
                case 1:
                    return Curry._1(Continuous$QuriSquiggleLang.T.toPointSetDist, Continuous$QuriSquiggleLang.combineAlgebraicallyWithDiscrete(op, m1$1, t2._0, 1));
                case 2:
                    return Curry._1(Continuous$QuriSquiggleLang.T.toPointSetDist, Continuous$QuriSquiggleLang.combineAlgebraically(op, m1$1, t2._0));
            }
            break;
    }
    return Curry._1(Mixed$QuriSquiggleLang.T.toPointSetDist, Mixed$QuriSquiggleLang.combineAlgebraically(op, toMixed(t1), toMixed(t2)));
}
function combinePointwise(combinerOpt, integralSumCachesFnOpt, integralCachesFnOpt, fn, t1, t2) {
    var combiner = combinerOpt !== undefined ? combinerOpt : XYShape$QuriSquiggleLang.PointwiseCombination.combine;
    var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
    });
    var integralCachesFn = integralCachesFnOpt !== undefined ? integralCachesFnOpt : (function (param, param$1) {
    });
    switch (t1.TAG | 0) {
        case 0:
            break;
        case 1:
            switch (t2.TAG | 0) {
                case 1:
                    return E_R$QuriSquiggleLang.fmap(Discrete$QuriSquiggleLang.combinePointwise(combiner, integralSumCachesFn, fn, t1._0, t2._0), (function (x) {
                        return {
                            TAG: 1,
                            _0: x,
                            [Symbol.for("name")]: "Discrete"
                        };
                    }));
                case 0:
                case 2:
                    break;
            }
            break;
        case 2:
            switch (t2.TAG | 0) {
                case 0:
                case 1:
                    break;
                case 2:
                    return E_R$QuriSquiggleLang.fmap(Continuous$QuriSquiggleLang.combinePointwise(combiner, integralSumCachesFn, undefined, fn, t1._0, t2._0), (function (x) {
                        return {
                            TAG: 2,
                            _0: x,
                            [Symbol.for("name")]: "Continuous"
                        };
                    }));
            }
            break;
    }
    return E_R$QuriSquiggleLang.fmap(Mixed$QuriSquiggleLang.combinePointwise(integralSumCachesFn, integralCachesFn, fn, toMixed(t1), toMixed(t2)), (function (x) {
        return {
            TAG: 0,
            _0: x,
            [Symbol.for("name")]: "Mixed"
        };
    }));
}
function xToY(f) {
    var partial_arg_0 = Curry._1(Mixed$QuriSquiggleLang.T.xToY, f);
    var partial_arg_1 = Curry._1(Discrete$QuriSquiggleLang.T.xToY, f);
    var partial_arg_2 = Curry._1(Continuous$QuriSquiggleLang.T.xToY, f);
    var partial_arg = [
        partial_arg_0,
        partial_arg_1,
        partial_arg_2
    ];
    return function (param) {
        return mapToAll(partial_arg, param);
    };
}
function toPointSetDist(t) {
    return t;
}
function downsample(i, t) {
    return fmap(t, [
        Curry._1(Mixed$QuriSquiggleLang.T.downsample, i),
        Curry._1(Discrete$QuriSquiggleLang.T.downsample, i),
        Curry._1(Continuous$QuriSquiggleLang.T.downsample, i)
    ]);
}
function truncate(leftCutoff, rightCutoff, t) {
    return fmap(t, [
        Curry._2(Mixed$QuriSquiggleLang.T.truncate, leftCutoff, rightCutoff),
        Curry._2(Discrete$QuriSquiggleLang.T.truncate, leftCutoff, rightCutoff),
        Curry._2(Continuous$QuriSquiggleLang.T.truncate, leftCutoff, rightCutoff)
    ]);
}
function normalize(__x) {
    return fmap(__x, [
        Mixed$QuriSquiggleLang.T.normalize,
        Discrete$QuriSquiggleLang.T.normalize,
        Continuous$QuriSquiggleLang.T.normalize
    ]);
}
function updateIntegralCache(t, integralCache) {
    return fmap(t, [
        (function (__x) {
            return Curry._2(Mixed$QuriSquiggleLang.T.updateIntegralCache, __x, integralCache);
        }),
        (function (__x) {
            return Curry._2(Discrete$QuriSquiggleLang.T.updateIntegralCache, __x, integralCache);
        }),
        (function (__x) {
            return Curry._2(Continuous$QuriSquiggleLang.T.updateIntegralCache, __x, integralCache);
        })
    ]);
}
var partial_arg_0$1 = Mixed$QuriSquiggleLang.T.toContinuous;
var partial_arg_1$1 = Discrete$QuriSquiggleLang.T.toContinuous;
var partial_arg_2$1 = Continuous$QuriSquiggleLang.T.toContinuous;
var partial_arg$1 = [
    partial_arg_0$1,
    partial_arg_1$1,
    partial_arg_2$1
];
function toContinuous(param) {
    return mapToAll(partial_arg$1, param);
}
var partial_arg_0$2 = Mixed$QuriSquiggleLang.T.toDiscrete;
var partial_arg_1$2 = Discrete$QuriSquiggleLang.T.toDiscrete;
var partial_arg_2$2 = Continuous$QuriSquiggleLang.T.toDiscrete;
var partial_arg$2 = [
    partial_arg_0$2,
    partial_arg_1$2,
    partial_arg_2$2
];
function toDiscrete(param) {
    return mapToAll(partial_arg$2, param);
}
var partial_arg_0$3 = Mixed$QuriSquiggleLang.T.toDiscreteProbabilityMassFraction;
var partial_arg_1$3 = Discrete$QuriSquiggleLang.T.toDiscreteProbabilityMassFraction;
var partial_arg_2$3 = Continuous$QuriSquiggleLang.T.toDiscreteProbabilityMassFraction;
var partial_arg$3 = [
    partial_arg_0$3,
    partial_arg_1$3,
    partial_arg_2$3
];
function toDiscreteProbabilityMassFraction(param) {
    return mapToAll(partial_arg$3, param);
}
var partial_arg_0$4 = Mixed$QuriSquiggleLang.T.minX;
var partial_arg_1$4 = Discrete$QuriSquiggleLang.T.minX;
var partial_arg_2$4 = Continuous$QuriSquiggleLang.T.minX;
var partial_arg$4 = [
    partial_arg_0$4,
    partial_arg_1$4,
    partial_arg_2$4
];
function minX(param) {
    return mapToAll(partial_arg$4, param);
}
var partial_arg_0$5 = Mixed$QuriSquiggleLang.T.Integral.get;
var partial_arg_1$5 = Discrete$QuriSquiggleLang.T.Integral.get;
var partial_arg_2$5 = Continuous$QuriSquiggleLang.T.Integral.get;
var partial_arg$5 = [
    partial_arg_0$5,
    partial_arg_1$5,
    partial_arg_2$5
];
function integral(param) {
    return mapToAll(partial_arg$5, param);
}
var partial_arg_0$6 = Mixed$QuriSquiggleLang.T.Integral.sum;
var partial_arg_1$6 = Discrete$QuriSquiggleLang.T.Integral.sum;
var partial_arg_2$6 = Continuous$QuriSquiggleLang.T.Integral.sum;
var partial_arg$6 = [
    partial_arg_0$6,
    partial_arg_1$6,
    partial_arg_2$6
];
function integralEndY(param) {
    return mapToAll(partial_arg$6, param);
}
function integralXtoY(f) {
    var partial_arg_0 = Curry._1(Mixed$QuriSquiggleLang.T.Integral.xToY, f);
    var partial_arg_1 = Curry._1(Discrete$QuriSquiggleLang.T.Integral.xToY, f);
    var partial_arg_2 = Curry._1(Continuous$QuriSquiggleLang.T.Integral.xToY, f);
    var partial_arg = [
        partial_arg_0,
        partial_arg_1,
        partial_arg_2
    ];
    return function (param) {
        return mapToAll(partial_arg, param);
    };
}
function integralYtoX(f) {
    var partial_arg_0 = Curry._1(Mixed$QuriSquiggleLang.T.Integral.yToX, f);
    var partial_arg_1 = Curry._1(Discrete$QuriSquiggleLang.T.Integral.yToX, f);
    var partial_arg_2 = Curry._1(Continuous$QuriSquiggleLang.T.Integral.yToX, f);
    var partial_arg = [
        partial_arg_0,
        partial_arg_1,
        partial_arg_2
    ];
    return function (param) {
        return mapToAll(partial_arg, param);
    };
}
var partial_arg_0$7 = Mixed$QuriSquiggleLang.T.maxX;
var partial_arg_1$7 = Discrete$QuriSquiggleLang.T.maxX;
var partial_arg_2$7 = Continuous$QuriSquiggleLang.T.maxX;
var partial_arg$7 = [
    partial_arg_0$7,
    partial_arg_1$7,
    partial_arg_2$7
];
function maxX(param) {
    return mapToAll(partial_arg$7, param);
}
function mapY(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    return fmap(t, [
        (function (__x) {
            return Curry._4(Mixed$QuriSquiggleLang.T.mapY, integralSumCacheFn, integralCacheFn, __x, fn);
        }),
        (function (__x) {
            return Curry._4(Discrete$QuriSquiggleLang.T.mapY, integralSumCacheFn, integralCacheFn, __x, fn);
        }),
        (function (__x) {
            return Curry._4(Continuous$QuriSquiggleLang.T.mapY, integralSumCacheFn, integralCacheFn, __x, fn);
        })
    ]);
}
function mapYResult(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    return fmapResult(t, [
        (function (__x) {
            return Curry._4(Mixed$QuriSquiggleLang.T.mapYResult, integralSumCacheFn, integralCacheFn, __x, fn);
        }),
        (function (__x) {
            return Curry._4(Discrete$QuriSquiggleLang.T.mapYResult, integralSumCacheFn, integralCacheFn, __x, fn);
        }),
        (function (__x) {
            return Curry._4(Continuous$QuriSquiggleLang.T.mapYResult, integralSumCacheFn, integralCacheFn, __x, fn);
        })
    ]);
}
function mean(t) {
    switch (t.TAG | 0) {
        case 0:
            return Curry._1(Mixed$QuriSquiggleLang.T.mean, t._0);
        case 1:
            return Curry._1(Discrete$QuriSquiggleLang.T.mean, t._0);
        case 2:
            return Curry._1(Continuous$QuriSquiggleLang.T.mean, t._0);
    }
}
function variance(t) {
    switch (t.TAG | 0) {
        case 0:
            return Curry._1(Mixed$QuriSquiggleLang.T.variance, t._0);
        case 1:
            return Curry._1(Discrete$QuriSquiggleLang.T.variance, t._0);
        case 2:
            return Curry._1(Continuous$QuriSquiggleLang.T.variance, t._0);
    }
}
var T = Distributions$QuriSquiggleLang.Dist({
    minX: minX,
    maxX: maxX,
    mapY: mapY,
    mapYResult: mapYResult,
    xToY: xToY,
    toPointSetDist: toPointSetDist,
    toContinuous: toContinuous,
    toDiscrete: toDiscrete,
    normalize: normalize,
    toDiscreteProbabilityMassFraction: toDiscreteProbabilityMassFraction,
    downsample: downsample,
    truncate: truncate,
    updateIntegralCache: updateIntegralCache,
    integral: integral,
    integralEndY: integralEndY,
    integralXtoY: integralXtoY,
    integralYtoX: integralYtoX,
    mean: mean,
    variance: variance
});
function logScore(args) {
    return PointSetDist_Scoring$QuriSquiggleLang.logScore(args, (function (eta) {
        return function (param, param$1) {
            return combinePointwise(undefined, undefined, undefined, eta, param, param$1);
        };
    }), T.Integral.sum, toMixed);
}
function pdf(f, t) {
    var mixedPoint = Curry._2(T.xToY, f, t);
    return mixedPoint.continuous + mixedPoint.discrete;
}
var inv = T.Integral.yToX;
var cdf = T.Integral.xToY;
function doN(n, fn) {
    var items = Belt_Array.make(n, 0.0);
    for (var x = 0; x < n; ++x) {
        Belt_Array.set(items, x, Curry._1(fn, undefined));
    }
    return items;
}
function sample(t) {
    var randomItem = Random.$$float(1.0);
    return Curry._2(T.Integral.yToX, randomItem, t);
}
function isFloat(t) {
    switch (t.TAG | 0) {
        case 1:
            var match = t._0.xyShape;
            if (match.xs.length !== 1) {
                return false;
            }
            var match$1 = match.ys;
            if (match$1.length !== 1) {
                return false;
            }
            var match$2 = match$1[0];
            return match$2 === 1.0;
        case 0:
        case 2:
            return false;
    }
}
function sampleNRendered(n, dist) {
    var integralCache = Curry._1(T.Integral.get, dist);
    var distWithUpdatedIntegralCache = Curry._2(T.updateIntegralCache, dist, integralCache);
    return doN(n, (function (param) {
        return sample(distWithUpdatedIntegralCache);
    }));
}
function operate(distToFloatOp, s) {
    if (typeof distToFloatOp !== "object") {
        if (distToFloatOp === "Max") {
            return Curry._1(T.maxX, s);
        }
        else if (distToFloatOp === "Min") {
            return Curry._1(T.minX, s);
        }
        else if (distToFloatOp === "Mean") {
            return Curry._1(T.mean, s);
        }
        else {
            return sample(s);
        }
    }
    var variant = distToFloatOp.NAME;
    if (variant === "Inv") {
        return Curry._2(inv, distToFloatOp.VAL, s);
    }
    else if (variant === "Pdf") {
        return pdf(distToFloatOp.VAL, s);
    }
    else {
        return Curry._2(cdf, distToFloatOp.VAL, s);
    }
}
function toSparkline(t, bucketCount) {
    return E_R$QuriSquiggleLang.fmap(E_O$QuriSquiggleLang.toResult(E_O$QuriSquiggleLang.fmap(Curry._1(T.toContinuous, t), (function (param) {
        return Continuous$QuriSquiggleLang.downsampleEquallyOverX(bucketCount, param);
    })), 0), (function (r) {
        return Sparklines$QuriSquiggleLang.create(Continuous$QuriSquiggleLang.getShape(r).ys, undefined, undefined);
    }));
}
function makeDiscrete(d) {
    return {
        TAG: 1,
        _0: d,
        [Symbol.for("name")]: "Discrete"
    };
}
function makeContinuous(d) {
    return {
        TAG: 2,
        _0: d,
        [Symbol.for("name")]: "Continuous"
    };
}
function makeMixed(d) {
    return {
        TAG: 0,
        _0: d,
        [Symbol.for("name")]: "Mixed"
    };
}
exports.mapToAll = mapToAll;
exports.fmap = fmap;
exports.fmapResult = fmapResult;
exports.toMixed = toMixed;
exports.combineAlgebraically = combineAlgebraically;
exports.combinePointwise = combinePointwise;
exports.T = T;
exports.logScore = logScore;
exports.pdf = pdf;
exports.inv = inv;
exports.cdf = cdf;
exports.doN = doN;
exports.sample = sample;
exports.isFloat = isFloat;
exports.sampleNRendered = sampleNRendered;
exports.operate = operate;
exports.toSparkline = toSparkline;
exports.makeDiscrete = makeDiscrete;
exports.makeContinuous = makeContinuous;
exports.makeMixed = makeMixed;
//# sourceMappingURL=PointSetDist.bs.js.map