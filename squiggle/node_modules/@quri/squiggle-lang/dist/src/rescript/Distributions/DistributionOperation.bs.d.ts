export namespace defaultEnv {
    export { defaultEnv_sampleCount as sampleCount };
    export { defaultEnv_xyPointLength as xyPointLength };
}
export function run(env: any, functionCallInfo: any): any;
export function runFromDist(env: any, functionCallInfo: any, dist: any): any;
export function runFromFloat(env: any, functionCallInfo: any, $$float: any): any;
export namespace Output {
    export { toDist };
    export { toDistR };
    export { toFloat };
    export { toFloatR };
    export { toString };
    export { toStringR };
    export { toBool };
    export { toBoolR };
    export { toError };
    export { fmap };
}
export namespace Constructors {
    export { mean };
    export { stdev };
    export { variance };
    export { sample };
    export { cdf };
    export { inv };
    export { pdf };
    export { normalize };
    export { isNormalized };
    export { LogScore };
    export { toPointSet };
    export { toSampleSet };
    export { fromSamples };
    export { truncate };
    export { inspect };
    export { toString$1 as toString };
    export { toSparkline };
    export { algebraicAdd };
    export { algebraicMultiply };
    export { algebraicDivide };
    export { algebraicSubtract };
    export { algebraicLogarithm };
    export { algebraicPower };
    export { scaleLogarithm };
    export { scaleMultiply };
    export { scalePower };
    export { pointwiseAdd };
    export { pointwiseMultiply };
    export { pointwiseDivide };
    export { pointwiseSubtract };
    export { pointwiseLogarithm };
    export { pointwisePower };
}
declare var defaultEnv_sampleCount: number;
declare var defaultEnv_xyPointLength: number;
declare function toDist(t: any): any;
declare function toDistR(t: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toFloat(t: any): any;
declare function toFloatR(t: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toString(t: any): any;
declare function toStringR(t: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toBool(t: any): any;
declare function toBoolR(t: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toError(t: any): any;
declare function fmap(env: any, input: any, functionCallInfo: any): any;
declare function mean(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function stdev(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function variance(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function sample(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function cdf(env: any, dist: any, f: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function inv(env: any, dist: any, f: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pdf(env: any, dist: any, f: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function normalize(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function isNormalized(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare namespace LogScore {
    export { distEstimateDistAnswer };
    export { distEstimateDistAnswerWithPrior };
    export { distEstimateScalarAnswer };
    export { distEstimateScalarAnswerWithPrior };
}
declare function toPointSet(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toSampleSet(env: any, dist: any, n: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function fromSamples(env: any, xs: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function truncate(env: any, dist: any, leftCutoff: any, rightCutoff: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function inspect(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toString$1(env: any, dist: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function toSparkline(env: any, dist: any, bucketCount: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicAdd(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicMultiply(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicDivide(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicSubtract(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicLogarithm(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function algebraicPower(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function scaleLogarithm(env: any, dist: any, n: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function scaleMultiply(env: any, dist: any, n: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function scalePower(env: any, dist: any, n: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwiseAdd(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwiseMultiply(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwiseDivide(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwiseSubtract(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwiseLogarithm(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function pointwisePower(env: any, dist1: any, dist2: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function distEstimateDistAnswer(env: any, estimate: any, answer: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function distEstimateDistAnswerWithPrior(env: any, estimate: any, answer: any, prior: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function distEstimateScalarAnswer(env: any, estimate: any, answer: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare function distEstimateScalarAnswerWithPrior(env: any, estimate: any, answer: any, prior: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
export {};
