"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPointSetDist = void 0;
const KdeLibrary_1 = require("./KdeLibrary");
const SampleSetDist_Bandwidth_1 = require("./SampleSetDist_Bandwidth");
const SplitContinuousAndDiscrete_1 = require("./SplitContinuousAndDiscrete");
const minDiscreteToKeep = (samples) => Math.max(20, samples.length / 50);
const toPointSetDist = (samples, outputXYPoints, kernelWidth) => {
    samples = Array.from(new Float64Array(samples).sort());
    const { continuousPart, discretePart } = (0, SplitContinuousAndDiscrete_1.splitContinuousAndDiscrete)(samples, minDiscreteToKeep(samples));
    const contLength = continuousPart.length;
    let pointWeight = 1 / samples.length;
    let continuousDist = undefined;
    let samplingStats = undefined;
    if (contLength <= 5) {
        pointWeight = 1 / (samples.length - contLength);
    }
    else if (continuousPart[0] === continuousPart[contLength - 1]) {
        discretePart.xs.push(contLength);
        discretePart.ys.push(continuousPart[0]);
    }
    else {
        const bandwidthXSuggested = (0, SampleSetDist_Bandwidth_1.nrd0)(continuousPart);
        const width = kernelWidth || bandwidthXSuggested;
        const { usedWidth: bandwidthXImplemented, xs, ys, } = (0, KdeLibrary_1.kde)(continuousPart, outputXYPoints, width, pointWeight);
        continuousDist = { xs, ys };
        samplingStats = {
            outputXYPoints,
            bandwidthXSuggested,
            bandwidthXImplemented,
        };
    }
    discretePart.ys = discretePart.ys.map((count) => count * pointWeight);
    return {
        continuousDist,
        discreteDist: discretePart,
    };
};
exports.toPointSetDist = toPointSetDist;
//# sourceMappingURL=SampleSetDist_ToPointSet.js.map