'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_array = require("@rescript/std/lib/js/caml_array.js");
var Pervasives = require("@rescript/std/lib/js/pervasives.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Belt_MutableMap = require("@rescript/std/lib/js/belt_MutableMap.js");
var E_A$QuriSquiggleLang = require("../../Utility/E/E_A.bs.js");
var E_O$QuriSquiggleLang = require("../../Utility/E/E_O.bs.js");
var E_R$QuriSquiggleLang = require("../../Utility/E/E_R.bs.js");
var Stdlib$QuriSquiggleLang = require("../../Utility/Stdlib.bs.js");
var XYShape$QuriSquiggleLang = require("../../Utility/XYShape.bs.js");
var Operation$QuriSquiggleLang = require("../../Utility/Operation.bs.js");
var Continuous$QuriSquiggleLang = require("./Continuous.bs.js");
var Distributions$QuriSquiggleLang = require("./Distributions.bs.js");
var PointSetTypes$QuriSquiggleLang = require("./PointSetTypes.bs.js");
var E_FloatFloatMap$QuriSquiggleLang = require("../../Utility/E/E_FloatFloatMap.bs.js");
function make(integralSumCacheOpt, integralCacheOpt, xyShape) {
    var integralSumCache = integralSumCacheOpt !== undefined ? Caml_option.valFromOption(integralSumCacheOpt) : undefined;
    var integralCache = integralCacheOpt !== undefined ? Caml_option.valFromOption(integralCacheOpt) : undefined;
    return {
        xyShape: xyShape,
        integralSumCache: integralSumCache,
        integralCache: integralCache
    };
}
function shapeMap(param, fn) {
    return {
        xyShape: Curry._1(fn, param.xyShape),
        integralSumCache: param.integralSumCache,
        integralCache: param.integralCache
    };
}
function getShape(t) {
    return t.xyShape;
}
function oShapeMap(fn, param) {
    var partial_arg = Caml_option.some(param.integralCache);
    var partial_arg$1 = Caml_option.some(param.integralSumCache);
    return E_O$QuriSquiggleLang.fmap(Curry._1(fn, param.xyShape), (function (param) {
        return make(partial_arg$1, partial_arg, param);
    }));
}
var emptyIntegral_xyShape = {
    xs: [Pervasives.neg_infinity],
    ys: [0.0]
};
var emptyIntegral_integralSumCache = 0.0;
var emptyIntegral = {
    xyShape: emptyIntegral_xyShape,
    interpolation: "Stepwise",
    integralSumCache: emptyIntegral_integralSumCache,
    integralCache: undefined
};
var empty_xyShape = XYShape$QuriSquiggleLang.T.empty;
var empty_integralSumCache = 0.0;
var empty_integralCache = emptyIntegral;
var empty = {
    xyShape: empty_xyShape,
    integralSumCache: empty_integralSumCache,
    integralCache: empty_integralCache
};
function shapeFn(t, fn) {
    return Curry._1(fn, t.xyShape);
}
function lastY(t) {
    return XYShape$QuriSquiggleLang.T.lastY(t.xyShape);
}
function combinePointwise(combinerOpt, integralSumCachesFnOpt, fnOpt, t1, t2) {
    var combiner = combinerOpt !== undefined ? combinerOpt : XYShape$QuriSquiggleLang.PointwiseCombination.combine;
    var fn = fnOpt !== undefined ? fnOpt : (function (a, b) {
        return {
            TAG: 0,
            _0: a + b,
            [Symbol.for("name")]: "Ok"
        };
    });
    return E_R$QuriSquiggleLang.fmap(Curry._4(combiner, XYShape$QuriSquiggleLang.XtoY.discreteInterpolator, fn, t1.xyShape, t2.xyShape), (function (eta) {
        return make(undefined, undefined, eta);
    }));
}
function reduce(discreteShapes, integralSumCachesFnOpt, fn) {
    var integralSumCachesFn = integralSumCachesFnOpt !== undefined ? integralSumCachesFnOpt : (function (param, param$1) {
    });
    var arg = integralSumCachesFn;
    var arg$1 = fn;
    return E_A$QuriSquiggleLang.R.foldM(discreteShapes, empty, (function (eta) {
        return function (param) {
            return combinePointwise(undefined, arg, arg$1, eta, param);
        };
    }));
}
function updateIntegralSumCache(t, integralSumCache) {
    return {
        xyShape: t.xyShape,
        integralSumCache: integralSumCache,
        integralCache: t.integralCache
    };
}
function updateIntegralCache(t, integralCache) {
    return {
        xyShape: t.xyShape,
        integralSumCache: t.integralSumCache,
        integralCache: integralCache
    };
}
function combineAlgebraically(op, t1, t2) {
    var t1s = t1.xyShape;
    var t2s = t2.xyShape;
    var t1n = XYShape$QuriSquiggleLang.T.length(t1s);
    var t2n = XYShape$QuriSquiggleLang.T.length(t2s);
    var combinedIntegralSum = Distributions$QuriSquiggleLang.Common.combineIntegralSums((function (s1, s2) {
        return s1 * s2;
    }), t1.integralSumCache, t2.integralSumCache);
    var fn = Operation$QuriSquiggleLang.Convolution.toFn(op);
    var xToYMap = E_FloatFloatMap$QuriSquiggleLang.empty(undefined);
    for (var i = 0; i < t1n; ++i) {
        for (var j = 0; j < t2n; ++j) {
            var x = Curry._2(fn, Caml_array.get(t1s.xs, i), Caml_array.get(t2s.xs, j));
            var cv = E_O$QuriSquiggleLang.$$default(E_FloatFloatMap$QuriSquiggleLang.get(x, xToYMap), 0);
            var my = Caml_array.get(t1s.ys, i) * Caml_array.get(t2s.ys, j);
            Belt_MutableMap.set(xToYMap, x, cv + my);
        }
    }
    var rxys = XYShape$QuriSquiggleLang.Zipped.sortByX(E_FloatFloatMap$QuriSquiggleLang.toArray(xToYMap));
    var combinedShape = XYShape$QuriSquiggleLang.T.fromZippedArray(rxys);
    return make(Caml_option.some(combinedIntegralSum), undefined, combinedShape);
}
function mapYResult(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    return E_R$QuriSquiggleLang.fmap(XYShape$QuriSquiggleLang.T.mapYResult(t.xyShape, fn), (function (x) {
        return make(Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralSumCache, integralSumCacheFn)), Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralCache, integralCacheFn)), x);
    }));
}
function mapY(integralSumCacheFnOpt, integralCacheFnOpt, t, fn) {
    var integralSumCacheFn = integralSumCacheFnOpt !== undefined ? integralSumCacheFnOpt : (function (param) {
    });
    var integralCacheFn = integralCacheFnOpt !== undefined ? integralCacheFnOpt : (function (param) {
    });
    return make(Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralSumCache, integralSumCacheFn)), Caml_option.some(E_O$QuriSquiggleLang.bind(t.integralCache, integralCacheFn)), XYShape$QuriSquiggleLang.T.mapY(t.xyShape, fn));
}
function scaleBy(t, scale) {
    var scaledIntegralSumCache = E_O$QuriSquiggleLang.fmap(t.integralSumCache, (function (param) {
        return scale * param;
    }));
    var scaledIntegralCache = E_O$QuriSquiggleLang.fmap(t.integralCache, (function (__x) {
        return Continuous$QuriSquiggleLang.scaleBy(__x, scale);
    }));
    return updateIntegralCache(updateIntegralSumCache(mapY(undefined, undefined, t, (function (r) {
        return r * scale;
    })), scaledIntegralSumCache), scaledIntegralCache);
}
function integral(t) {
    var match = XYShape$QuriSquiggleLang.T.isEmpty(t.xyShape);
    var match$1 = t.integralCache;
    if (match) {
        return emptyIntegral;
    }
    if (match$1 !== undefined) {
        return match$1;
    }
    var ts = t.xyShape;
    var firstX = XYShape$QuriSquiggleLang.T.minX(ts);
    var prependedZeroPoint_xs = [firstX - Pervasives.epsilon_float];
    var prependedZeroPoint_ys = [0];
    var prependedZeroPoint = {
        xs: prependedZeroPoint_xs,
        ys: prependedZeroPoint_ys
    };
    var integralShape = XYShape$QuriSquiggleLang.T.accumulateYs(XYShape$QuriSquiggleLang.T.concat(prependedZeroPoint, ts), (function (prim0, prim1) {
        return prim0 + prim1;
    }));
    return Continuous$QuriSquiggleLang.make("Stepwise", undefined, undefined, integralShape);
}
function integralEndY(t) {
    return E_O$QuriSquiggleLang.defaultFn(t.integralSumCache, (function (param) {
        return Continuous$QuriSquiggleLang.lastY(integral(t));
    }));
}
function minX(__x) {
    return XYShape$QuriSquiggleLang.T.minX(__x.xyShape);
}
function maxX(__x) {
    return XYShape$QuriSquiggleLang.T.maxX(__x.xyShape);
}
function toDiscreteProbabilityMassFraction(param) {
    return 1.0;
}
function toPointSetDist(t) {
    return {
        TAG: 1,
        _0: t,
        [Symbol.for("name")]: "Discrete"
    };
}
function toContinuous(param) {
}
function toDiscrete(t) {
    return Caml_option.some(t);
}
function normalize(t) {
    return updateIntegralSumCache(scaleBy(t, 1 / integralEndY(t)), 1.0);
}
function downsample(i, t) {
    var currentLength = XYShape$QuriSquiggleLang.T.length(t.xyShape);
    if (i < currentLength && i >= 1 && currentLength > 1) {
        return make(undefined, undefined, XYShape$QuriSquiggleLang.T.fromZippedArray(XYShape$QuriSquiggleLang.Zipped.sortByX(E_A$QuriSquiggleLang.slice(Belt_Array.reverse(XYShape$QuriSquiggleLang.Zipped.sortByY(XYShape$QuriSquiggleLang.T.zip(t.xyShape))), 0, i))));
    }
    else {
        return t;
    }
}
function truncate(leftCutoff, rightCutoff, t) {
    return make(undefined, undefined, XYShape$QuriSquiggleLang.T.fromZippedArray(XYShape$QuriSquiggleLang.Zipped.filterByX(XYShape$QuriSquiggleLang.T.zip(t.xyShape), (function (x) {
        if (x >= E_O$QuriSquiggleLang.$$default(leftCutoff, Pervasives.neg_infinity)) {
            return x <= E_O$QuriSquiggleLang.$$default(rightCutoff, Pervasives.infinity);
        }
        else {
            return false;
        }
    }))));
}
function xToY(f, t) {
    return PointSetTypes$QuriSquiggleLang.MixedPoint.makeDiscrete(E_O$QuriSquiggleLang.$$default(XYShape$QuriSquiggleLang.XtoY.stepwiseIfAtX(t.xyShape, f), 0.0));
}
function integralXtoY(f, t) {
    return XYShape$QuriSquiggleLang.XtoY.linear(Continuous$QuriSquiggleLang.getShape(integral(t)), f);
}
function integralYtoX(f, t) {
    return XYShape$QuriSquiggleLang.YtoX.linear(Continuous$QuriSquiggleLang.getShape(integral(t)), f);
}
function mean(t) {
    var s = t.xyShape;
    return E_A$QuriSquiggleLang.reducei(s.xs, 0.0, (function (acc, x, i) {
        return acc + x * Caml_array.get(s.ys, i);
    }));
}
function variance(t) {
    var getMeanOfSquares = function (t) {
        return mean(shapeMap(t, XYShape$QuriSquiggleLang.T.square));
    };
    return XYShape$QuriSquiggleLang.Analysis.getVarianceDangerously(t, mean, getMeanOfSquares);
}
var T = Distributions$QuriSquiggleLang.Dist({
    minX: minX,
    maxX: maxX,
    mapY: mapY,
    mapYResult: mapYResult,
    xToY: xToY,
    toPointSetDist: toPointSetDist,
    toContinuous: toContinuous,
    toDiscrete: toDiscrete,
    normalize: normalize,
    toDiscreteProbabilityMassFraction: toDiscreteProbabilityMassFraction,
    downsample: downsample,
    truncate: truncate,
    updateIntegralCache: updateIntegralCache,
    integral: integral,
    integralEndY: integralEndY,
    integralXtoY: integralXtoY,
    integralYtoX: integralYtoX,
    mean: mean,
    variance: variance
});
function sampleN(t, n) {
    var normalized = Curry._1(T.normalize, t).xyShape;
    return Stdlib$QuriSquiggleLang.Random.sample(normalized.xs, {
        probs: normalized.ys,
        size: n
    });
}
exports.make = make;
exports.shapeMap = shapeMap;
exports.getShape = getShape;
exports.oShapeMap = oShapeMap;
exports.emptyIntegral = emptyIntegral;
exports.empty = empty;
exports.shapeFn = shapeFn;
exports.lastY = lastY;
exports.combinePointwise = combinePointwise;
exports.reduce = reduce;
exports.updateIntegralSumCache = updateIntegralSumCache;
exports.updateIntegralCache = updateIntegralCache;
exports.combineAlgebraically = combineAlgebraically;
exports.mapYResult = mapYResult;
exports.mapY = mapY;
exports.scaleBy = scaleBy;
exports.T = T;
exports.sampleN = sampleN;
//# sourceMappingURL=Discrete.bs.js.map