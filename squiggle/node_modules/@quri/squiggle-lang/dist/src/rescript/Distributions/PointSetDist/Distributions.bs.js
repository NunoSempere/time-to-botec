'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
function Dist(T) {
    var minX = T.minX;
    var maxX = T.maxX;
    var xTotalRange = function (t) {
        return Curry._1(maxX, t) - Curry._1(minX, t);
    };
    var Integral_get = T.integral;
    var Integral_xToY = T.integralXtoY;
    var Integral_yToX = T.integralYtoX;
    var Integral_sum = T.integralEndY;
    var Integral = {
        get: Integral_get,
        xToY: Integral_xToY,
        yToX: Integral_yToX,
        sum: Integral_sum
    };
    return {
        minX: minX,
        maxX: maxX,
        integral: T.integral,
        xTotalRange: xTotalRange,
        mapY: T.mapY,
        mapYResult: T.mapYResult,
        xToY: T.xToY,
        downsample: T.downsample,
        toPointSetDist: T.toPointSetDist,
        toDiscreteProbabilityMassFraction: T.toDiscreteProbabilityMassFraction,
        toContinuous: T.toContinuous,
        toDiscrete: T.toDiscrete,
        normalize: T.normalize,
        truncate: T.truncate,
        mean: T.mean,
        variance: T.variance,
        integralEndY: T.integralEndY,
        updateIntegralCache: T.updateIntegralCache,
        Integral: Integral
    };
}
function combineIntegralSums(combineFn, t1IntegralSumCache, t2IntegralSumCache) {
    if (t1IntegralSumCache !== undefined && t2IntegralSumCache !== undefined) {
        return Curry._2(combineFn, t1IntegralSumCache, t2IntegralSumCache);
    }
}
function combineIntegrals(combineFn, t1IntegralCache, t2IntegralCache) {
    if (t1IntegralCache !== undefined && t2IntegralCache !== undefined) {
        return Curry._2(combineFn, t1IntegralCache, t2IntegralCache);
    }
}
var Common = {
    combineIntegralSums: combineIntegralSums,
    combineIntegrals: combineIntegrals
};
exports.Dist = Dist;
exports.Common = Common;
//# sourceMappingURL=Distributions.bs.js.map