'use strict';
var E_I$QuriSquiggleLang = require("../Utility/E/E_I.bs.js");
var E_R$QuriSquiggleLang = require("../Utility/E/E_R.bs.js");
var E_Float$QuriSquiggleLang = require("../Utility/E/E_Float.bs.js");
var XYShape$QuriSquiggleLang = require("../Utility/XYShape.bs.js");
var Operation$QuriSquiggleLang = require("../Utility/Operation.bs.js");
var PointSetTypes$QuriSquiggleLang = require("./PointSetDist/PointSetTypes.bs.js");
var SampleSetDist$QuriSquiggleLang = require("./SampleSetDist/SampleSetDist.bs.js");
function fromString(s) {
    return {
        TAG: 7,
        _0: s,
        [Symbol.for("name")]: "OtherError"
    };
}
function toString(err) {
    if (typeof err === "number") {
        switch (err) {
            case 0:
                return "Function not yet implemented";
            case 1:
                return "Unreachable";
            case 2:
                return "Distribution vertical shift is invalid";
        }
    }
    else {
        switch (err.TAG | 0) {
            case 0:
                var err$1 = err._0;
                if (typeof err$1 === "number") {
                    return "Too Few Samples";
                }
                else if (err$1.TAG === 0) {
                    return "Found a non-number in input: " + err$1._0 + "";
                }
                else {
                    return Operation$QuriSquiggleLang.$$Error.toString(err$1._0);
                }
            case 1:
                return "Argument Error " + err._0 + "";
            case 2:
                return Operation$QuriSquiggleLang.$$Error.toString(err._0);
            case 3:
                return SampleSetDist$QuriSquiggleLang.pointsetConversionErrorToString(err._0);
            case 4:
                return PointSetTypes$QuriSquiggleLang.sparklineErrorToString(err._0);
            case 5:
                return "Requested strategy invalid: " + err._0 + "";
            case 6:
                return "Logarithm of input error: " + err._0 + "";
            case 7:
                return err._0;
            case 8:
                return "XY Shape Error: " + XYShape$QuriSquiggleLang.$$Error.toString(err._0) + "";
        }
    }
}
function resultStringToResultError(n) {
    return E_R$QuriSquiggleLang.errMap(n, (function (r) {
        return {
            TAG: 7,
            _0: r,
            [Symbol.for("name")]: "OtherError"
        };
    }));
}
function sampleErrorToDistErr(err) {
    return {
        TAG: 0,
        _0: err,
        [Symbol.for("name")]: "SampleSetError"
    };
}
var $$Error = {
    fromString: fromString,
    toString: toString,
    resultStringToResultError: resultStringToResultError,
    sampleErrorToDistErr: sampleErrorToDistErr
};
function floatCallToString(floatFunction) {
    var variant = floatFunction.NAME;
    if (variant === "ToString") {
        var n = floatFunction.VAL;
        if (n) {
            return "sparkline(" + E_I$QuriSquiggleLang.toString(n._0) + ")";
        }
        else {
            return "toString";
        }
    }
    if (variant === "ToFloat") {
        var match = floatFunction.VAL;
        if (typeof match !== "object") {
            if (match === "Sample") {
                return "sample";
            }
            else if (match === "IntegralSum") {
                return "integralSum";
            }
            else if (match === "Max") {
                return "max";
            }
            else if (match === "Min") {
                return "min";
            }
            else if (match === "Stdev") {
                return "stdev";
            }
            else if (match === "Mean") {
                return "mean";
            }
            else if (match === "Mode") {
                return "mode";
            }
            else {
                return "variance";
            }
        }
        var variant$1 = match.NAME;
        if (variant$1 === "Inv") {
            return "inv(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
        }
        else if (variant$1 === "Pdf") {
            return "pdf(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
        }
        else {
            return "cdf(" + E_Float$QuriSquiggleLang.toFixed(match.VAL) + ")";
        }
    }
    if (variant === "ToBool") {
        return "isNormalized";
    }
    if (variant !== "ToDist") {
        if (floatFunction.VAL[0]) {
            return "algebraic";
        }
        else {
            return "pointwise";
        }
    }
    var r = floatFunction.VAL;
    if (typeof r === "number") {
        switch (r) {
            case 0:
                return "normalize";
            case 1:
                return "toPointSet";
            case 2:
                return "inspect";
        }
    }
    else {
        switch (r.TAG | 0) {
            case 0:
                return "toSampleSet(" + E_I$QuriSquiggleLang.toString(r._0) + ")";
            case 1:
                var match$1 = r._0;
                if (typeof match$1 === "object") {
                    return "scaleLogWithThreshold(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ", epsilon=" + E_Float$QuriSquiggleLang.toFixed(match$1.VAL) + ")";
                }
                else if (match$1 === "Power") {
                    return "scalePower(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
                }
                else if (match$1 === "Multiply") {
                    return "scaleMultiply(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
                }
                else {
                    return "scaleLog(" + E_Float$QuriSquiggleLang.toFixed(r._1) + ")";
                }
            case 2:
                return "truncate";
        }
    }
}
function distCallToString(distFunction) {
    var variant = distFunction.NAME;
    if (variant === "ToString") {
        return floatCallToString({
            NAME: "ToString",
            VAL: distFunction.VAL
        });
    }
    if (variant === "ToScore") {
        return "logScore";
    }
    if (variant === "ToFloat") {
        return floatCallToString({
            NAME: "ToFloat",
            VAL: distFunction.VAL
        });
    }
    if (variant === "ToBool") {
        return floatCallToString({
            NAME: "ToBool",
            VAL: distFunction.VAL
        });
    }
    if (variant === "ToDist") {
        return floatCallToString({
            NAME: "ToDist",
            VAL: distFunction.VAL
        });
    }
    var match = distFunction.VAL;
    return floatCallToString({
        NAME: "ToDistCombination",
        VAL: [
            match[0],
            match[1],
            match[2]
        ]
    });
}
function toString$1(d) {
    switch (d.TAG | 0) {
        case 0:
            return distCallToString(d._0);
        case 1:
            return floatCallToString(d._0);
        case 2:
            return "fromSamples";
        case 3:
            return "mixture";
    }
}
var DistributionOperation = {
    floatCallToString: floatCallToString,
    distCallToString: distCallToString,
    toString: toString$1
};
function mean(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: "Mean"
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function stdev(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: "Stdev"
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function variance(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: "Variance"
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function sample(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: "Sample"
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function cdf(dist, x) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: {
                NAME: "Cdf",
                VAL: x
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function inv(dist, x) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: {
                NAME: "Inv",
                VAL: x
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function pdf(dist, x) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToFloat",
            VAL: {
                NAME: "Pdf",
                VAL: x
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function normalize(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: 0
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function isNormalized(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToBool",
            VAL: 0
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function toPointSet(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: 1
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function toSampleSet(dist, r) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 0,
                _0: r,
                [Symbol.for("name")]: "ToSampleSet"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function fromSamples(xs) {
    return {
        TAG: 2,
        _0: xs,
        [Symbol.for("name")]: "FromSamples"
    };
}
function truncate(dist, left, right) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 2,
                _0: left,
                _1: right,
                [Symbol.for("name")]: "Truncate"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function inspect(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: 2
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function distEstimateDistAnswer(estimate, answer) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToScore",
            VAL: {
                _0: {
                    TAG: 0,
                    _0: answer,
                    [Symbol.for("name")]: "Score_Dist"
                },
                _1: undefined,
                [Symbol.for("name")]: "LogScore"
            }
        },
        _1: estimate,
        [Symbol.for("name")]: "FromDist"
    };
}
function distEstimateDistAnswerWithPrior(estimate, answer, prior) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToScore",
            VAL: {
                _0: {
                    TAG: 0,
                    _0: answer,
                    [Symbol.for("name")]: "Score_Dist"
                },
                _1: prior,
                [Symbol.for("name")]: "LogScore"
            }
        },
        _1: estimate,
        [Symbol.for("name")]: "FromDist"
    };
}
function distEstimateScalarAnswer(estimate, answer) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToScore",
            VAL: {
                _0: {
                    TAG: 1,
                    _0: answer,
                    [Symbol.for("name")]: "Score_Scalar"
                },
                _1: undefined,
                [Symbol.for("name")]: "LogScore"
            }
        },
        _1: estimate,
        [Symbol.for("name")]: "FromDist"
    };
}
function distEstimateScalarAnswerWithPrior(estimate, answer, prior) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToScore",
            VAL: {
                _0: {
                    TAG: 1,
                    _0: answer,
                    [Symbol.for("name")]: "Score_Scalar"
                },
                _1: prior,
                [Symbol.for("name")]: "LogScore"
            }
        },
        _1: estimate,
        [Symbol.for("name")]: "FromDist"
    };
}
var LogScore = {
    distEstimateDistAnswer: distEstimateDistAnswer,
    distEstimateDistAnswerWithPrior: distEstimateDistAnswerWithPrior,
    distEstimateScalarAnswer: distEstimateScalarAnswer,
    distEstimateScalarAnswerWithPrior: distEstimateScalarAnswerWithPrior
};
function scaleMultiply(dist, n) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 1,
                _0: "Multiply",
                _1: n,
                [Symbol.for("name")]: "Scale"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function scalePower(dist, n) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 1,
                _0: "Power",
                _1: n,
                [Symbol.for("name")]: "Scale"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function scaleLogarithm(dist, n) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 1,
                _0: "Logarithm",
                _1: n,
                [Symbol.for("name")]: "Scale"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function scaleLogarithmWithThreshold(dist, n, eps) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDist",
            VAL: {
                TAG: 1,
                _0: {
                    NAME: "LogarithmWithThreshold",
                    VAL: eps
                },
                _1: n,
                [Symbol.for("name")]: "Scale"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function toString$2(dist) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToString",
            VAL: 0
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function toSparkline(dist, n) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToString",
            VAL: {
                _0: n,
                [Symbol.for("name")]: "ToSparkline"
            }
        },
        _1: dist,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicAdd(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Add",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicMultiply(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Multiply",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicDivide(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Divide",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicSubtract(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Subtract",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicLogarithm(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Logarithm",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function algebraicPower(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                {
                    _0: 0,
                    [Symbol.for("name")]: "Algebraic"
                },
                "Power",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwiseAdd(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Add",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwiseMultiply(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Multiply",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwiseDivide(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Divide",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwiseSubtract(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Subtract",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwiseLogarithm(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Logarithm",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
function pointwisePower(dist1, dist2) {
    return {
        TAG: 0,
        _0: {
            NAME: "ToDistCombination",
            VAL: [
                0,
                "Power",
                {
                    NAME: "Dist",
                    VAL: dist2
                }
            ]
        },
        _1: dist1,
        [Symbol.for("name")]: "FromDist"
    };
}
var UsingDists = {
    mean: mean,
    stdev: stdev,
    variance: variance,
    sample: sample,
    cdf: cdf,
    inv: inv,
    pdf: pdf,
    normalize: normalize,
    isNormalized: isNormalized,
    toPointSet: toPointSet,
    toSampleSet: toSampleSet,
    fromSamples: fromSamples,
    truncate: truncate,
    inspect: inspect,
    LogScore: LogScore,
    scaleMultiply: scaleMultiply,
    scalePower: scalePower,
    scaleLogarithm: scaleLogarithm,
    scaleLogarithmWithThreshold: scaleLogarithmWithThreshold,
    toString: toString$2,
    toSparkline: toSparkline,
    algebraicAdd: algebraicAdd,
    algebraicMultiply: algebraicMultiply,
    algebraicDivide: algebraicDivide,
    algebraicSubtract: algebraicSubtract,
    algebraicLogarithm: algebraicLogarithm,
    algebraicPower: algebraicPower,
    pointwiseAdd: pointwiseAdd,
    pointwiseMultiply: pointwiseMultiply,
    pointwiseDivide: pointwiseDivide,
    pointwiseSubtract: pointwiseSubtract,
    pointwiseLogarithm: pointwiseLogarithm,
    pointwisePower: pointwisePower
};
var Constructors = {
    UsingDists: UsingDists
};
exports.$$Error = $$Error;
exports.DistributionOperation = DistributionOperation;
exports.Constructors = Constructors;
//# sourceMappingURL=DistributionTypes.bs.js.map