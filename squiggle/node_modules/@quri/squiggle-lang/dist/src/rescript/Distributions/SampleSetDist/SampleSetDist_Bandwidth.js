"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nrd = exports.nrd0 = void 0;
const iqr_percentile = 0.75;
const iqr_percentile_complement = 1 - iqr_percentile;
const nrd0_lo_denominator = 1.34;
const one = 1.0;
const nrd0_coef = 0.9;
const nrd_coef = 1.06;
const nrd_fractionalPower = -0.2;
const percentile = (xs, k) => {
    const realIndex = k * (xs.length - 1);
    const index = Math.floor(realIndex);
    if (index + 1 < xs.length) {
        const frac = realIndex - index;
        const x0 = xs[index];
        const x1 = xs[index + 1];
        return x0 + frac * (x1 - x0);
    }
    else {
        return xs[index];
    }
};
const variance = (xs) => {
    const n = xs.length;
    const offset = (xs[0] + xs[n - 1]) / 2;
    let sum = 0;
    let sumsq = 0;
    xs.forEach((x) => {
        let xOffset = x - offset;
        sum += xOffset;
        sumsq += xOffset * xOffset;
    });
    const mean = sum / n;
    return sumsq / n - mean * mean;
};
const iqr = (x) => percentile(x, iqr_percentile) - percentile(x, iqr_percentile_complement);
const nrd0 = (x) => {
    const hi = Math.sqrt(variance(x));
    const lo = Math.min(hi, iqr(x) / nrd0_lo_denominator);
    const e = Math.abs(x[1]);
    const loPrime = !isNaN(lo) ? lo : !isNaN(hi) ? hi : !isNaN(e) ? e : one;
    return nrd0_coef * loPrime * Math.pow(x.length, nrd_fractionalPower);
};
exports.nrd0 = nrd0;
const nrd = (x) => {
    const h = iqr(x) / nrd0_lo_denominator;
    return (nrd_coef *
        Math.min(Math.sqrt(variance(x)), h) *
        Math.pow(x.length, nrd_fractionalPower));
};
exports.nrd = nrd;
//# sourceMappingURL=SampleSetDist_Bandwidth.js.map