'use strict';
var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var SqError$QuriSquiggleLang = require("../SqError.bs.js");
var DateTime$QuriSquiggleLang = require("../Utility/DateTime.bs.js");
var Declaration$QuriSquiggleLang = require("../Utility/Declaration.bs.js");
var GenericDist$QuriSquiggleLang = require("../Distributions/GenericDist.bs.js");
function toString(aValue) {
    if (typeof aValue === "number") {
        return toStringVoid;
    }
    switch (aValue.TAG | 0) {
        case 0:
            return toStringArray(aValue._0);
        case 2:
            return DateTime$QuriSquiggleLang.$$Date.toString(aValue._0);
        case 3:
            return toStringDeclaration(aValue._0);
        case 4:
            return GenericDist$QuriSquiggleLang.toString(aValue._0);
        case 5:
            return toStringLambda(aValue._0);
        case 1:
        case 6:
            return String(aValue._0);
        case 7:
            return toStringMap(aValue._0);
        case 8:
            return toStringString(aValue._0);
        case 9:
            return DateTime$QuriSquiggleLang.Duration.toString(aValue._0);
    }
}
function toStringMap(aMap) {
    var pairs = Belt_MapString.toArray(aMap).map(function (param) {
        return "" + param[0] + ": " + toString(param[1]) + "";
    }).toString();
    return "{" + pairs + "}";
}
function toStringDeclaration(d) {
    return Declaration$QuriSquiggleLang.toString(d, (function (r) {
        return toString({
            TAG: 5,
            _0: r,
            [Symbol.for("name")]: "IEvLambda"
        });
    }));
}
function toStringString(aString) {
    return "'" + aString + "'";
}
function toStringArray(anArray) {
    var args = anArray.map(toString).toString();
    return "[" + args + "]";
}
function toStringLambda(lambdaValue) {
    if (lambdaValue.TAG === 0) {
        return "lambda(" + lambdaValue.parameters.toString() + "=>internal code)";
    }
    else {
        return "Builtin function";
    }
}
var toStringVoid = "()";
function toStringTimeDuration(t) {
    return DateTime$QuriSquiggleLang.Duration.toString(t);
}
var toStringDistribution = GenericDist$QuriSquiggleLang.toString;
function toStringDate(date) {
    return DateTime$QuriSquiggleLang.$$Date.toString(date);
}
function toStringNumber(aNumber) {
    return String(aNumber);
}
function toStringBool(aBool) {
    return String(aBool);
}
var toStringRecord = toStringMap;
function toStringCall(fName) {
    return ":" + fName + "";
}
function toStringSymbol(aString) {
    return ":" + aString + "";
}
function toStringWithType(aValue) {
    if (typeof aValue === "number") {
        return "Void";
    }
    switch (aValue.TAG | 0) {
        case 0:
            return "Array::" + toString(aValue) + "";
        case 1:
            return "Bool::" + toString(aValue) + "";
        case 3:
            return "Declaration::" + toString(aValue) + "";
        case 4:
            return "Distribution::" + toString(aValue) + "";
        case 5:
            return "Lambda::" + toString(aValue) + "";
        case 6:
            return "Number::" + toString(aValue) + "";
        case 7:
            return "Record::" + toString(aValue) + "";
        case 8:
            return "String::" + toString(aValue) + "";
        case 2:
        case 9:
            return "Date::" + toString(aValue) + "";
    }
}
function argsToString(args) {
    return args.map(toString).toString();
}
function toStringFunctionCall(param) {
    return "" + param[0] + "(" + argsToString(param[1]) + ")";
}
function toStringResult(x) {
    if (x.TAG === 0) {
        return "Ok(" + toString(x._0) + ")";
    }
    else {
        return "Error(" + SqError$QuriSquiggleLang.toString(x._0) + ")";
    }
}
function toStringResultOkless(codeResult) {
    if (codeResult.TAG === 0) {
        return toString(codeResult._0);
    }
    else {
        return "Error(" + SqError$QuriSquiggleLang.toString(codeResult._0) + ")";
    }
}
function valueToValueType(value) {
    if (typeof value === "number") {
        return 10;
    }
    switch (value.TAG | 0) {
        case 0:
            return 0;
        case 1:
            return 1;
        case 2:
            return 2;
        case 3:
            return 3;
        case 4:
            return 4;
        case 5:
            return 5;
        case 6:
            return 6;
        case 7:
            return 7;
        case 8:
            return 8;
        case 9:
            return 9;
    }
}
function functionCallToCallSignature(functionCall) {
    return {
        _0: functionCall[0],
        _1: functionCall[1].map(valueToValueType),
        [Symbol.for("name")]: "CallSignature"
    };
}
function valueTypeToString(valueType) {
    switch (valueType) {
        case 0:
            return "Array";
        case 1:
            return "Bool";
        case 2:
            return "Date";
        case 3:
            return "Declaration";
        case 4:
            return "Distribution";
        case 5:
            return "Lambda";
        case 6:
            return "Number";
        case 7:
            return "Record";
        case 8:
            return "String";
        case 9:
            return "Duration";
        case 10:
            return "Void";
    }
}
function functionCallSignatureToString(functionCallSignature) {
    return "" + functionCallSignature._0 + "(" + functionCallSignature._1.map(valueTypeToString).toString() + ")";
}
function arrayToValueArray(arr) {
    return arr;
}
function resultToValue(rExpression) {
    if (rExpression.TAG === 0) {
        return rExpression._0;
    }
    else {
        return SqError$QuriSquiggleLang.Message.$$throw(rExpression._0);
    }
}
var recordToKeyValuePairs = Belt_MapString.toArray;
var T;
exports.T = T;
exports.toString = toString;
exports.toStringArray = toStringArray;
exports.toStringBool = toStringBool;
exports.toStringCall = toStringCall;
exports.toStringDate = toStringDate;
exports.toStringDeclaration = toStringDeclaration;
exports.toStringDistribution = toStringDistribution;
exports.toStringLambda = toStringLambda;
exports.toStringNumber = toStringNumber;
exports.toStringRecord = toStringRecord;
exports.toStringString = toStringString;
exports.toStringSymbol = toStringSymbol;
exports.toStringTimeDuration = toStringTimeDuration;
exports.toStringVoid = toStringVoid;
exports.toStringMap = toStringMap;
exports.toStringWithType = toStringWithType;
exports.argsToString = argsToString;
exports.toStringFunctionCall = toStringFunctionCall;
exports.toStringResult = toStringResult;
exports.toStringResultOkless = toStringResultOkless;
exports.valueToValueType = valueToValueType;
exports.functionCallToCallSignature = functionCallToCallSignature;
exports.valueTypeToString = valueTypeToString;
exports.functionCallSignatureToString = functionCallSignatureToString;
exports.arrayToValueArray = arrayToValueArray;
exports.resultToValue = resultToValue;
exports.recordToKeyValuePairs = recordToKeyValuePairs;
//# sourceMappingURL=Reducer_Value.bs.js.map