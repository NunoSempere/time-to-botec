"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeVoid = exports.nodeTernary = exports.nodeString = exports.nodeModuleIdentifier = exports.nodeLetStatement = exports.nodeLambda = exports.nodeKeyValue = exports.nodeInteger = exports.nodeIdentifier = exports.nodeFloat = exports.nodeCall = exports.nodeBoolean = exports.nodeProgram = exports.nodeBlock = exports.constructRecord = exports.constructArray = exports.makeFunctionCall = exports.postOperatorToFunction = exports.unaryToFunction = exports.toFunction = void 0;
exports.toFunction = {
    "+": "add",
    "-": "subtract",
    "!=": "unequal",
    ".-": "dotSubtract",
    ".*": "dotMultiply",
    "./": "dotDivide",
    ".^": "dotPow",
    ".+": "dotAdd",
    "*": "multiply",
    "/": "divide",
    "&&": "and",
    "^": "pow",
    "<": "smaller",
    "<=": "smallerEq",
    "==": "equal",
    ">": "larger",
    ">=": "largerEq",
    "||": "or",
    to: "credibleIntervalToDistribution",
};
exports.unaryToFunction = {
    "-": "unaryMinus",
    "!": "not",
    ".-": "unaryDotMinus",
};
exports.postOperatorToFunction = {
    ".": "$_atIndex_$",
    "()": "$$_applyAll_$$",
    "[]": "$_atIndex_$",
};
function makeFunctionCall(fn, args, location) {
    if (fn === "$$_applyAll_$$") {
        return nodeCall(args[0], args.splice(1), location);
    }
    else {
        return nodeCall(nodeIdentifier(fn, location), args, location);
    }
}
exports.makeFunctionCall = makeFunctionCall;
function constructArray(elements, location) {
    return { type: "Array", elements, location };
}
exports.constructArray = constructArray;
function constructRecord(elements, location) {
    return { type: "Record", elements, location };
}
exports.constructRecord = constructRecord;
function nodeBlock(statements, location) {
    return { type: "Block", statements, location };
}
exports.nodeBlock = nodeBlock;
function nodeProgram(statements, location) {
    return { type: "Program", statements, location };
}
exports.nodeProgram = nodeProgram;
function nodeBoolean(value, location) {
    return { type: "Boolean", value, location };
}
exports.nodeBoolean = nodeBoolean;
function nodeCall(fn, args, location) {
    return { type: "Call", fn, args, location };
}
exports.nodeCall = nodeCall;
function nodeFloat(value, location) {
    return { type: "Float", value, location };
}
exports.nodeFloat = nodeFloat;
function nodeIdentifier(value, location) {
    return { type: "Identifier", value, location };
}
exports.nodeIdentifier = nodeIdentifier;
function nodeInteger(value, location) {
    return { type: "Integer", value, location };
}
exports.nodeInteger = nodeInteger;
function nodeKeyValue(key, value, location) {
    if (key.type === "Identifier") {
        key = Object.assign(Object.assign({}, key), { type: "String" });
    }
    return { type: "KeyValue", key, value, location };
}
exports.nodeKeyValue = nodeKeyValue;
function nodeLambda(args, body, location, name) {
    return { type: "Lambda", args, body, location, name: name === null || name === void 0 ? void 0 : name.value };
}
exports.nodeLambda = nodeLambda;
function nodeLetStatement(variable, value, location) {
    const patchedValue = value.type === "Lambda" ? Object.assign(Object.assign({}, value), { name: variable.value }) : value;
    return { type: "LetStatement", variable, value: patchedValue, location };
}
exports.nodeLetStatement = nodeLetStatement;
function nodeModuleIdentifier(value, location) {
    return { type: "ModuleIdentifier", value, location };
}
exports.nodeModuleIdentifier = nodeModuleIdentifier;
function nodeString(value, location) {
    return { type: "String", value, location };
}
exports.nodeString = nodeString;
function nodeTernary(condition, trueExpression, falseExpression, location) {
    return {
        type: "Ternary",
        condition,
        trueExpression,
        falseExpression,
        location,
    };
}
exports.nodeTernary = nodeTernary;
function nodeVoid(location) {
    return { type: "Void", location };
}
exports.nodeVoid = nodeVoid;
//# sourceMappingURL=helpers.js.map