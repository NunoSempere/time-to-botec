'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var E_A$QuriSquiggleLang = require("../Utility/E/E_A.bs.js");
var E_R$QuriSquiggleLang = require("../Utility/E/E_R.bs.js");
var Declaration$QuriSquiggleLang = require("../Utility/Declaration.bs.js");
var FunctionRegistry_Core$QuriSquiggleLang = require("../FunctionRegistry/FunctionRegistry_Core.bs.js");
var FunctionRegistry_Helpers$QuriSquiggleLang = require("../FunctionRegistry/FunctionRegistry_Helpers.bs.js");
var frType = {
    TAG: 0,
    _0: [
        [
            "fn",
            7
        ],
        [
            "inputs",
            {
                TAG: 2,
                _0: {
                    TAG: 0,
                    _0: [
                        [
                            "min",
                            0
                        ],
                        [
                            "max",
                            0
                        ]
                    ],
                    [Symbol.for("name")]: "FRTypeRecord"
                },
                [Symbol.for("name")]: "FRTypeArray"
            }
        ]
    ],
    [Symbol.for("name")]: "FRTypeRecord"
};
function fromExpressionValue(e) {
    var r = Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.Prepare.ToValueArray.Record.twoArgs, [e], [
        "fn",
        "inputs"
    ]);
    if (r.TAG !== 0) {
        return {
            TAG: 1,
            _0: r._0,
            [Symbol.for("name")]: "Error"
        };
    }
    var match = r._0;
    if (match.length !== 2) {
        return {
            TAG: 1,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.impossibleErrorString,
            [Symbol.for("name")]: "Error"
        };
    }
    var lambda = match[0];
    if (typeof lambda === "number") {
        return {
            TAG: 1,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.impossibleErrorString,
            [Symbol.for("name")]: "Error"
        };
    }
    if (lambda.TAG !== 5) {
        return {
            TAG: 1,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.impossibleErrorString,
            [Symbol.for("name")]: "Error"
        };
    }
    var lambda$1 = lambda._0;
    var inputs = match[1];
    if (typeof inputs === "number") {
        return {
            TAG: 1,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.impossibleErrorString,
            [Symbol.for("name")]: "Error"
        };
    }
    if (inputs.TAG !== 0) {
        return {
            TAG: 1,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.impossibleErrorString,
            [Symbol.for("name")]: "Error"
        };
    }
    var getMinMax = function (arg) {
        return E_R$QuriSquiggleLang.fmap(E_R$QuriSquiggleLang.bind(Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.Prepare.ToValueArray.Record.twoArgs, [arg], [
            "min",
            "max"
        ]), FunctionRegistry_Helpers$QuriSquiggleLang.Prepare.ToValueTuple.twoNumbers), (function (param) {
            return Declaration$QuriSquiggleLang.ContinuousFloatArg.make(param[0], param[1]);
        }));
    };
    return E_R$QuriSquiggleLang.fmap(E_A$QuriSquiggleLang.R.firstErrorOrOpen(E_A$QuriSquiggleLang.fmap(inputs._0, getMinMax)), (function (args) {
        return {
            TAG: 3,
            _0: Declaration$QuriSquiggleLang.make(lambda$1, args),
            [Symbol.for("name")]: "IEvDeclaration"
        };
    }));
}
var Declaration = {
    frType: frType,
    fromExpressionValue: fromExpressionValue
};
var nameSpace = "Function";
var library = [FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("declare", nameSpace, true, [FunctionRegistry_Core$QuriSquiggleLang.FnDefinition.make("declare", [frType], (function (inputs, param, param$1) {
            return E_R$QuriSquiggleLang.errMap(E_R$QuriSquiggleLang.bind(FunctionRegistry_Helpers$QuriSquiggleLang.getOrError(inputs, 0), fromExpressionValue), FunctionRegistry_Helpers$QuriSquiggleLang.wrapError);
        }), undefined)], ["Function.declare({\n  fn: {|a,b| a },\n  inputs: [\n    {min: 0, max: 100},\n    {min: 30, max: 50}\n  ]\n})"], 3, "Adds metadata to a function of the input ranges. Works now for numeric and date inputs. This is useful when making predictions. It allows you to limit the domain that your prediction will be used and scored within.", true, undefined)];
exports.Declaration = Declaration;
exports.nameSpace = nameSpace;
exports.library = library;
//# sourceMappingURL=FR_Fn.bs.js.map