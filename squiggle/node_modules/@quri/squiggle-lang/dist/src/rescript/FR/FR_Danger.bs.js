'use strict';
var Curry = require("@rescript/std/lib/js/curry.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_array = require("@rescript/std/lib/js/caml_array.js");
var E_A$QuriSquiggleLang = require("../Utility/E/E_A.bs.js");
var E_I$QuriSquiggleLang = require("../Utility/E/E_I.bs.js");
var E_R$QuriSquiggleLang = require("../Utility/E/E_R.bs.js");
var SqError$QuriSquiggleLang = require("../SqError.bs.js");
var Reducer_Lambda$QuriSquiggleLang = require("../Reducer/Reducer_Lambda.bs.js");
var Factorial = require("@stdlib/math/base/special/factorial");
var FunctionRegistry_Core$QuriSquiggleLang = require("../FunctionRegistry/FunctionRegistry_Core.bs.js");
var FunctionRegistry_Helpers$QuriSquiggleLang = require("../FunctionRegistry/FunctionRegistry_Helpers.bs.js");
var nameSpace = "Danger";
function laplace(successes, trials) {
    return (successes + 1.0) / (trials + 2.0);
}
function factorial(prim) {
    return Factorial(prim);
}
function choose(n, k) {
    return Factorial(n) / (Factorial(n - k) * Factorial(k));
}
function pow(base, exp) {
    return Math.pow(base, exp);
}
function binomial(n, k, p) {
    return choose(n, k) * Math.pow(p, k) * Math.pow(1.0 - p, n - k);
}
var Helpers = {
    laplace: laplace,
    factorial: factorial,
    choose: choose,
    pow: pow,
    binomial: binomial
};
var laplace$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("laplace", nameSpace, true, [Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.DefineFn.Numbers.twoToOne, "laplace", laplace)], ["Danger.laplace(1, 20)"], 6, undefined, undefined, undefined);
var factorial$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("factorial", nameSpace, true, [Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.DefineFn.Numbers.oneToOne, "factorial", factorial)], ["Danger.factorial(20)"], 6, undefined, undefined, undefined);
var choose$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("choose", nameSpace, true, [Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.DefineFn.Numbers.twoToOne, "choose", choose)], ["Danger.choose(1, 20)"], 6, undefined, undefined, undefined);
var binomial$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("binomial", nameSpace, true, [Curry._2(FunctionRegistry_Helpers$QuriSquiggleLang.DefineFn.Numbers.threeToOne, "binomial", binomial)], ["Danger.binomial(1, 20, 0.5)"], 6, undefined, undefined, undefined);
var Lib = {
    laplace: laplace$1,
    factorial: factorial$1,
    choose: choose$1,
    binomial: binomial$1
};
var Combinatorics = {
    Helpers: Helpers,
    Lib: Lib
};
function integrateFunctionBetweenWithNumIntegrationPoints(aLambda, min, max, numIntegrationPoints, context, reducer) {
    var applyFunctionAtFloatToFloatOption = function (point) {
        var pointAsInternalExpression = FunctionRegistry_Helpers$QuriSquiggleLang.Wrappers.evNumber(point);
        var resultAsInternalExpression = Reducer_Lambda$QuriSquiggleLang.doLambdaCall(aLambda, [pointAsInternalExpression], context, reducer);
        if (typeof resultAsInternalExpression === "number" || resultAsInternalExpression.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error 1 in Danger.integrate. It's possible that your function doesn't return a number, try definining auxiliaryFunction(x) = mean(yourFunction(x)) and integrate auxiliaryFunction instead",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        else {
            return {
                TAG: 0,
                _0: resultAsInternalExpression._0,
                [Symbol.for("name")]: "Ok"
            };
        }
    };
    var numTotalPoints = numIntegrationPoints | 0;
    var numInnerPoints = numTotalPoints - 2 | 0;
    var totalWeight = max - min;
    var weightForAnInnerPoint = totalWeight / E_I$QuriSquiggleLang.toFloat(numTotalPoints - 1 | 0);
    var weightForAnOuterPoint = totalWeight / E_I$QuriSquiggleLang.toFloat(numTotalPoints - 1 | 0) / 2.0;
    var innerPointIncrement = (max - min) / E_I$QuriSquiggleLang.toFloat(numTotalPoints - 1 | 0);
    var innerXs = E_A$QuriSquiggleLang.makeBy(numInnerPoints, (function (i) {
        return min + (i + 1 | 0) * innerPointIncrement;
    }));
    var ysOptions = E_A$QuriSquiggleLang.fmap(innerXs, applyFunctionAtFloatToFloatOption);
    var ys = E_A$QuriSquiggleLang.R.firstErrorOrOpen(ysOptions);
    if (ys.TAG !== 0) {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Integration error 2 in Danger.integrate. It's possible that your function doesn't return a number, try definining auxiliaryFunction(x) = mean(yourFunction(x)) and integrate auxiliaryFunction instead.Original error: " + SqError$QuriSquiggleLang.Message.toString(ys._0),
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    var innerPointsSum = E_A$QuriSquiggleLang.reduce(ys._0, 0.0, (function (a, b) {
        return a + b;
    }));
    var match = applyFunctionAtFloatToFloatOption(min);
    var match$1 = applyFunctionAtFloatToFloatOption(max);
    if (match.TAG !== 0) {
        return {
            TAG: 1,
            _0: match._0,
            [Symbol.for("name")]: "Error"
        };
    }
    if (match$1.TAG !== 0) {
        return {
            TAG: 1,
            _0: match$1._0,
            [Symbol.for("name")]: "Error"
        };
    }
    var result = (match._0 + match$1._0) * weightForAnOuterPoint + innerPointsSum * weightForAnInnerPoint;
    return {
        TAG: 0,
        _0: {
            TAG: 6,
            _0: result,
            [Symbol.for("name")]: "IEvNumber"
        },
        [Symbol.for("name")]: "Ok"
    };
}
var Helpers$1 = {
    integrateFunctionBetweenWithNumIntegrationPoints: integrateFunctionBetweenWithNumIntegrationPoints
};
var integrateFunctionBetweenWithNumIntegrationPoints$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("integrateFunctionBetweenWithNumIntegrationPoints", nameSpace, false, [FunctionRegistry_Core$QuriSquiggleLang.FnDefinition.make("integrateFunctionBetweenWithNumIntegrationPoints", [
        7,
        0,
        0,
        0
    ], (function (inputs, context, reducer) {
        if (inputs.length !== 4) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var aLambda = inputs[0];
        var match = inputs[3];
        if (typeof match === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (match.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (match._0 === 0.0) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 4 in Danger.integrate: Increment can't be 0.",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (typeof aLambda === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (aLambda.TAG !== 5) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var min = inputs[1];
        if (typeof min === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (min.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var max = inputs[2];
        if (typeof max === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (max.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 5 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var numIntegrationPoints = inputs[3];
        return integrateFunctionBetweenWithNumIntegrationPoints(aLambda._0, min._0, max._0, numIntegrationPoints._0, context, reducer);
    }), undefined)], ["Danger.integrateFunctionBetweenWithNumIntegrationPoints({|x| x+1}, 1, 10, 10)"], 6, undefined, undefined, undefined);
var integrateFunctionBetweenWithEpsilon = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("integrateFunctionBetweenWithEpsilon", nameSpace, false, [FunctionRegistry_Core$QuriSquiggleLang.FnDefinition.make("integrateFunctionBetweenWithEpsilon", [
        7,
        0,
        0,
        0
    ], (function (inputs, context, reducer) {
        if (inputs.length !== 4) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var aLambda = inputs[0];
        var match = inputs[3];
        if (typeof match === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (match.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (match._0 === 0.0) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error in Danger.integrate: Increment can't be 0.",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (typeof aLambda === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (aLambda.TAG !== 5) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var min = inputs[1];
        if (typeof min === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (min.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var min$1 = min._0;
        var max = inputs[2];
        if (typeof max === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (max.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Integration error 8 in Danger.integrate. Remember that inputs are (function, number (min), number (max), number(increment))",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var max$1 = max._0;
        var epsilon = inputs[3];
        return E_R$QuriSquiggleLang.errMap(integrateFunctionBetweenWithNumIntegrationPoints(aLambda._0, min$1, max$1, (max$1 - min$1) / epsilon._0, context, reducer), (function (b) {
            return {
                TAG: 15,
                _0: "Integration error 7 in Danger.integrate. Something went wrong along the way: " + SqError$QuriSquiggleLang.Message.toString(b),
                [Symbol.for("name")]: "REOther"
            };
        }));
    }), undefined)], ["Danger.integrateFunctionBetweenWithEpsilon({|x| x+1}, 1, 10, 0.1)"], 6, undefined, undefined, undefined);
var Lib$1 = {
    integrateFunctionBetweenWithNumIntegrationPoints: integrateFunctionBetweenWithNumIntegrationPoints$1,
    integrateFunctionBetweenWithEpsilon: integrateFunctionBetweenWithEpsilon
};
var Integration = {
    Helpers: Helpers$1,
    Lib: Lib$1
};
function findBiggestElementIndex(xs) {
    return E_A$QuriSquiggleLang.reducei(xs, 0, (function (acc, newElement, index) {
        if (newElement > Caml_array.get(xs, acc)) {
            return index;
        }
        else {
            return acc;
        }
    }));
}
function optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions(lambdas, funds, approximateIncrement, context, reducer) {
    var match = E_A$QuriSquiggleLang.length(lambdas) > 1;
    var match$1 = funds > 0.0;
    var match$2 = approximateIncrement > 0.0;
    var match$3 = funds > approximateIncrement;
    if (!match) {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Error in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions, number of functions should be greater than 1.",
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    if (!match$1) {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Error in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions, funds should be greater than 0.",
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    if (!match$2) {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Error in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions, approximateIncrement should be greater than 0.",
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    if (!match$3) {
        return {
            TAG: 1,
            _0: {
                TAG: 15,
                _0: "Error in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions, approximateIncrement should be smaller than funds amount.",
                [Symbol.for("name")]: "REOther"
            },
            [Symbol.for("name")]: "Error"
        };
    }
    var applyFunctionAtPoint = function (lambda, point) {
        var pointAsInternalExpression = FunctionRegistry_Helpers$QuriSquiggleLang.Wrappers.evNumber(point);
        var resultAsInternalExpression = Reducer_Lambda$QuriSquiggleLang.doLambdaCall(lambda, [pointAsInternalExpression], context, reducer);
        if (typeof resultAsInternalExpression === "number" || resultAsInternalExpression.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error 1 in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions. It's possible that your function doesn't return a number, try definining auxiliaryFunction(x) = mean(yourFunction(x)) and integrate auxiliaryFunction instead",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        else {
            return {
                TAG: 0,
                _0: resultAsInternalExpression._0,
                [Symbol.for("name")]: "Ok"
            };
        }
    };
    var numDivisions = Math.round(funds / approximateIncrement);
    var increment = funds / numDivisions;
    var arrayOfIncrements = Belt_Array.make(numDivisions | 0, increment);
    var initAccumulator = {
        TAG: 0,
        _0: {
            optimalAllocations: Belt_Array.make(E_A$QuriSquiggleLang.length(lambdas), 0.0),
            currentMarginalReturns: E_A$QuriSquiggleLang.R.firstErrorOrOpen(E_A$QuriSquiggleLang.fmap(lambdas, (function (lambda) {
                return applyFunctionAtPoint(lambda, 0.0);
            })))
        },
        [Symbol.for("name")]: "Ok"
    };
    var optimalAllocationEndAccumulator = E_A$QuriSquiggleLang.reduce(arrayOfIncrements, initAccumulator, (function (acc, newIncrement) {
        if (acc.TAG !== 0) {
            return {
                TAG: 1,
                _0: acc._0,
                [Symbol.for("name")]: "Error"
            };
        }
        var accInner = acc._0;
        var oldMarginalReturnsWrapped = accInner.currentMarginalReturns;
        if (oldMarginalReturnsWrapped.TAG !== 0) {
            return {
                TAG: 1,
                _0: oldMarginalReturnsWrapped._0,
                [Symbol.for("name")]: "Error"
            };
        }
        var oldMarginalReturns = oldMarginalReturnsWrapped._0;
        var indexOfBiggestDMR = findBiggestElementIndex(oldMarginalReturns);
        var newOptimalAllocations = accInner.optimalAllocations.slice(0);
        var newOptimalAllocationsi = Caml_array.get(newOptimalAllocations, indexOfBiggestDMR) + newIncrement;
        Caml_array.set(newOptimalAllocations, indexOfBiggestDMR, newOptimalAllocationsi);
        var lambdai = Caml_array.get(lambdas, indexOfBiggestDMR);
        var newMarginalResultsLambdai = applyFunctionAtPoint(lambdai, newOptimalAllocationsi);
        var newCurrentMarginalReturns;
        if (newMarginalResultsLambdai.TAG === 0) {
            var result = oldMarginalReturns.slice(0);
            Caml_array.set(result, indexOfBiggestDMR, newMarginalResultsLambdai._0);
            newCurrentMarginalReturns = {
                TAG: 0,
                _0: result,
                [Symbol.for("name")]: "Ok"
            };
        }
        else {
            newCurrentMarginalReturns = {
                TAG: 1,
                _0: newMarginalResultsLambdai._0,
                [Symbol.for("name")]: "Error"
            };
        }
        var newAcc = {
            optimalAllocations: newOptimalAllocations,
            currentMarginalReturns: newCurrentMarginalReturns
        };
        return {
            TAG: 0,
            _0: newAcc,
            [Symbol.for("name")]: "Ok"
        };
    }));
    if (optimalAllocationEndAccumulator.TAG === 0) {
        return {
            TAG: 0,
            _0: FunctionRegistry_Helpers$QuriSquiggleLang.Wrappers.evArrayOfEvNumber(optimalAllocationEndAccumulator._0.optimalAllocations),
            [Symbol.for("name")]: "Ok"
        };
    }
    else {
        return {
            TAG: 1,
            _0: optimalAllocationEndAccumulator._0,
            [Symbol.for("name")]: "Error"
        };
    }
}
var Helpers$2 = {
    findBiggestElementIndex: findBiggestElementIndex,
    optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions: optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions
};
var optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions$1 = FunctionRegistry_Core$QuriSquiggleLang.$$Function.make("optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions", nameSpace, false, [FunctionRegistry_Core$QuriSquiggleLang.FnDefinition.make("optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions", [
        {
            TAG: 2,
            _0: 7,
            [Symbol.for("name")]: "FRTypeArray"
        },
        0,
        0
    ], (function (inputs, context, reducer) {
        if (inputs.length !== 3) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var innerlambdas = inputs[0];
        if (typeof innerlambdas === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (innerlambdas.TAG !== 0) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var funds = inputs[1];
        if (typeof funds === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (funds.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var approximateIncrement = inputs[2];
        if (typeof approximateIncrement === "number") {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        if (approximateIncrement.TAG !== 6) {
            return {
                TAG: 1,
                _0: {
                    TAG: 15,
                    _0: "Error in Danger.diminishingMarginalReturnsForTwoFunctions",
                    [Symbol.for("name")]: "REOther"
                },
                [Symbol.for("name")]: "Error"
            };
        }
        var individuallyWrappedLambdas = E_A$QuriSquiggleLang.fmap(innerlambdas._0, (function (innerLambda) {
            if (typeof innerLambda === "number" || innerLambda.TAG !== 5) {
                return {
                    TAG: 1,
                    _0: {
                        TAG: 15,
                        _0: "Error in Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions. A member of the array wasn't a function",
                        [Symbol.for("name")]: "REOther"
                    },
                    [Symbol.for("name")]: "Error"
                };
            }
            else {
                return {
                    TAG: 0,
                    _0: innerLambda._0,
                    [Symbol.for("name")]: "Ok"
                };
            }
        }));
        var wrappedLambdas = E_A$QuriSquiggleLang.R.firstErrorOrOpen(individuallyWrappedLambdas);
        if (wrappedLambdas.TAG === 0) {
            return optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions(wrappedLambdas._0, funds._0, approximateIncrement._0, context, reducer);
        }
        else {
            return {
                TAG: 1,
                _0: wrappedLambdas._0,
                [Symbol.for("name")]: "Error"
            };
        }
    }), undefined)], ["Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions([{|x| x+1}, {|y| 10}], 100, 0.01)"], 0, undefined, undefined, undefined);
var Lib$2 = {
    optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions: optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions$1
};
var DiminishingReturns = {
    Helpers: Helpers$2,
    Lib: Lib$2
};
var library = [
    laplace$1,
    factorial$1,
    choose$1,
    binomial$1,
    integrateFunctionBetweenWithNumIntegrationPoints$1,
    integrateFunctionBetweenWithEpsilon,
    optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions$1
];
var requiresNamespace = true;
exports.nameSpace = nameSpace;
exports.requiresNamespace = requiresNamespace;
exports.Combinatorics = Combinatorics;
exports.Integration = Integration;
exports.DiminishingReturns = DiminishingReturns;
exports.library = library;
//# sourceMappingURL=FR_Danger.bs.js.map