export var nameSpace: string;
export var requiresNamespace: boolean;
export namespace Combinatorics {
    export { Helpers };
    export { Lib };
}
export namespace Integration {
    export { Helpers$1 as Helpers };
    export { Lib$1 as Lib };
}
export namespace DiminishingReturns {
    export { Helpers$2 as Helpers };
    export { Lib$2 as Lib };
}
export var library: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
}[];
declare namespace Helpers {
    export { laplace };
    export { factorial };
    export { choose };
    export { pow };
    export { binomial };
}
declare namespace Lib {
    export { laplace$1 as laplace };
    export { factorial$1 as factorial };
    export { choose$1 as choose };
    export { binomial$1 as binomial };
}
declare namespace Helpers$1 {
    export { integrateFunctionBetweenWithNumIntegrationPoints };
}
declare namespace Lib$1 {
    export { integrateFunctionBetweenWithNumIntegrationPoints$1 as integrateFunctionBetweenWithNumIntegrationPoints };
    export { integrateFunctionBetweenWithEpsilon };
}
declare namespace Helpers$2 {
    export { findBiggestElementIndex };
    export { optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions };
}
declare namespace Lib$2 {
    export { optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions$1 as optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions };
}
declare function laplace(successes: any, trials: any): number;
declare function factorial(prim: any): number;
declare function choose(n: any, k: any): number;
declare function pow(base: any, exp: any): number;
declare function binomial(n: any, k: any, p: any): number;
declare var laplace$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare var factorial$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare var choose$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare var binomial$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare function integrateFunctionBetweenWithNumIntegrationPoints(aLambda: any, min: any, max: any, numIntegrationPoints: any, context: any, reducer: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare var integrateFunctionBetweenWithNumIntegrationPoints$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare var integrateFunctionBetweenWithEpsilon: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
declare function findBiggestElementIndex(xs: any): any;
declare function optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions(lambdas: any, funds: any, approximateIncrement: any, context: any, reducer: any): {
    [x: symbol]: string;
    TAG: number;
    _0: any;
};
declare var optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions$1: {
    name: any;
    definitions: any;
    requiresNamespace: any;
    nameSpace: any;
    output: any;
    examples: any;
    description: any;
    isExperimental: any;
};
export {};
